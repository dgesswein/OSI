    1                  ;
    2                  ; DISK TEST UTILITY FOR C1P/UK101/C2PDF/C4PMF/C8P/C3-OEM
    3                  ; Supposed to work with serial or video and 8", 5.25", or 3.5" floppies. Tested
    4                  ; with C2 with 8" floppies, serial, and 540B video. Tested with OSI emulator
    5                  ; with 5.25" floppies.
    6                  ; Needs 16k memory.
    7                  ; Start at $300
    8                  ; Does write/read or read only test. Disk format is not compatible with
    9                  ; OSI operating systems. Can either print error information or generate
   10                  ; a pulse on fault reset to trigger scope on error. Can also show
   11                  ; drive status lines and allow manual control of drive control lines.
   12                  ; Will also measure drive RPM
   13                  ;
   14                  ; DESTRUCTIVE DISK READ/WRITE TEST
   15                  ; By David Gesswein djg@pdp8online.com
   16                  ; Initial release V1.00 05/04/2020
   17                  ; V1.04 12/28/2020. Fix from Mark Spankus to not check for polled keyboard
   18                  ;    on C3. Also some comment changes by DJG.
   19                  ; V1.03 07/18/2020. Experimental support for 3.5" drives from Jeff Tranter.
   20                  ; V1.02 05/28/2020. Fixes from Mark Spankus. Fixed W in status test hanging if
   21                  ;    drive not selected. Fixed C1 serial I/O code. Simplified code. Fixed
   22                  ;    polled keyboard code to work reliably on C1 and other machines. Fixed
   23                  ;    video to work with C1P though messages may not fit in 30 columns. Fixed
   24                  ;    video for SYNMON, SYN600, and CEGMON.
   25                  ; V1.01 05/16/2020. Fixed ANYKEY not aborting. Prevent specifying illegal
   26                  ;    track to test. Fixed printing false errors when no data read.
   27                  ;    Fixed issues with serial console getting selected on video system.
   28                  
   29                  ; All my changes are released as public domain. The original code did not have
   30                  ; any license specified.
   31                  ; For usage see http://www.pdp8online.com/osi/osi-floppy-test.shtml
   32                  
   33                  ;BASED ON https://osi.marks-lab.com/software/tools.html Universal OSIDump 
   34                  ;BASED ON ED'S OSIDUMP UTILITY
   35                  ;
   36                  ;
   37                  
   38  0300            ORG     =       $0300
   39                  
   40  0028            MAXTRK5 =       40      ; # TRACKS TO READ 5 1/4 disk
   41  000A            MAXPAG5 =       10      ; # PAGES TO READ  5 1/4 disk
   42  004D            MAXTRK8 =       77      ; # Tracks to read 8 disk
   43  000F            MAXPAG8 =       15      ; # Pages to read 8 disk
   44  0050            MAXTRK3 =       80      ; # Tracks to read 3 1/2 disk
   45  0010            MAXPAG3 =       16      ; # Pages to read 3 1/2 disk
   46  0877            BYTES5  = 2167
   47  0E10            BYTES8  = 3600
   48  10CC            BYTES3  = 4300
   49                  
   50  C000            DDPIA   =   $C000   ; Disk controller PIA
   51  C010            DDACIA  =   $C010   ; Disk Controller Serial Port
   52  FC00            C2ACIA  =   $FC00   ; ACIA on C2/C4/C8/C3
   53  F000            C1ACIA  =   $F000   ; ACIA on C1
   54                  
   55                  ;Control Character Constants XMODEM etc.
   56  000D            CR              =       $0D
   57  000A            LF              =       $0A
   58  001B            ESC             =       $1B             ; ESC to exit
   59                  
   60                  
   61                  ;storage space (anywhere, so why not page zero?)
   62  0029            STORE   =   $29   ;storage C4P starts stack at 28
   63  002A            MAXTRK  =   STORE+01 ;1 - 40 for 5.25, 77 for 8, 255 for HD
   64  002B            MAXPAG  =   STORE+02 ;1 - 9 for 5.25, 15 for 8, 16 for HD
   65  002C            ACIACTL =   STORE+03 ;1 controls cassette/rs-232 ACIA divisor, format
   66  002D            DRVNUM  =   STORE+04 ;1 drive# 0-3
   67  002E            TRK     =   STORE+05 ;1 current track #
   68  002F            TMP     =   STORE+6  ;1
   69  0030            MACHINE =   STORE+7  ;1 C1/C2/C3 flag 00=C2/4/8, $40=C3Ser, $80=C1
   70  0031            INVKEYB =   STORE+8  ;C1 polled = FF C2 polled = 00
   71                  
   72  0032                            *= STORE+9
   73  0032  00        VIDEO           .BYTE 0 ; 0 = Serial $FF = video
   74  0033  00        PATSEL          .BYTE 0 ;  0 = Fixed byte (PATVAL), $FF = random
   75  0034  00        PATVAL          .BYTE 0 ;  Byte to write to disk
   76  0035  00        PASSES          .BYTE 0
   77  0036  00        READONLY        .BYTE 0 ; zero read write
   78  0037  00        PASSCNTR        .BYTE 0
   79  0038  5C 9F 89  RND             .BYTE 92, 159, 137, 36, 210, 89
       003B  24 D2 59  
   80  003E  00 00 00  RNDHLD          .BYTE 0,0,0,0,0,0
       0041  00 00 00  
   81  0044  00 00 00  DIVIDEND        .BYTE 0,0,0
   82  0047  00 00 00  DIVISOR         .BYTE 0,0,0
   83  004A  00 00 00  REMAINDER       .BYTE 0,0,0
   84  004D  00 00 00  factor2         .BYTE 0,0,0
   85  0050  00        PZTEMP          .BYTE 0
   86  0051  00 00 00  MAX             .BYTE 0,0,0
   87  0054  00 00 00  MIN             .BYTE 0,0,0
   88  0057  00 00 00  SUM             .BYTE 0,0,0
   89  005A  00        pad             .BYTE 0
   90  005B  00 00     ERRCNT          .WORD 0
   91  005D  00        PRTERR          .BYTE 0
   92                  ; 8" RPM scale 360 RPM * (250000 bps/10 bits/byte/6 RPS) = 1500000
   93  005E  60 E3 16  RPMSCALE8       .BYTE $60, $e3, $16 
   94                  ; 5.25" RPM scale 300 * (125000/10/5) = 750000
   95  0061  B0 71 0B  RPMSCALE5       .BYTE $b0, $71, $0b 
   96                  ; 3.5" 720KB RPM scale 300 RPM * (250000 bps/10 bits/byte/5 RPS) = 1500000
   97  0064  60 E3 16  RPMSCALE3       .BYTE $60, $e3, $16
   98                  ; 3.5" 1.44MB RPM scale 300 RPM * (500000 bps/10 bits/byte/5 RPS) = 3000000
   99                  ;RPMSCALE3       .BYTE $c0, $c6, $2d
  100                  ; Allow 3% fast rotation and 1.25 delay after index high and 2.2 ms index
  101                  ; pulse;
  102  0067  00 00     MTRKBYTES       .WORD 0 ; negative number of bytes in track
  103  0069  00 00     BYTECNTR        .WORD 0
  104  006B  00        YHOLD           .BYTE 0
  105  006C  00        TESTTYPE        .BYTE 0 ; 0 normal 1 scope
  106                  
  107                  ;zero page storage
  108  006D  00        DRVACIA         .BYTE 0 ; Current serial word format for DISK ACIA 8E1/8N1
  109  006E  00 00     PTRSTOR         .WORD 0 
  110  0070  00 00     TDATA           .WORD 0
  111  0072  00 00     TDATA2          .WORD 0
  112  0074  40 D0     VIDSRC          .WORD $D040
  113  0076  00 D0     VIDDST          .WORD $D000
  114  0078  00        VIDOFFSET       .BYTE 0
  115  0079  00        VIDXLEN         .BYTE 0
  116  007A  00        VIDXMAX         .BYTE 0
  117  007B  00        MAXERR          .BYTE 0 ; number of errors + 1 to print
  118  007C  00        SINGLETRK       .BYTE 0; non zero if testing single track
  119                  
  120                          ; Serial monitor start values
  121  0129                    *= $129
  122  0129  00 00 00          .BYTE 0,0,0,0,$fd,ORG/256,ORG%256
       012C  00 FD 03  
       012F  00        
  123                  
  124  0300                    *=      ORG
  125  0300                    .EXE *        ;A65 emit OSI .lod start address operation
  126  0300  78                SEI
  127  0301  20 D3 12          JSR     VIDINIT
  128  0304  AD 01 FE          LDA     $FE01     ;determine machine type
  129  0307  F0 10             BEQ     SERTYP    ;Is this serial system?                                                    
  130  0309  A9 00             LDA     #$00
  131  030B  AA                TAX
  132  030C  8D 00 DF          STA     $DF00   
  133  030F  2C 00 DF          BIT     $DF00     ;okay check C1/C2-C4
  134  0312  30 02             BMI     C1TYPE
  135  0314  E8                INX
  136  0316            C1TYPE=*+1
  137  0315  2C A9 80          BIT     $80A9
  138  0319            SERTYP=*+1
  139  0318  2C A9 40          BIT     $40A9
  140  031B  CA                DEX
  141  031C  85 30             STA     MACHINE   ;bit 7 = C1, bit 6 = C3, none =C2/C4
  142  031E  86 31             STX     INVKEYB
  143  0320  A9 15             LDA     #$15      ;B1 = 8N2 /16 RTStxIRQ  rxIRQ ;$15 = 8N1 /16 RTSNOtxIRQ NOrxIRQ; $B5 = irqs on 8N1
  144  0322  85 2C             STA     ACIACTL
  145                          ; Not sure how to figure out if we should use serial or video.
  146                          ; First try to determine if a serial port exists. If it does we
  147                          ; print a message to both serial and video and see which the user
  148                          ; hits a key on to select between video and serial
  149  0324  A2 0A             LDX     #10     ; 10*1.25MS wait for last character to be output
  150  0326  20 F4 0F          JSR     DELAY
  151  0329  A2 00             LDX     #0
  152  032B  20 9F 12          JSR     CheckTXReady    ; If serial not ready likely no serial port
  153  032E  B0 01             BCS     SELLP           
  154  0330  CA                DEX                     ; so don't write to serial.
  155  0331            SELLP
  156  0331  20 66 12          JSR     Get_Chr         ; Flush serial data if any
  157  0334  86 32             STX     VIDEO           ; Select serial first then video
  158  0336  20 03 10          JSR     PRINT
  159  0339  0D 0A 48          .BYTE   CR,LF,'HIT ANY KEY TO SELECT CONSOLE DEVICE',CR,LF,0
       033C  49 54 20  
       033F  41 4E 59  
       0342  20 4B 45  
       0345  59 20 54  
       0348  4F 20 53  
       034B  45 4C 45  
       034E  43 54 20  
       0351  43 4F 4E  
       0354  53 4F 4C  
       0357  45 20 44  
       035A  45 56 49  
       035D  43 45 0D  
       0360  0A 00     
  160  0362  20 66 12          JSR     Get_Chr         ; Flush serial data if any
  161  0365  CA                DEX
  162  0366  E0 FE             CPX     #$FE            ; If we did both then we are done
  163  0368  D0 C7             BNE     SELLP
  164  036A            SELLP2
  165  036A  20 66 12          JSR     Get_Chr         ; Get serial character if one ready
  166  036D  B0 0C             BCS     SERCON          ; Got one, select serial
  167  036F  20 35 12          JSR     Check_Keypress  ; Check polled keyboard for key down
  168  0372  90 F6             BCC     SELLP2          ; Didn't find it
  169  0374  A2 FF             LDX     #$FF
  170  0376  A0 04             LDY     #4              ; Set video console and # of errors to print
  171  0378  4C 7F 03          JMP     STORECON
  172  037B            SERCON
  173  037B  A2 00             LDX     #0
  174  037D  A0 06             LDY     #6              ; Set serial console and # of errors to print
  175  037F            STORECON
  176  037F  86 32             STX     VIDEO
  177  0381  84 7B             STY     MAXERR
  178                  
  179  0383  A9 00             LDA     #$00    ; Reset various variables
  180  0385  85 2D             STA     DRVNUM
  181  0387  85 33             STA     PATSEL
  182  0389  85 6C             STA     TESTTYPE
  183  038B  85 36             STA     READONLY
  184  038D  85 2E             STA     TRK     ; We don't know the track so set to zero
  185                  
  186  038F  A9 01             LDA     #$01
  187  0391  85 35             STA     PASSES
  188  0393  A9 18             LDA     #$18
  189  0395  85 34             STA     PATVAL
  190  0397  24 30             BIT     MACHINE
  191  0399  50 03             BVC     *+5
  192  039B  4C 6C 04          JMP     SETDRV8  ;serial systems use 8" by default
  193  039E  4C 59 04          JMP     SETDRV5
  194                  
  195  03A1            TOP
  196  03A1  20 8D 10          JSR     DRWMENU ; Print menu
  197  03A4  20 66 12          JSR     Get_Chr         ; Flush serial data if any
  198  03A7  A2 00             LDX     #$00
  199  03A9  20 7E 12          JSR     INKEY   ; Key user input
  200  03AC  20 AF 12          JSR     OUTPUT
  201  03AF  C9 31             CMP     #$31    ; See if its a menu choice and do it
  202  03B1  D0 03             BNE     *+5
  203  03B3  4C E2 08          JMP     TEST
  204  03B6  C9 32             CMP     #$32
  205  03B8  D0 03             BNE     *+5
  206  03BA  4C 92 04          JMP     TESTTRK
  207  03BD  C9 33             CMP     #$33
  208  03BF  D0 03             BNE     *+5
  209  03C1  4C F5 05          JMP     SETDRV
  210  03C4  C9 34             CMP     #$34
  211  03C6  D0 03             BNE     *+5
  212  03C8  4C F7 03          JMP     DRVTYPE
  213  03CB  C9 35             CMP     #$35
  214  03CD  D0 03             BNE     *+5
  215  03CF  4C E9 04          JMP     SETPAT
  216  03D2  C9 36             CMP     #$36
  217  03D4  D0 09             BNE     CHECKNEXT
  218  03D6  A9 FF             LDA     #$FF
  219  03D8  45 36             EOR     READONLY
  220  03DA  85 36             STA     READONLY
  221  03DC  4C A1 03          JMP     TOP
  222  03DF            CHECKNEXT
  223  03DF  C9 37             CMP     #$37
  224  03E1  D0 03             BNE     *+5
  225  03E3  4C 3B 06          JMP     RPMTEST
  226  03E6  C9 38             CMP     #$38
  227  03E8  D0 03             BNE     *+5
  228  03EA  4C 20 14          JMP     STATSCRN
  229  03ED  C9 39             CMP     #$39
  230  03EF  D0 03             BNE     *+5
  231  03F1  6C FC FF          JMP     ($FFFC) ;Exit
  232  03F4  4C 51 04          JMP     INPERR
  233                  
  234  03F7            DRVTYPE
  235  03F7  20 03 10          JSR     PRINT
  236  03FA  0D 0A 45          .BYTE $D,$A,'Enter your disk drive type (8) inch, (5).25 inch, or (3).5 inch? >',0
       03FD  6E 74 65  
       0400  72 20 79  
       0403  6F 75 72  
       0406  20 64 69  
       0409  73 6B 20  
       040C  64 72 69  
       040F  76 65 20  
       0412  74 79 70  
       0415  65 20 28  
       0418  38 29 20  
       041B  69 6E 63  
       041E  68 2C 20  
       0421  28 35 29  
       0424  2E 32 35  
       0427  20 69 6E  
       042A  63 68 2C  
       042D  20 6F 72  
       0430  20 28 33  
       0433  29 2E 35  
       0436  20 69 6E  
       0439  63 68 3F  
       043C  20 3E 00  
  237  043F  20 7E 12          JSR     INKEY
  238  0442  20 AF 12          JSR     OUTPUT
  239  0445  C9 38             CMP     #$38
  240  0447  F0 23             BEQ     SETDRV8
  241  0449  C9 35             CMP     #$35
  242  044B  F0 0C             BEQ     SETDRV5
  243  044D  C9 33             CMP     #$33
  244  044F  F0 2E             BEQ     SETDRV3
  245  0451            INPERR
  246  0451  A9 3F             LDA     #'?     ; Print bad choice and menu again
  247  0453  20 AF 12          JSR     OUTPUT
  248  0456  4C A1 03          JMP     TOP
  249                  
  250  0459            SETDRV5
  251  0459  A9 28             LDA     #MAXTRK5
  252  045B  85 2A             STA     MAXTRK
  253  045D  A9 0A             LDA     #MAXPAG5
  254  045F  85 2B             STA     MAXPAG
  255  0461  A9 89             LDA     #-BYTES5%256
  256  0463  85 67             STA     MTRKBYTES
  257  0465  A9 F7             LDA     #-BYTES5/256
  258  0467  85 68             STA     MTRKBYTES+1
  259  0469  4C A1 03          JMP     TOP
  260                  
  261  046C            SETDRV8
  262  046C  A9 4D             LDA     #MAXTRK8
  263  046E  85 2A             STA     MAXTRK
  264  0470  A9 0F             LDA     #MAXPAG8
  265  0472  85 2B             STA     MAXPAG
  266  0474  A9 F0             LDA     #-BYTES8%256
  267  0476  85 67             STA     MTRKBYTES
  268  0478  A9 F1             LDA     #-BYTES8/256
  269  047A  85 68             STA     MTRKBYTES+1
  270  047C  4C A1 03          JMP     TOP
  271                  
  272  047F            SETDRV3
  273  047F  A9 50             LDA     #MAXTRK3
  274  0481  85 2A             STA     MAXTRK
  275  0483  A9 10             LDA     #MAXPAG3
  276  0485  85 2B             STA     MAXPAG
  277  0487  A9 34             LDA     #-BYTES3%256
  278  0489  85 67             STA     MTRKBYTES
  279  048B  A9 EF             LDA     #-BYTES3/256
  280  048D  85 68             STA     MTRKBYTES+1
  281  048F  4C A1 03          JMP     TOP
  282                  
  283                  
  284  0492            TESTTRK
  285  0492  20 03 10          JSR PRINT
  286  0495  0D 0A 45          .BYTE $D,$A,'Enter 2 digit decimal track to test > ',0
       0498  6E 74 65  
       049B  72 20 32  
       049E  20 64 69  
       04A1  67 69 74  
       04A4  20 64 65  
       04A7  63 69 6D  
       04AA  61 6C 20  
       04AD  74 72 61  
       04B0  63 6B 20  
       04B3  74 6F 20  
       04B6  74 65 73  
       04B9  74 20 3E  
       04BC  20 00     
  287  04BE  20 CF 05          JSR GETDEC2
  288  04C1  90 CF             BCC TESTTRK
  289  04C3  85 6B             STA YHOLD
  290  04C5  C5 2A             CMP MAXTRK      ; Don't allow more than MAXTRK
  291  04C7  10 C9             BPL TESTTRK
  292  04C9  20 20 0F          JSR INITPIA
  293  04CC  20 40 0F          JSR SELDRV
  294  04CF  20 5D 0F          JSR TZERO       ; STEP TO TRACK 0
  295  04D2  90 03             BCC *+5
  296  04D4  4C E9 0E          JMP NOTRK
  297  04D7  A5 6B             LDA YHOLD
  298  04D9  F0 07             BEQ TESTSTART
  299  04DB            TESTTN
  300  04DB  20 C1 0F          JSR TNEXT       ; Step to desired track
  301  04DE  C6 6B             DEC YHOLD
  302  04E0  D0 F9             BNE TESTTN
  303  04E2            TESTSTART
  304  04E2  A9 01             LDA #1          ; And set flag to only test the one track
  305  04E4  85 7C             STA SINGLETRK
  306  04E6  4C E6 08          JMP TEST2
  307                  
  308  04E9            SETPAT
  309  04E9  A9 00             LDA #0
  310  04EB  85 33             STA PATSEL
  311  04ED  20 03 10          JSR PRINT
  312  04F0  0D 0A 45          .BYTE $D,$A,'Enter hex fill pattern or space for random > ',0
       04F3  6E 74 65  
       04F6  72 20 68  
       04F9  65 78 20  
       04FC  66 69 6C  
       04FF  6C 20 70  
       0502  61 74 74  
       0505  65 72 6E  
       0508  20 6F 72  
       050B  20 73 70  
       050E  61 63 65  
       0511  20 66 6F  
       0514  72 20 72  
       0517  61 6E 64  
       051A  6F 6D 20  
       051D  3E 20 00  
  313  0520  20 7E 12          JSR INKEY
  314  0523  20 AF 12          JSR OUTPUT
  315  0526  29 7F             AND #$7F
  316  0528  C9 20             CMP #' '
  317  052A  F0 7D             BEQ PATRND
  318  052C  20 AE 05          JSR CONVHDIG
  319  052F  90 B8             BCC SETPAT
  320  0531  0A                ASL     ; Shift to high nibble
  321  0532  0A                ASL
  322  0533  0A                ASL
  323  0534  0A                ASL
  324  0535  AA                TAX
  325  0536  20 7E 12          JSR INKEY       ; Get and combine with low nibble
  326  0539  20 AF 12          JSR OUTPUT
  327  053C  20 AE 05          JSR CONVHDIG
  328  053F  90 A8             BCC SETPAT
  329  0541  85 2F             STA TMP
  330  0543  8A                TXA
  331  0544  05 2F             ORA TMP
  332  0546  85 34             STA PATVAL
  333  0548            GETPASSES
  334  0548  20 03 10          JSR PRINT
  335  054B  0D 0A 45          .BYTE $D,$A,'Enter two digit passes > ',0
       054E  6E 74 65  
       0551  72 20 74  
       0554  77 6F 20  
       0557  64 69 67  
       055A  69 74 20  
       055D  70 61 73  
       0560  73 65 73  
       0563  20 3E 20  
       0566  00        
  336  0567  20 CF 05          JSR GETDEC2
  337  056A  90 DC             BCC GETPASSES
  338  056C  85 35             STA PASSES
  339                  
  340  056E            GETTYPE
  341  056E  20 03 10          JSR PRINT
  342  0571  0D 0A 28          .BYTE $D,$A,'(S)cope test or (N)ormal > ',0
       0574  53 29 63  
       0577  6F 70 65  
       057A  20 74 65  
       057D  73 74 20  
       0580  6F 72 20  
       0583  28 4E 29  
       0586  6F 72 6D  
       0589  61 6C 20  
       058C  3E 20 00  
  343  058F  20 7E 12          JSR INKEY
  344  0592  20 AF 12          JSR OUTPUT
  345  0595  29 7F             AND #$7F
  346  0597  09 20             ORA #$20
  347  0599  A2 00             LDX #0
  348  059B  C9 6E             CMP #'n'
  349  059D  F0 05             BEQ SETTYPE
  350  059F  E8                INX
  351  05A0  C9 73             CMP #'s'
  352  05A2  D0 CA             BNE GETTYPE
  353  05A4            SETTYPE
  354  05A4  86 6C             STX TESTTYPE
  355  05A6  4C A1 03          JMP TOP
  356  05A9            PATRND
  357  05A9  C6 33             DEC PATSEL
  358  05AB  4C 48 05          JMP GETPASSES
  359                  
  360  05AE            CONVHDIG
  361  05AE  20 BE 05          JSR CONVDIG
  362  05B1  B0 0A             BCS CONVHRET
  363  05B3  C9 61             CMP #'a'
  364  05B5  30 16             BMI CONVERR
  365  05B7  C9 67             CMP #'f'+1
  366  05B9  10 12             BPL CONVERR
  367  05BB  E9 56             SBC #'a'-1-10
  368  05BD            CONVHRET
  369  05BD  60                RTS
  370  05BE            CONVDIG
  371  05BE  29 7F             AND #$7F
  372  05C0  09 20             ORA #$20
  373  05C2  C9 30             CMP #'0'
  374  05C4  30 07             BMI CONVERR
  375  05C6  C9 3A             CMP #'9'+1
  376  05C8  10 03             BPL CONVERR
  377  05CA  E9 2F             SBC #'0'-1
  378  05CC  60                RTS
  379  05CD            CONVERR
  380  05CD  18                CLC
  381  05CE  60                RTS
  382                  
  383                  ; Return 2 digit decimal number in A. Carry clear if number valid
  384  05CF            GETDEC2
  385  05CF  20 7E 12          JSR INKEY
  386  05D2  20 AF 12          JSR OUTPUT
  387  05D5  20 BE 05          JSR CONVDIG
  388  05D8  90 1A             BCC GETDEC2RET
  389  05DA  85 2F             STA TMP
  390  05DC  0A                ASL             ; Multiply by 8
  391  05DD  0A                ASL
  392  05DE  0A                ASL
  393  05DF  65 2F             ADC TMP         ; And add twice to make multiply by 10
  394  05E1  65 2F             ADC TMP
  395  05E3  85 2F             STA TMP
  396  05E5  20 7E 12          JSR INKEY       ; Get and add low digit
  397  05E8  20 AF 12          JSR OUTPUT
  398  05EB  20 BE 05          JSR CONVDIG
  399  05EE  90 04             BCC GETDEC2RET
  400  05F0  18                CLC
  401  05F1  65 2F             ADC TMP
  402  05F3  38                SEC
  403  05F4            GETDEC2RET              ; Not valid number, return carry clear
  404  05F4  60                RTS
  405                  
  406  05F5            SETDRV
  407  05F5  20 03 10          JSR PRINT
  408  05F8  0D 0A 53          .BYTE $D,$A,'Select drive (A), (B), (C), (D) ? >',0
       05FB  65 6C 65  
       05FE  63 74 20  
       0601  64 72 69  
       0604  76 65 20  
       0607  28 41 29  
       060A  2C 20 28  
       060D  42 29 2C  
       0610  20 28 43  
       0613  29 2C 20  
       0616  28 44 29  
       0619  20 3F 20  
       061C  3E 00     
  409  061E  20 7E 12          JSR INKEY
  410  0621  20 AF 12          JSR OUTPUT
  411  0624  29 5F             AND #$5F
  412  0626  C9 41             CMP #'A
  413  0628  90 0B             BCC SETERR
  414  062A  C9 45             CMP #'E
  415  062C  B0 07             BCS SETERR
  416  062E  E9 40             SBC #'@         ;carry is clear so val -1
  417  0630  85 2D             STA DRVNUM
  418  0632  4C A1 03          JMP TOP
  419  0635            SETERR
  420  0635  4C 51 04          JMP INPERR
  421                  
  422  0638            NOTRK2
  423  0638  4C E9 0E          JMP NOTRK
  424                          ; Test drive RPM with head unloaded and loaded
  425                          ; We count number of bytes sent through disk serial port between
  426                          ; index pulses to measure RPM. That is independent of CPU speed.
  427                          ; We use 8N1 for 10 total bits.
  428                          ; 8" = 25,000 characters per second, 5.25" 12,500, 3.5" 720k 25,000 
  429                          ; 3.5" 1.44M (not yet supported) 50,000.
  430                          ; 16 measurements are done with minimum, maximum, and avarage
  431                          ; printed
  432  063B            RPMTEST
  433  063B  20 20 0F          JSR INITPIA
  434  063E  20 40 0F          JSR SELDRV
  435  0641  20 5D 0F          JSR TZERO       ; STEP TO TRACK 0
  436  0644  B0 F2             BCS NOTRK2
  437  0646  A9 03             LDA #3
  438  0648  8D 10 C0          STA DDACIA      ; RESET ACIA
  439  064B  A9 54             LDA #$54    ;0 10 101 00 ;$54-  recv irq, RTS HIGH no xmit irq,  8N1,  DIVIDE BY 1,
  440  064D  85 6D             STA DRVACIA     
  441  064F  8D 10 C0          STA DDACIA      ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  442  0652  20 03 10          JSR PRINT
  443  0655  0D 0A 48          .BYTE $D,$A,'Head unloaded ',0
       0658  65 61 64  
       065B  20 75 6E  
       065E  6C 6F 61  
       0661  64 65 64  
       0664  20 00     
  444  0666  20 D6 06          JSR RPMTST2
  445  0669  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
  446  066C  29 7F             AND #$7F        ; 0111 1111
  447  066E  8D 02 C0          STA DDPIA+2     ; LOAD DISK HEAD
  448  0671  A2 FF             LDX #$FF        ; 320MS
  449  0673  20 F4 0F          JSR DELAY
  450  0676  20 03 10          JSR PRINT
  451  0679  0D 0A 48          .BYTE $D,$A,'Head loaded   ',0
       067C  65 61 64  
       067F  20 6C 6F  
       0682  61 64 65  
       0685  64 20 20  
       0688  20 00     
  452  068A  20 D6 06          JSR RPMTST2
  453  068D            RPMUNLOAD
  454  068D  AD 02 C0          LDA DDPIA+2
  455  0690  09 80             ORA #$80        
  456  0692  8D 02 C0          STA DDPIA+2     ; UNLOAD DISK HEAD
  457  0695  4C A1 03          JMP TOP
  458  0698            INDEXACT
  459  0698  20 03 10          JSR PRINT
  460  069B  49 6E 64          .BYTE 'Index stuck active',CR,LF,0
       069E  65 78 20  
       06A1  73 74 75  
       06A4  63 6B 20  
       06A7  61 63 74  
       06AA  69 76 65  
       06AD  0D 0A 00  
  461  06B0  20 5E 10          JSR ANYKEY
  462  06B3  4C 8D 06          JMP RPMUNLOAD
  463  06B6            INDEXINACT
  464  06B6  20 03 10          JSR PRINT
  465  06B9  49 6E 64          .BYTE 'Index stuck inactive',CR,LF,0
       06BC  65 78 20  
       06BF  73 74 75  
       06C2  63 6B 20  
       06C5  69 6E 61  
       06C8  63 74 69  
       06CB  76 65 0D  
       06CE  0A 00     
  466  06D0  20 5E 10          JSR ANYKEY
  467  06D3  4C 8D 06          JMP RPMUNLOAD
  468  06D6            RPMTST2
  469  06D6  A2 00             LDX #0
  470  06D8  A0 00             LDY #0
  471  06DA            RPMTSTLP
  472  06DA  E8                INX
  473  06DB  D0 01             BNE *+3
  474  06DD  C8                INY
  475  06DE  F0 B8             BEQ INDEXACT
  476  06E0  2C 00 C0          BIT DDPIA       ; WAIT END OF
  477  06E3  10 F5             BPL RPMTSTLP    ; INDEX PULSE
  478  06E5  A9 00             LDA #0
  479  06E7  85 47             STA DIVISOR     ; Clear variables
  480  06E9  85 48             STA DIVISOR+1
  481  06EB  85 49             STA DIVISOR+2
  482  06ED  85 51             STA MAX
  483  06EF  85 52             STA MAX+1
  484  06F1  85 53             STA MAX+2
  485  06F3  85 57             STA SUM
  486  06F5  85 58             STA SUM+1
  487  06F7  85 59             STA SUM+2
  488  06F9  A9 FF             LDA #255
  489  06FB  85 54             STA MIN
  490  06FD  85 55             STA MIN+1
  491  06FF  85 56             STA MIN+2
  492  0701  A2 10             LDX #16         ; Measure RPM 16 times
  493  0703  A0 00             LDY #0
  494  0705  A9 00             LDA #0
  495  0707  18                CLC
  496  0708            RPMLP1
  497                          ; Wait for index then write first byte to UART since it
  498                          ; should be ready. Then write a second byte since it should either
  499                          ; be ready immediatly or very shortly after first byte is transferred
  500                          ; to TX shift register. Then start counting with the writes that
  501                          ; will happen at the UART data rate.
  502  0708  C8                INY
  503  0709  D0 02             BNE *+4
  504  070B  69 01             ADC #1
  505  070D  F0 A7             BEQ INDEXINACT  ; If we wait to long for index inactive print error
  506  070F  2C 00 C0          BIT DDPIA       ; WAIT for INDEX PULSE
  507  0712  30 F4             BMI RPMLP1
  508  0714  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  509  0717            RPMNDX0
  510  0717  A9 02             LDA #2
  511  0719  2D 10 C0          AND DDACIA      ;test tx ready? 
  512  071C  F0 F9             BEQ RPMNDX0     ;not ready?
  513  071E  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  514  0721            RPMNDX1
  515  0721  A9 02             LDA #2
  516  0723  2D 10 C0          AND DDACIA      ;test tx ready? 
  517  0726  F0 F9             BEQ RPMNDX1     ;not ready?
  518  0728  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  519  072B  E6 47             INC DIVISOR
  520  072D  D0 02             BNE *+4
  521  072F  E6 48             INC DIVISOR+1
  522  0731  D0 02             BNE *+4
  523  0733  E6 49             INC DIVISOR+2
  524  0735  2C 00 C0          BIT DDPIA       ; WAIT END OF
  525  0738  10 E7             BPL RPMNDX1     ; INDEX PULSE
  526  073A            RPMNDX2
  527  073A  2C 00 C0          BIT DDPIA       ; DONE IF 
  528  073D  10 17             BPL RPMNDX3     ; INDEX PULSE
  529  073F  A9 02             LDA #2
  530  0741  2D 10 C0          AND DDACIA      ;test tx ready? 
  531  0744  F0 F4             BEQ RPMNDX2     ;not ready?
  532  0746  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  533  0749  E6 47             INC DIVISOR     ; Count character sent
  534  074B  D0 02             BNE *+4
  535  074D  E6 48             INC DIVISOR+1
  536  074F  D0 02             BNE *+4
  537  0751  E6 49             INC DIVISOR+2
  538  0753  4C 3A 07          JMP RPMNDX2
  539  0756            RPMNDX3
  540  0756  2C 00 C0          BIT DDPIA       ; WAIT END OF
  541  0759  10 FB             BPL RPMNDX3     ; INDEX PULSE
  542  075B  18                CLC
  543  075C  A5 57             LDA SUM         ; Sum of all rotation time
  544  075E  65 47             ADC DIVISOR
  545  0760  85 57             STA SUM
  546  0762  A5 58             LDA SUM+1
  547  0764  65 48             ADC DIVISOR+1
  548  0766  85 58             STA SUM+1
  549  0768  A5 59             LDA SUM+2
  550  076A  65 49             ADC DIVISOR+2
  551  076C  85 59             STA SUM+2
  552                  
  553  076E  A5 49             LDA DIVISOR+2
  554  0770  C5 56             CMP MIN+2
  555  0772  90 35             BCC LESS1
  556  0774  D0 0E             BNE GE1
  557  0776  A5 48             LDA DIVISOR+1
  558  0778  C5 55             CMP MIN+1
  559  077A  90 2D             BCC LESS1
  560  077C  D0 06             BNE GE1
  561  077E  A5 47             LDA DIVISOR
  562  0780  C5 54             CMP MIN
  563  0782  90 25             BCC LESS1
  564  0784            GE1     ; DIVISOR >= MIN
  565  0784  A5 49             LDA DIVISOR+2
  566  0786  C5 53             CMP MAX+2
  567  0788  90 2E             BCC LESS2
  568  078A  D0 0E             BNE GE2
  569  078C  A5 48             LDA DIVISOR+1
  570  078E  C5 52             CMP MAX+1
  571  0790  90 26             BCC LESS2
  572  0792  D0 06             BNE GE2
  573  0794  A5 47             LDA DIVISOR
  574  0796  C5 51             CMP MAX
  575  0798  90 1E             BCC LESS2
  576  079A            GE2     ; DIVISOR >= MAX
  577  079A  A5 47             LDA DIVISOR
  578  079C  85 51             STA MAX
  579  079E  A5 48             LDA DIVISOR+1
  580  07A0  85 52             STA MAX+1
  581  07A2  A5 49             LDA DIVISOR+2
  582  07A4  85 53             STA MAX+2
  583  07A6  4C B8 07          JMP LESS2
  584                  
  585  07A9            LESS1   ; DIVISOR < MIN
  586  07A9  A5 47             LDA DIVISOR
  587  07AB  85 54             STA MIN
  588  07AD  A5 48             LDA DIVISOR+1
  589  07AF  85 55             STA MIN+1
  590  07B1  A5 49             LDA DIVISOR+2
  591  07B3  85 56             STA MIN+2
  592  07B5  4C 84 07          JMP GE1
  593                          
  594  07B8            LESS2   ; DIVISOR < MAX
  595  07B8  CA                DEX
  596  07B9  F0 0B             BEQ RPMDONE
  597  07BB  A9 00             LDA #0
  598  07BD  85 47             STA DIVISOR
  599  07BF  85 48             STA DIVISOR+1
  600  07C1  85 49             STA DIVISOR+2
  601  07C3  4C 08 07          JMP RPMLP1
  602                  
  603  07C6            RPMDONE
  604  07C6  20 03 10          JSR PRINT
  605  07C9  52 50 4D          .BYTE 'RPM: AVG ',0
       07CC  3A 20 41  
       07CF  56 47 20  
       07D2  00        
  606  07D3  A2 04             LDX #4          ; Divide by 16 to convert sum to average
  607  07D5            RPMDIVL
  608  07D5  18                CLC
  609  07D6  66 59             ROR SUM+2
  610  07D8  66 58             ROR SUM+1
  611  07DA  66 57             ROR SUM
  612  07DC  CA                DEX
  613  07DD  D0 F6             BNE RPMDIVL
  614  07DF  A5 57             LDA SUM
  615  07E1  85 47             STA DIVISOR
  616  07E3  A5 58             LDA SUM+1
  617  07E5  85 48             STA DIVISOR+1
  618  07E7  A5 59             LDA SUM+2
  619  07E9  85 49             STA DIVISOR+2
  620  07EB  20 1F 08          JSR RPMPRT
  621                  
  622  07EE  20 03 10          JSR PRINT
  623  07F1  20 20 4D          .BYTE '  MIN',0
       07F4  49 4E 00  
  624                  
  625  07F7  A5 51             LDA MAX
  626  07F9  85 47             STA DIVISOR
  627  07FB  A5 52             LDA MAX+1
  628  07FD  85 48             STA DIVISOR+1
  629  07FF  A5 53             LDA MAX+2
  630  0801  85 49             STA DIVISOR+2
  631  0803  20 1F 08          JSR RPMPRT
  632                  
  633  0806  20 03 10          JSR PRINT
  634  0809  20 20 4D          .BYTE '  MAX',0
       080C  41 58 00  
  635                  
  636  080F  A5 54             LDA MIN
  637  0811  85 47             STA DIVISOR
  638  0813  A5 55             LDA MIN+1
  639  0815  85 48             STA DIVISOR+1
  640  0817  A5 56             LDA MIN+2
  641  0819  85 49             STA DIVISOR+2
  642  081B  20 1F 08          JSR RPMPRT
  643  081E  60                RTS
  644                  
  645                          ; Convert count to RPM with two decimal places
  646  081F            RPMPRT
  647  081F  A5 2B             LDA MAXPAG
  648  0821  C9 0F             CMP #MAXPAG8
  649  0823  F0 22             BEQ RPM8
  650  0825  C9 0A             CMP #MAXPAG5
  651  0827  F0 0F             BEQ RPM5
  652                  
  653  0829  A5 64             LDA RPMSCALE3
  654  082B  85 44             STA DIVIDEND
  655  082D  A5 65             LDA RPMSCALE3+1
  656  082F  85 45             STA DIVIDEND+1
  657  0831  A5 66             LDA RPMSCALE3+2
  658  0833  85 46             STA DIVIDEND+2
  659  0835  4C 53 08          JMP DODIV
  660                  
  661  0838  A5 61     RPM5    LDA RPMSCALE5
  662  083A  85 44             STA DIVIDEND
  663  083C  A5 62             LDA RPMSCALE5+1
  664  083E  85 45             STA DIVIDEND+1
  665  0840  A5 63             LDA RPMSCALE5+2
  666  0842  85 46             STA DIVIDEND+2
  667  0844  4C 53 08          JMP DODIV
  668  0847            RPM8
  669  0847  A5 5E             LDA RPMSCALE8
  670  0849  85 44             STA DIVIDEND
  671  084B  A5 5F             LDA RPMSCALE8+1
  672  084D  85 45             STA DIVIDEND+1
  673  084F  A5 60             LDA RPMSCALE8+2
  674  0851  85 46             STA DIVIDEND+2
  675  0853            DODIV
  676  0853  20 AD 13          JSR DIV24       ; Get integer part of RPM
  677  0856  A9 20             LDA #' '
  678  0858  85 5A             STA pad
  679  085A  20 98 08          JSR PrDec16
  680  085D  A9 64             LDA #100        ; Multiply remainder by 100 and divide again to get
  681  085F  85 4D             STA factor2     ; fractional part
  682  0861  A9 00             LDA #0
  683  0863  85 4E             STA factor2+1
  684  0865  85 4F             STA factor2+2
  685  0867  20 E3 13          JSR MULT24
  686  086A  20 AD 13          JSR DIV24
  687  086D  A9 2E             LDA #'.'
  688  086F  20 AF 12          JSR OUTPUT
  689  0872  A9 30             LDA #'0'
  690  0874  85 5A             STA pad
  691  0876  A0 02             LDY #2                       ; Print 2 digits
  692  0878  20 9A 08          JSR PrDec16Lp1
  693  087B  60                RTS
  694                          
  695                     ; From http://beebwiki.mdfs.net/Number_output_in_6502_machine_code
  696                     ; ---------------------------
  697                     ; Print 16-bit decimal number
  698                     ; ---------------------------
  699                     ; On entry, num=number to print
  700                     ;           pad=0 or pad character (eg '0' or ' ')
  701                     ; On entry at PrDec16Lp1,
  702                     ;           Y=(number of digits)*2-2, eg 8 for 5 digits
  703                     ; On exit,  A,X,Y,num,pad corrupted
  704                     ; Size      69 bytes
  705                     ; -----------------------------------------------------------------
  706  0044            num = DIVIDEND
  707                  
  708  087C            PrDec2Dig
  709  087C  85 44        STA num
  710  087E  A9 00        LDA #0
  711  0880  85 45        STA num+1
  712  0882  A9 20        LDA #' '
  713  0884  85 5A        STA pad
  714  0886  A0 02        LDY #2
  715  0888  4C 9A 08     JMP PrDec16Lp1
  716  088B            PrDec4Dig
  717  088B  86 44        STX num
  718  088D  85 45        STA num+1
  719  088F  A9 20        LDA #' '
  720  0891  85 5A        STA pad
  721  0893  A0 06        LDY #6
  722  0895  4C 9A 08     JMP PrDec16Lp1
  723                  
  724  0898            PrDec16
  725  0898  A0 08        LDY #8               ; Offset to powers of ten
  726  089A            PrDec16Lp1
  727  089A  A2 FF        LDX #$FF
  728  089C  38           SEC                  ; Start with digit=-1
  729  089D            PrDec16Lp2
  730  089D  A5 44        LDA num+0
  731  089F  F9 D8 08     SBC PrDec16Tens+0,Y
  732  08A2  85 44        STA num+0            ; Subtract current tens
  733  08A4  A5 45        LDA num+1
  734  08A6  F9 D9 08     SBC PrDec16Tens+1,Y
  735  08A9  85 45        STA num+1
  736  08AB  E8           INX
  737  08AC  B0 EF        BCS PrDec16Lp2       ; Loop until <0
  738  08AE  A5 44        LDA num+0
  739  08B0  79 D8 08     ADC PrDec16Tens+0,Y
  740  08B3  85 44        STA num+0            ; Add current tens back in
  741  08B5  A5 45        LDA num+1
  742  08B7  79 D9 08     ADC PrDec16Tens+1,Y
  743  08BA  85 45        STA num+1
  744  08BC  8A           TXA
  745  08BD  C0 00        CPY #0
  746  08BF  F0 09        BEQ PrDec16Digit     ; Last digit, always print
  747  08C1  8A           TXA
  748  08C2  D0 06        BNE PrDec16Digit     ; Not zero, print it
  749  08C4  A5 5A        LDA pad
  750  08C6  D0 08        BNE PrDec16Print
  751  08C8  F0 09        BEQ PrDec16Next      ; pad<>0, use it
  752  08CA            PrDec16Digit
  753  08CA  A2 30        LDX #'0
  754  08CC  86 5A        STX pad              ; No more zero padding
  755  08CE  09 30        ORA #'0              ; Print this digit
  756  08D0            PrDec16Print
  757  08D0  20 AF 12     JSR OUTPUT
  758  08D3            PrDec16Next
  759  08D3  88           DEY
  760  08D4  88           DEY
  761  08D5  10 C3        BPL PrDec16Lp1       ; Loop for next digit
  762  08D7  60           RTS
  763  08D8            PrDec16Tens
  764  08D8  01 00        .WORD 1
  765  08DA  0A 00        .WORD 10
  766  08DC  64 00        .WORD 100
  767  08DE  E8 03        .WORD 1000
  768  08E0  10 27        .WORD 10000
  769                  ;-----------------------------------------------------------
  770                  ; Either write test pattern then check or just check pattern.
  771                  ; Read test only works for data written by this program.
  772  08E2            TEST
  773  08E2  A9 00             LDA     #0
  774  08E4  85 7C             STA     SINGLETRK
  775  08E6            TEST2
  776  08E6  20 03 10          JSR     PRINT
  777  08E9  0D 0A             .BYTE   CR,LF
  778  08EB  57 52 49          .BYTE   'WRITE PROTECT ALL DISKS EXCEPT TEST DISK!',CR,LF
       08EE  54 45 20  
       08F1  50 52 4F  
       08F4  54 45 43  
       08F7  54 20 41  
       08FA  4C 4C 20  
       08FD  44 49 53  
       0900  4B 53 20  
       0903  45 58 43  
       0906  45 50 54  
       0909  20 54 45  
       090C  53 54 20  
       090F  44 49 53  
       0912  4B 21 0D  
       0915  0A        
  779  0916  0D 0A             .BYTE   CR,LF
  780  0918  49 4E 53          .BYTE   'INSERT DISK TO BE TESTED',CR,LF
       091B  45 52 54  
       091E  20 44 49  
       0921  53 4B 20  
       0924  54 4F 20  
       0927  42 45 20  
       092A  54 45 53  
       092D  54 45 44  
       0930  0D 0A     
  781  0932  49 66 20          .BYTE   'If errors found the output is DDDD (#### GG BBP)* EEEE',CR,LF
       0935  65 72 72  
       0938  6F 72 73  
       093B  20 66 6F  
       093E  75 6E 64  
       0941  20 74 68  
       0944  65 20 6F  
       0947  75 74 70  
       094A  75 74 20  
       094D  69 73 20  
       0950  44 44 44  
       0953  44 20 28  
       0956  23 23 23  
       0959  23 20 47  
       095C  47 20 42  
       095F  42 50 29  
       0962  2A 20 45  
       0965  45 45 45  
       0968  0D 0A     
  782  096A  77 68 65          .BYTE   'where DDDD is difference between number of bytes written',CR,LF
       096D  72 65 20  
       0970  44 44 44  
       0973  44 20 69  
       0976  73 20 64  
       0979  69 66 66  
       097C  65 72 65  
       097F  6E 63 65  
       0982  20 62 65  
       0985  74 77 65  
       0988  65 6E 20  
       098B  6E 75 6D  
       098E  62 65 72  
       0991  20 6F 66  
       0994  20 62 79  
       0997  74 65 73  
       099A  20 77 72  
       099D  69 74 74  
       09A0  65 6E 0D  
       09A3  0A        
  783  09A4  61 6E 64          .BYTE   'and read. EEEE is total errors, #### is byte count from', CR,LF
       09A7  20 72 65  
       09AA  61 64 2E  
       09AD  20 45 45  
       09B0  45 45 20  
       09B3  69 73 20  
       09B6  74 6F 74  
       09B9  61 6C 20  
       09BC  65 72 72  
       09BF  6F 72 73  
       09C2  2C 20 23  
       09C5  23 23 23  
       09C8  20 69 73  
       09CB  20 62 79  
       09CE  74 65 20  
       09D1  63 6F 75  
       09D4  6E 74 20  
       09D7  66 72 6F  
       09DA  6D 0D 0A  
  784  09DD  73 74 61          .BYTE   'start of track, GG is good byte, BB is bad byte,',CR,LF
       09E0  72 74 20  
       09E3  6F 66 20  
       09E6  74 72 61  
       09E9  63 6B 2C  
       09EC  20 47 47  
       09EF  20 69 73  
       09F2  20 67 6F  
       09F5  6F 64 20  
       09F8  62 79 74  
       09FB  65 2C 20  
       09FE  42 42 20  
       0A01  69 73 20  
       0A04  62 61 64  
       0A07  20 62 79  
       0A0A  74 65 2C  
       0A0D  0D 0A     
  785  0A0F  50 20 69          .BYTE   'P is byte had parity error.',CR,LF
       0A12  73 20 62  
       0A15  79 74 65  
       0A18  20 68 61  
       0A1B  64 20 70  
       0A1E  61 72 69  
       0A21  74 79 20  
       0A24  65 72 72  
       0A27  6F 72 2E  
       0A2A  0D 0A     
  786  0A2C  45 72 72          .BYTE   'Errors that fit on line are printed.',CR,LF
       0A2F  6F 72 73  
       0A32  20 74 68  
       0A35  61 74 20  
       0A38  66 69 74  
       0A3B  20 6F 6E  
       0A3E  20 6C 69  
       0A41  6E 65 20  
       0A44  61 72 65  
       0A47  20 70 72  
       0A4A  69 6E 74  
       0A4D  65 64 2E  
       0A50  0D 0A     
  787  0A52  45 53 43          .BYTE   'ESC KEY OR ^X ABORTS...',CR,LF,0
       0A55  20 4B 45  
       0A58  59 20 4F  
       0A5B  52 20 5E  
       0A5E  58 20 41  
       0A61  42 4F 52  
       0A64  54 53 2E  
       0A67  2E 2E 0D  
       0A6A  0A 00     
  788                  
  789  0A6C  20 5E 10          JSR     ANYKEY
  790  0A6F  C9 1B             CMP     #$1B   ;ESC key?
  791  0A71  F0 3B             BEQ     JMP2TOP
  792  0A73  C9 18             CMP     #$18   ;^X
  793  0A75  F0 37             BEQ     JMP2TOP
  794                  
  795                  
  796  0A77  A5 35             LDA     PASSES
  797  0A79  85 37             STA     PASSCNTR
  798  0A7B  20 20 0F          JSR     INITPIA
  799  0A7E  20 40 0F          JSR     SELDRV
  800  0A81  20 0F 0F          JSR     RESPTR
  801  0A84  A9 20             LDA     #$20
  802  0A86  2C 00 C0          BIT     DDPIA
  803  0A89  D0 26             BNE     WRITEOK
  804  0A8B  20 03 10          JSR     PRINT
  805  0A8E  0D 0A             .BYTE   CR,LF
  806  0A90  44 49 53          .BYTE   'DISK IS WRITE PROTECTED!',CR,LF,0
       0A93  4B 20 49  
       0A96  53 20 57  
       0A99  52 49 54  
       0A9C  45 20 50  
       0A9F  52 4F 54  
       0AA2  45 43 54  
       0AA5  45 44 21  
       0AA8  0D 0A 00  
  807  0AAB  20 5E 10          JSR     ANYKEY
  808  0AAE            JMP2TOP
  809  0AAE  4C A1 03          JMP     TOP
  810  0AB1            WRITEOK
  811  0AB1  A5 7C             LDA     SINGLETRK
  812  0AB3  D0 08             BNE     TESTFILL ; Head already at desired track
  813  0AB5  20 5D 0F          JSR     TZERO   ; STEP TO TRACK 0
  814  0AB8  90 03             BCC     TESTFILL
  815  0ABA  4C E9 0E          JMP     NOTRK
  816                  
  817  0ABD            TESTFILL
  818  0ABD  20 0F 0F          JSR     RESPTR
  819  0AC0  A0 00             LDY     #0
  820  0AC2            TFILL   
  821  0AC2  A5 34             LDA     PATVAL
  822  0AC4  24 33             BIT     PATSEL          ; Fill with test pattern. 
  823  0AC6  10 03             BPL     TSTORE          ; Always fills larger 8" number of bytes
  824  0AC8  20 97 13          JSR     RAND
  825  0ACB            TSTORE
  826  0ACB  91 70             STA     (TDATA),Y
  827  0ACD  C8                INY
  828  0ACE  D0 02             BNE     TCHKFILLED
  829  0AD0  E6 71             INC     TDATA+1
  830  0AD2            TCHKFILLED
  831  0AD2  C0 10             CPY     #BYTES8%256
  832  0AD4  D0 EC             BNE     TFILL
  833  0AD6  A5 71             LDA     TDATA+1
  834  0AD8  38                SEC
  835  0AD9  E9 15             SBC     #BUFFER/256
  836  0ADB  C9 0E             CMP     #BYTES8/256
  837  0ADD  D0 E3             BNE     TFILL
  838                  
  839  0ADF  A9 5A             LDA     #$5A            ; Start of track marker
  840  0AE1  8D 89 15          STA     BUFFER
  841                          
  842  0AE4  A9 58             LDA     #$58    ;0 10 110 00 ;$58-  recv irq, RTS HIGH no xmit irq,  8E1,  DIVIDE BY 1,
  843  0AE6  85 6D             STA     DRVACIA 
  844                  
  845  0AE8  AD 02 C0          LDA     DDPIA+2  ; PRESERVE DISK SEL BIT
  846  0AEB  29 7F             AND     #$7F    ; 0111 1111
  847  0AED  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
  848  0AF0  A2 FF             LDX     #$FF    ; 320MS
  849  0AF2  20 F4 0F          JSR     DELAY
  850                  
  851  0AF5  A5 36             LDA     READONLY        ; If read only skip write
  852  0AF7  F0 03             BEQ     WRNEXT
  853  0AF9  4C 95 0B          JMP     TREAD
  854  0AFC            WRNEXT
  855  0AFC  20 03 10          JSR     PRINT
  856  0AFF  57 54 52          .BYTE   'WTRK ',0
       0B02  4B 20 00  
  857  0B05  A5 2E             LDA     TRK
  858  0B07  20 7C 08          JSR     PrDec2Dig
  859  0B0A  A5 67             LDA     MTRKBYTES
  860  0B0C  85 69             STA     BYTECNTR
  861  0B0E  A5 68             LDA     MTRKBYTES+1
  862  0B10  85 6A             STA     BYTECNTR+1
  863  0B12  20 0F 0F          JSR     RESPTR
  864  0B15  A5 2E             LDA     TRK     ; Write track to second byte to check for seek errors
  865  0B17  8D 8A 15          STA     BUFFER+1
  866                  
  867  0B1A  2C 00 C0          BIT     DDPIA   ; WAIT 
  868  0B1D  30 FB             BMI     *-3     ; INDEX PULSE
  869  0B1F  2C 00 C0          BIT     DDPIA   ; WAIT END OF
  870  0B22  10 FB             BPL     *-3     ; INDEX PULSE
  871  0B24  AD 02 C0          LDA     DDPIA+2 ; PRESERVE DISK SEL BIT
  872  0B27  29 FC             AND     #$FC    ; TURN ON WRITE AND ERASE ENABLE
  873  0B29  8D 02 C0          STA     DDPIA+2
  874                  
  875  0B2C  A9 03             LDA     #3
  876  0B2E  8D 10 C0          STA     DDACIA  ; RESET ACIA
  877  0B31  A5 6D             LDA     DRVACIA ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
  878  0B33  8D 10 C0          STA     DDACIA  ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  879  0B36  A2 01             LDX     #1      ; 0.8MS
  880  0B38  A0 9E             LDY     #$9E
  881  0B3A  20 F6 0F          JSR     DELAY1
  882  0B3D  A0 00             LDY     #0
  883  0B3F            WRDATALP
  884  0B3F  2C 00 C0          BIT     DDPIA   ; WAIT 
  885  0B42  30 03             BMI     WNOINDEXERR     ; Didn't find INDEX PULSE
  886  0B44  4C 9B 0E          JMP     INDEXERR        
  887  0B47            WNOINDEXERR
  888  0B47  A9 02             LDA     #2
  889  0B49  2D 10 C0          AND     DDACIA          ;test tx ready? 
  890  0B4C  F0 F1             BEQ     WRDATALP        ;not ready?
  891  0B4E  B1 70             LDA     (TDATA),Y
  892  0B50  8D 11 C0          STA     DDACIA+1        ; Write data to floppy
  893  0B53  C8                INY
  894  0B54  D0 02             BNE     *+4
  895  0B56  E6 71             INC     TDATA+1
  896  0B58  E6 69             INC     BYTECNTR
  897  0B5A  D0 E3             BNE     WRDATALP
  898  0B5C  E6 6A             INC     BYTECNTR+1
  899  0B5E  D0 E7             BNE     WNOINDEXERR     ; Not done, write more. Don't check for index
  900                                                  ; to prevent being late writing next char.
  901                  
  902  0B60  2C 00 C0          BIT     DDPIA   ; WAIT FOR
  903  0B63  30 FB             BMI     *-3     ; INDEX PULSE
  904  0B65  2C 00 C0          BIT     DDPIA   ; WAIT FOR
  905  0B68  10 FB             BPL     *-3     ; END INDEX PULSE
  906  0B6A  A2 20             LDX     #32     ; Erase a little past index
  907  0B6C  CA                DEX
  908  0B6D  D0 FD             BNE     *-1
  909                          
  910  0B6F  A9 03             LDA     #$03
  911  0B71  0D 02 C0          ORA     DDPIA+2 ; turn off write and erase
  912  0B74  8D 02 C0          STA     DDPIA+2
  913                  
  914  0B77  A9 0D             LDA     #CR
  915  0B79  20 AF 12          JSR     OUTPUT
  916  0B7C  A5 7C             LDA     SINGLETRK
  917  0B7E  D0 15             BNE     TREAD   ; Single track, we are done writing
  918  0B80  A6 2E             LDX     TRK
  919  0B82  E8                INX
  920  0B83  E4 2A             CPX     MAXTRK
  921  0B85  F0 06             BEQ     TWDONE
  922  0B87  20 C1 0F          JSR     TNEXT   ; Go to next track
  923  0B8A  4C FC 0A          JMP     WRNEXT
  924  0B8D            TWDONE
  925  0B8D  A9 80             LDA     #$80
  926  0B8F  0D 02 C0          ORA     DDPIA+2 ; Unload head
  927  0B92  8D 02 C0          STA     DDPIA+2
  928                  
  929                  
  930                          ; Read portion of disk test. Enter at TREAD2 if testing
  931                          ; single track. For normal read we save off the data read and the
  932                          ; error flags from the serial chip. We don't have enough time
  933                          ; to handle errors between bytes.
  934                          ; For scope read we check the word in real time and generate
  935                          ; fault reset pulse to trigger a scope. Checking for the track stops
  936                          ; after the first error.
  937  0B95            TREAD
  938  0B95  A5 7C             LDA     SINGLETRK
  939  0B97  D0 15             BNE     TREAD2  ; Single track, skip seek to zero
  940  0B99  20 5D 0F          JSR     TZERO   ; STEP TO TRACK 0
  941  0B9C  90 03             BCC     *+5
  942  0B9E  4C E9 0E          JMP     NOTRK
  943  0BA1  AD 02 C0          LDA     DDPIA+2  ; PRESERVE DISK SEL BIT
  944  0BA4  29 7F             AND     #$7F    ; 0111 1111
  945  0BA6  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
  946  0BA9  A2 FF             LDX     #$FF    ; 320MS
  947  0BAB  20 F4 0F          JSR     DELAY
  948                  
  949  0BAE            TREAD2
  950  0BAE  20 0F 0F          JSR     RESPTR
  951  0BB1  A9 00             LDA     #0
  952  0BB3  85 5B             STA     ERRCNT
  953  0BB5  85 5C             STA     ERRCNT+1
  954  0BB7  85 5D             STA     PRTERR  
  955                  
  956  0BB9  20 03 10          JSR     PRINT
  957  0BBC  52 54 52          .BYTE   'RTRK ',0
       0BBF  4B 20 00  
  958  0BC2  A5 2E             LDA     TRK
  959  0BC4  20 7C 08          JSR     PrDec2Dig
  960  0BC7  A9 20             LDA     #' '
  961  0BC9  20 AF 12          JSR     OUTPUT
  962  0BCC  A5 2E             LDA     TRK             ; Update compare data with track testing
  963  0BCE  8D 8A 15          STA     BUFFER+1
  964                  
  965  0BD1  2C 00 C0          BIT     DDPIA   ; WAIT 
  966  0BD4  30 FB             BMI     *-3     ; INDEX PULSE
  967  0BD6  2C 00 C0          BIT     DDPIA   ; WAIT END OF
  968  0BD9  10 FB             BPL     *-3     ; INDEX PULSE
  969  0BDB  A9 03             LDA     #3
  970  0BDD  8D 10 C0          STA     DDACIA  ; RESET ACIA
  971  0BE0  A5 6D             LDA     DRVACIA ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
  972  0BE2  8D 10 C0          STA     DDACIA  ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  973  0BE5  A5 6C             LDA     TESTTYPE
  974  0BE7  D0 03             BNE     *+5
  975  0BE9  4C 15 0D          JMP     NORMREAD        ; User selected normal read test
  976                  
  977                          ; This is scope read check code
  978  0BEC  A0 00             LDY     #0
  979  0BEE  A9 01             LDA     #1
  980  0BF0            RDATALP2
  981  0BF0  2C 00 C0          BIT     DDPIA
  982  0BF3  10 35             BPL     NODATA          ; INDEX PULSE
  983  0BF5  2C 10 C0          BIT     DDACIA          ; test tx ready?        
  984  0BF8  F0 F6             BEQ     RDATALP2
  985  0BFA  08                PHP
  986  0BFB  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
  987  0BFE  C9 5A             CMP     #$5A            ; Got start byte
  988  0C00  D0 07             BNE     IGNBYTE         ; No, try one more time. We get one junk
  989                                                  ; byte where write turned on/off
  990  0C02  28                PLP
  991  0C03  70 33             BVS     SERROR          ; Did it get a parity error
  992  0C05  C8                INY                     ; Skip this byte in checking since we checked
  993  0C06  4C 0A 0C          JMP     RDATALP3
  994  0C09            IGNBYTE
  995  0C09  28                PLP
  996  0C0A            RDATALP3
  997  0C0A  2C 00 C0          BIT     DDPIA
  998  0C0D  30 03             BMI     NOTINDEX2       ; INDEX PULSE
  999  0C0F  4C 20 0E          JMP     PCRONLY
 1000  0C12            NOTINDEX2
 1001  0C12  A9 01             LDA     #1
 1002  0C14  2C 10 C0          BIT     DDACIA          ; test tx ready?        
 1003  0C17  F0 F1             BEQ     RDATALP3
 1004  0C19  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
 1005  0C1C  70 1A             BVS     SERROR          ; Branch if parity error
 1006  0C1E  D1 70             CMP     (TDATA),Y       ; Check data
 1007  0C20  D0 16             BNE     SERROR
 1008  0C22  C8                INY
 1009  0C23  D0 ED             BNE     NOTINDEX2
 1010  0C25  E6 71             INC     TDATA+1
 1011  0C27  4C 12 0C          JMP     NOTINDEX2
 1012  0C2A            NODATA
 1013  0C2A  20 03 10          JSR     PRINT
 1014  0C2D  4E 6F 20          .BYTE   'No data',0
       0C30  64 61 74  
       0C33  61 00     
 1015  0C35            JPCRLF
 1016  0C35  4C 17 0E          JMP     PCRLF
 1017  0C38            SERROR  ; Print error info and generate scope trigger
 1018  0C38  48                PHA
 1019  0C39  A9 EF             LDA     #$EF
 1020  0C3B  2D 02 C0          AND     DDPIA+2 ; Clear fault reset
 1021  0C3E  8D 02 C0          STA     DDPIA+2
 1022  0C41  20 FF 0F          JSR     DELAY2
 1023  0C44  A9 10             LDA     #$10
 1024  0C46  0D 02 C0          ORA     DDPIA+2 ; Set fault reset
 1025  0C49  8D 02 C0          STA     DDPIA+2
 1026                  
 1027  0C4C  38                SEC
 1028  0C4D  A5 71             LDA     TDATA+1         ; Calculate offset of byte with error
 1029  0C4F  E9 15             SBC     #>BUFFER
 1030  0C51  85 45             STA     num+1
 1031  0C53  84 6B             STY     YHOLD
 1032  0C55  84 44             STY     num
 1033  0C57  98                TYA
 1034  0C58  18                CLC
 1035  0C59  65 67             ADC     MTRKBYTES
 1036  0C5B  A5 45             LDA     num+1
 1037  0C5D  65 68             ADC     MTRKBYTES+1
 1038  0C5F  30 16             BMI     SPERR   ; Error was in bytes being tested
 1039  0C61  20 03 10          JSR     PRINT
 1040  0C64  45 78 74          .BYTE   'Extra data read',0
       0C67  72 61 20  
       0C6A  64 61 74  
       0C6D  61 20 72  
       0C70  65 61 64  
       0C73  00        
 1041  0C74  4C 9E 0C          JMP     SERRWAIT
 1042                          
 1043  0C77            SPERR
 1044  0C77  A9 30             LDA     #'0'
 1045  0C79  85 5A             STA     pad
 1046  0C7B  A0 06             LDY     #6      ; 4 digits max
 1047  0C7D  20 9A 08          JSR     PrDec16Lp1
 1048  0C80  20 03 10          JSR     PRINT
 1049  0C83  20 47 4F          .BYTE   ' GOOD ',0
       0C86  4F 44 20  
       0C89  00        
 1050  0C8A  A4 6B             LDY     YHOLD
 1051  0C8C  B1 70             LDA     (TDATA),Y
 1052  0C8E  20 2D 10          JSR     PHEXA
 1053  0C91  20 03 10          JSR     PRINT
 1054  0C94  20 42 41          .BYTE   ' BAD ',0
       0C97  44 20 00  
 1055  0C9A  68                PLA
 1056  0C9B  20 2D 10          JSR     PHEXA
 1057  0C9E            SERRWAIT
 1058  0C9E  AD 02 C0          LDA     DDPIA+2
 1059  0CA1  09 80             ORA     #$80    
 1060  0CA3  8D 02 C0          STA     DDPIA+2 ; UNLOAD DISK HEAD
 1061  0CA6  20 66 12          JSR     Get_Chr
 1062  0CA9  20 03 10          JSR     PRINT
 1063  0CAC  0D 0A 48          .BYTE   CR,LF,'Hit space to reread E to exit or other key to continue > ',0
       0CAF  69 74 20  
       0CB2  73 70 61  
       0CB5  63 65 20  
       0CB8  74 6F 20  
       0CBB  72 65 72  
       0CBE  65 61 64  
       0CC1  20 45 20  
       0CC4  74 6F 20  
       0CC7  65 78 69  
       0CCA  74 20 6F  
       0CCD  72 20 6F  
       0CD0  74 68 65  
       0CD3  72 20 6B  
       0CD6  65 79 20  
       0CD9  74 6F 20  
       0CDC  63 6F 6E  
       0CDF  74 69 6E  
       0CE2  75 65 20  
       0CE5  3E 20 00  
 1064  0CE8  20 7E 12          JSR     INKEY
 1065  0CEB  48                PHA
 1066  0CEC  20 03 10          JSR     PRINT
 1067  0CEF  0D 0A 00          .BYTE   CR,LF,0
 1068  0CF2  68                PLA
 1069  0CF3  09 20             ORA     #$20    ; Lower case
 1070  0CF5  C9 65             CMP     #'e'
 1071  0CF7  D0 03             BNE     *+5
 1072  0CF9  4C A1 03          JMP     TOP
 1073  0CFC  48                PHA
 1074  0CFD  AD 02 C0          LDA     DDPIA+2 ; PRESERVE DISK SEL BIT
 1075  0D00  29 7F             AND     #$7F    ; 0111 1111
 1076  0D02  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
 1077  0D05  A2 FF             LDX     #$FF    ; 320MS
 1078  0D07  20 F4 0F          JSR     DELAY
 1079  0D0A  68                PLA
 1080  0D0B  C9 20             CMP     #' '
 1081  0D0D  F0 03             BEQ     *+5
 1082  0D0F  4C 25 0E          JMP     NEXTTRK
 1083  0D12  4C AE 0B          JMP     TREAD2
 1084                          
 1085                          
 1086                  
 1087                          ; This is normal read check code
 1088  0D15            NORMREAD
 1089  0D15  A0 00             LDY     #0
 1090  0D17            RDATALP
 1091  0D17  2C 00 C0          BIT     DDPIA
 1092  0D1A  10 16             BPL     RINDEX          ; INDEX PULSE
 1093  0D1C            NOTINDEX
 1094  0D1C  AD 10 C0          LDA     DDACIA          ; test tx ready?        
 1095  0D1F  91 72             STA     (TDATA2),Y      ; store error data
 1096  0D21  4A                LSR
 1097  0D22  90 F3             BCC     RDATALP         ; not ready?
 1098  0D24  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
 1099  0D27  C8                INY
 1100  0D28  91 72             STA     (TDATA2),Y      ; store disk data
 1101  0D2A  C8                INY
 1102  0D2B  D0 EF             BNE     NOTINDEX
 1103  0D2D  E6 73             INC     TDATA2+1
 1104  0D2F  4C 1C 0D          JMP     NOTINDEX
 1105                  
 1106  0D32            RINDEX
 1107  0D32  18                CLC     ; Found index, determine how many bytes read
 1108  0D33  98                TYA
 1109  0D34  65 72             ADC     TDATA2
 1110  0D36  85 72             STA     TDATA2
 1111  0D38  90 02             BCC     *+4
 1112  0D3A  E6 73             INC     TDATA2+1
 1113  0D3C  38                SEC
 1114  0D3D  A5 72             LDA     TDATA2
 1115  0D3F  E9 99             SBC     #<BUFFER2
 1116  0D41  85 69             STA     BYTECNTR
 1117  0D43  A5 73             LDA     TDATA2+1
 1118  0D45  E9 23             SBC     #>BUFFER2
 1119  0D47  18                CLC
 1120  0D48  6A                ROR
 1121  0D49  85 6A             STA     BYTECNTR+1
 1122  0D4B  A5 69             LDA     BYTECNTR        ; divide by 2 to get bytes data stored
 1123  0D4D  6A                ROR
 1124  0D4E  85 69             STA     BYTECNTR
 1125  0D50  A5 69             LDA     BYTECNTR
 1126  0D52  D0 04             BNE     CHKSTART
 1127  0D54  A5 6A             LDA     BYTECNTR+1
 1128  0D56  F0 26             BEQ     NOSKIP          ; If no data don't try to find start of track
 1129  0D58            CHKSTART
 1130                          ; This will skip up to 1 byte looking for $5A start of track flag
 1131                          ; The write turn on/off generates one byte of junk sometimes
 1132  0D58  20 0F 0F          JSR     RESPTR
 1133  0D5B  AD 9A 23          LDA     BUFFER2+1
 1134  0D5E  C9 5A             CMP     #$5A            ; Start of track flag
 1135  0D60  F0 1C             BEQ     NOSKIP
 1136  0D62  AD 9C 23          LDA     BUFFER2+3
 1137  0D65  C9 5A             CMP     #$5A            ; Start of track flag
 1138  0D67  D0 15             BNE     NOSKIP          ; No, assume read error
 1139  0D69  18                CLC
 1140  0D6A  A9 02             LDA     #2
 1141  0D6C  65 72             ADC     TDATA2
 1142  0D6E  85 72             STA     TDATA2
 1143  0D70  A9 00             LDA     #0
 1144  0D72  65 73             ADC     TDATA2+1        ; Ignore one junk character
 1145  0D74  85 73             STA     TDATA2+1        ; and parity byte
 1146  0D76  A5 69             LDA     BYTECNTR
 1147  0D78  D0 02             BNE     *+4
 1148  0D7A  C6 6A             DEC     BYTECNTR+1
 1149  0D7C  C6 69             DEC     BYTECNTR
 1150  0D7E            NOSKIP
 1151  0D7E  18                CLC     ; Print bytes read - bytes written. Skipped byte not
 1152                                  ; included in bytes read 
 1153  0D7F  A5 69             LDA     BYTECNTR
 1154  0D81  65 67             ADC     MTRKBYTES
 1155  0D83  AA                TAX
 1156  0D84  A5 6A             LDA     BYTECNTR+1
 1157  0D86  65 68             ADC     MTRKBYTES+1
 1158  0D88  30 0D             BMI     PNEG
 1159  0D8A  48                PHA
 1160  0D8B  A9 20             LDA     #' '
 1161  0D8D  20 AF 12          JSR     OUTPUT
 1162  0D90  68                PLA
 1163  0D91  20 8B 08          JSR     PrDec4Dig
 1164  0D94  4C CC 0D          JMP     RCHKDATA
 1165  0D97            PNEG
 1166  0D97  85 6B             STA     YHOLD
 1167  0D99  86 2F             STX     TMP
 1168  0D9B  A9 2D             LDA     #'-'
 1169  0D9D  20 AF 12          JSR     OUTPUT
 1170  0DA0  A9 00             LDA     #0
 1171  0DA2  38                SEC
 1172  0DA3  E5 2F             SBC     TMP
 1173  0DA5  85 44             STA     num
 1174  0DA7  A9 00             LDA     #0
 1175  0DA9  E5 6B             SBC     YHOLD
 1176  0DAB  85 45             STA     num+1
 1177  0DAD  A9 2D             LDA     #'-'
 1178  0DAF  85 5A             STA     pad
 1179  0DB1  A0 06             LDY     #6
 1180  0DB3  20 9A 08          JSR     PrDec16Lp1
 1181                  
 1182  0DB6  38                SEC
 1183  0DB7  A9 00             LDA     #0
 1184                          ; Bytes read shorter than expected so only check bytes read.
 1185  0DB9  E5 69             SBC     BYTECNTR        
 1186  0DBB  85 69             STA     BYTECNTR        ; Convert to negative count
 1187  0DBD  A9 00             LDA     #0
 1188  0DBF  E5 6A             SBC     BYTECNTR+1
 1189  0DC1  85 6A             STA     BYTECNTR+1
 1190  0DC3  D0 0F             BNE     RCHKDATALP
 1191  0DC5  A5 69             LDA     BYTECNTR
 1192  0DC7  D0 0B             BNE     RCHKDATALP
 1193  0DC9  4C 17 0E          JMP     PCRLF   ; No bytes read, don't compare. Just print CRLF
 1194  0DCC            RCHKDATA
 1195  0DCC  A5 67             LDA     MTRKBYTES
 1196  0DCE  85 69             STA     BYTECNTR
 1197  0DD0  A5 68             LDA     MTRKBYTES+1
 1198  0DD2  85 6A             STA     BYTECNTR+1
 1199  0DD4            RCHKDATALP
 1200  0DD4  A0 00             LDY     #0
 1201  0DD6  A9 40             LDA     #$40
 1202  0DD8  31 72             AND     (TDATA2),Y
 1203  0DDA  D0 6F             BNE     RERROR  ; Data had parity error
 1204  0DDC  A5 73             LDA     TDATA2+1
 1205  0DDE  C8                INY
 1206  0DDF  B1 72             LDA     (TDATA2),Y
 1207  0DE1  88                DEY
 1208  0DE2  D1 70             CMP     (TDATA),Y
 1209  0DE4  D0 65             BNE     RERROR  ; Miscompare
 1210  0DE6            RCONT
 1211  0DE6  18                CLC
 1212  0DE7  A9 02             LDA     #2
 1213  0DE9  65 72             ADC     TDATA2  ; Inc data pointers
 1214  0DEB  85 72             STA     TDATA2
 1215  0DED  90 02             BCC     *+4
 1216  0DEF  E6 73             INC     TDATA2+1
 1217  0DF1  E6 70             INC     TDATA
 1218  0DF3  D0 02             BNE     *+4
 1219  0DF5  E6 71             INC     TDATA+1
 1220  0DF7  E6 69             INC     BYTECNTR
 1221  0DF9  D0 02             BNE     *+4
 1222  0DFB  E6 6A             INC     BYTECNTR+1
 1223  0DFD  D0 D5             BNE     RCHKDATALP
 1224                  
 1225  0DFF            PRTERRCNT
 1226  0DFF  A5 5B             LDA     ERRCNT  ; Done compare, did we get any errors?
 1227  0E01  D0 04             BNE     PERRCNT
 1228  0E03  A5 5C             LDA     ERRCNT+1
 1229  0E05  F0 0C             BEQ     PNOERR  ; no
 1230  0E07            PERRCNT
 1231  0E07  A9 20             LDA     #' '
 1232  0E09  20 AF 12          JSR     OUTPUT
 1233  0E0C  A6 5B             LDX     ERRCNT
 1234  0E0E  A5 5C             LDA     ERRCNT+1
 1235  0E10  20 8B 08          JSR     PrDec4Dig
 1236  0E13            PNOERR
 1237  0E13  A5 5D             LDA     PRTERR
 1238  0E15  F0 09             BEQ     PCRONLY
 1239  0E17            PCRLF
 1240  0E17  20 03 10          JSR     PRINT
 1241  0E1A  0D 0A 00          .BYTE   CR,LF,0
 1242  0E1D  4C 25 0E          JMP     NEXTTRK
 1243  0E20            PCRONLY
 1244  0E20  A9 0D             LDA     #CR
 1245  0E22  20 AF 12          JSR     OUTPUT
 1246  0E25            NEXTTRK
 1247  0E25  A5 7C             LDA     SINGLETRK       ; Done if single track or at max
 1248  0E27  D0 0D             BNE     TRDONE
 1249  0E29  A6 2E             LDX     TRK
 1250  0E2B  E8                INX
 1251  0E2C  E4 2A             CPX     MAXTRK
 1252  0E2E  F0 06             BEQ     TRDONE
 1253  0E30  20 C1 0F          JSR     TNEXT   ; seek to next track
 1254  0E33            JTREAD2
 1255  0E33  4C AE 0B          JMP     TREAD2
 1256  0E36            TRDONE
 1257  0E36  A9 80             LDA     #$80
 1258  0E38  0D 02 C0          ORA     DDPIA+2 ; Unload head
 1259  0E3B  8D 02 C0          STA     DDPIA+2
 1260  0E3E  C6 37             DEC     PASSCNTR
 1261  0E40  F0 03             BEQ     JMPTOP
 1262  0E42  4C B1 0A          JMP     WRITEOK
 1263  0E45            JMPTOP
 1264  0E45  20 5E 10          JSR     ANYKEY
 1265  0E48  4C A1 03          JMP     TOP
 1266                  
 1267                          ; Print offset of error and good and bad data
 1268  0E4B            RERROR
 1269  0E4B  E6 5B             INC     ERRCNT
 1270  0E4D  D0 02             BNE     *+4
 1271  0E4F  E6 5C             INC     ERRCNT+1
 1272  0E51  A5 5B             LDA     ERRCNT
 1273  0E53  C5 7B             CMP     MAXERR          ; Only print first MAXERR errors
 1274  0E55  B0 41             BCS     NOPRT
 1275  0E57  A5 5C             LDA     ERRCNT+1
 1276  0E59  D0 3D             BNE     NOPRT
 1277  0E5B  A9 20             LDA     #' '
 1278  0E5D  85 5D             STA     PRTERR
 1279  0E5F  20 AF 12          JSR     OUTPUT
 1280  0E62  38                SEC
 1281  0E63  A5 70             LDA     TDATA
 1282  0E65  E9 89             SBC     #<BUFFER
 1283  0E67  AA                TAX
 1284  0E68  A5 71             LDA     TDATA+1
 1285  0E6A  E9 15             SBC     #>BUFFER        
 1286  0E6C  20 8B 08          JSR     PrDec4Dig
 1287  0E6F  A9 20             LDA     #' '
 1288  0E71  20 AF 12          JSR     OUTPUT
 1289  0E74  A0 00             LDY     #0
 1290  0E76  B1 70             LDA     (TDATA),Y       ; Good value
 1291  0E78  20 2D 10          JSR     PHEXA
 1292  0E7B  A9 20             LDA     #' '
 1293  0E7D  20 AF 12          JSR     OUTPUT
 1294  0E80  C8                INY
 1295  0E81  B1 72             LDA     (TDATA2),Y      ; Bad value
 1296  0E83  88                DEY
 1297  0E84  20 2D 10          JSR     PHEXA
 1298  0E87  A2 20             LDX     #' '
 1299  0E89  A9 40             LDA     #$40
 1300  0E8B  31 72             AND     (TDATA2),Y
 1301  0E8D  F0 02             BEQ     *+4
 1302  0E8F  A2 50             LDX     #'P'            ; Parity error
 1303  0E91  8A                TXA
 1304  0E92  20 AF 12          JSR     OUTPUT
 1305  0E95  4C E6 0D          JMP     RCONT
 1306  0E98            NOPRT
 1307  0E98  4C E6 0D          JMP     RCONT
 1308                          
 1309  0E9B            INDEXERR
 1310                          ; Found index before we wrote all our data
 1311  0E9B  A9 83             LDA     #$83
 1312  0E9D  0D 02 C0          ORA     DDPIA+2 ; Unload head, turn off write and erase
 1313  0EA0  8D 02 C0          STA     DDPIA+2
 1314  0EA3  20 03 10          JSR     PRINT
 1315  0EA6  0D 0A             .BYTE   CR,LF
 1316  0EA8  49 4E 44          .BYTE   'INDEX ACTIVE DURING WRITE, BYTES LEFT: ',0
       0EAB  45 58 20  
       0EAE  41 43 54  
       0EB1  49 56 45  
       0EB4  20 44 55  
       0EB7  52 49 4E  
       0EBA  47 20 57  
       0EBD  52 49 54  
       0EC0  45 2C 20  
       0EC3  42 59 54  
       0EC6  45 53 20  
       0EC9  4C 45 46  
       0ECC  54 3A 20  
       0ECF  00        
 1317  0ED0  38                SEC
 1318  0ED1  A9 00             LDA     #0
 1319  0ED3  E5 69             SBC     BYTECNTR
 1320  0ED5  AA                TAX
 1321  0ED6  A9 00             LDA     #0
 1322  0ED8  E5 6A             SBC     BYTECNTR+1      
 1323  0EDA  20 47 10          JSR     PDEC
 1324  0EDD  20 03 10          JSR     PRINT
 1325  0EE0  0D 0A 00          .BYTE   CR,LF,0
 1326  0EE3  20 5E 10          JSR     ANYKEY
 1327  0EE6  4C A1 03          JMP     TOP
 1328                          
 1329  0EE9            NOTRK
 1330  0EE9  20 20 0F          JSR     INITPIA
 1331  0EEC  20 03 10          JSR     PRINT
 1332  0EEF  0D 0A 0D          .BYTE CR,LF,CR,LF, 'ERROR Seeking Track 0',0
       0EF2  0A 45 52  
       0EF5  52 4F 52  
       0EF8  20 53 65  
       0EFB  65 6B 69  
       0EFE  6E 67 20  
       0F01  54 72 61  
       0F04  63 6B 20  
       0F07  30 00     
 1333  0F09  20 5E 10          JSR     ANYKEY
 1334  0F0C  4C A1 03          JMP     TOP     
 1335                  
 1336                  ; RESET BUFFER POINTERS
 1337  0F0F            RESPTR  
 1338  0F0F  A9 89             LDA     #<BUFFER
 1339  0F11  85 70             STA     TDATA
 1340  0F13  A9 15             LDA     #>BUFFER
 1341  0F15  85 71             STA     TDATA+1
 1342  0F17  A9 99             LDA     #<BUFFER2
 1343  0F19  85 72             STA     TDATA2
 1344  0F1B  A9 23             LDA     #>BUFFER2
 1345  0F1D  85 73             STA     TDATA2+1
 1346                  
 1347  0F1F  60                RTS
 1348                  
 1349                  ; INIT DISK CONTROLLER PIA
 1350  0F20            INITPIA 
 1351  0F20  A0 00             LDY     #0
 1352  0F22  A9 40             LDA     #$40
 1353  0F24  8C 01 C0          STY     DDPIA+1 ; SELECT DDRA
 1354  0F27  8D 00 C0          STA     DDPIA   ; SET PORTA TO ALL INPUTS except PA6
 1355  0F2A  A2 04             LDX     #4              ; 0000 0100
 1356  0F2C  8E 01 C0          STX     DDPIA+1 ; SELECT PORTA
 1357  0F2F  8D 00 C0          STA     DDPIA    ; SET PB6 HIGH
 1358  0F32  8C 03 C0          STY     DDPIA+3 ; SELECT DDRB
 1359  0F35  88                DEY
 1360  0F36  8C 02 C0          STY     DDPIA+2 ; SET PORTB TO ALL OUTPUTS
 1361  0F39  8E 03 C0          STX     DDPIA+3 ; SELECT PORTB
 1362  0F3C  8C 02 C0          STY     DDPIA+2 ; SET PORTB OUTPUTS HIGH
 1363  0F3F  60                RTS
 1364                  
 1365                  
 1366                  ;SELECT DRIVE PB5 PA6  DRIVE (1-4)
 1367                  ;              0   0    #4
 1368                  ;              0   1    #3
 1369                  ;              1   0    #2
 1370                  ;              1   1    #1
 1371                  
 1372  0F40            SELDRV
 1373  0F40  A5 2D             LDA     DRVNUM
 1374  0F42  4A                LSR     A
 1375  0F43  A8                TAY
 1376  0F44  90 03             BCC     *+5
 1377  0F46  A9 00             LDA     #$00
 1378  0F48  2C A9 40          BIT     $40A9   ; This is LDA #$40 if BCC branches
 1379  0F4B  8D 00 C0          STA     DDPIA   ; This is A/B select in port A
 1380  0F4E  AD 02 C0          LDA     DDPIA+2
 1381  0F51  09 20             ORA     #$20
 1382  0F53  C0 01             CPY     #$01
 1383  0F55  90 02             BCC     *+4
 1384  0F57  29 DF             AND     #$DF
 1385  0F59  8D 02 C0          STA     DDPIA+2 ; This is master select in port B
 1386  0F5C  60                RTS
 1387                  
 1388                  
 1389                  ; STEP TO TRACK 0. Carry clear if no error. A modified. TRK set to 0
 1390                  ; if no error.
 1391                  
 1392  0F5D            TZERO
 1393  0F5D  A5 2A             LDA     MAXTRK  ;max num tracks
 1394  0F5F  69 08             ADC     #$08    ;plus a few more
 1395  0F61  85 2F             STA     TMP             ;MAX times to step before abort
 1396  0F63  AD 02 C0          LDA     DDPIA+2
 1397  0F66  29 FB             AND     #$FB    ; 1111 1011
 1398  0F68  D0 1B             BNE     TZERO3  ; DIR=INWARDS, start with one step away from track 0
 1399                  
 1400  0F6A            TZERO1
 1401  0F6A  C6 2F             DEC     TMP
 1402  0F6C  D0 02             BNE     TZERO5
 1403  0F6E  38                SEC
 1404  0F6F  60                RTS
 1405  0F70            TZERO5  
 1406  0F70  A9 02             LDA     #2              ; 0000 0010
 1407  0F72  2C 00 C0          BIT     DDPIA   ; TEST 'TRK0' PIN
 1408  0F75  D0 09             BNE     TZERO2  ; AT TRACK 0
 1409  0F77  A9 00             LDA     #0
 1410  0F79  85 2E             STA     TRK
 1411  0F7B  20 E3 0F          JSR     REDWR
 1412  0F7E  18                CLC
 1413  0F7F  60                RTS
 1414                  
 1415  0F80            TZERO2  
 1416  0F80  AD 02 C0          LDA     DDPIA+2 ; DIR=OUTWARDS (TO TRK0)
 1417  0F83  09 04             ORA     #$04
 1418  0F85            TZERO3  
 1419  0F85  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1420  0F88  20 FF 0F          JSR     DELAY2
 1421  0F8B  29 F7             AND     #$F7    ; 1111 0111
 1422  0F8D  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN LOW
 1423  0F90  20 FF 0F          JSR     DELAY2
 1424  0F93  09 08             ORA     #8              ; 0000 1000
 1425  0F95  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN HIGH
 1426  0F98  A2 20             LDX     #32     ; 40 MS
 1427  0F9A  20 F4 0F          JSR     DELAY
 1428  0F9D  F0 CB             BEQ     TZERO1  ; ALWAYS
 1429                  
 1430                  ; STEP TO PREVIOUS TRACK
 1431  0F9F            TPREV
 1432  0F9F  AD 02 C0          LDA     DDPIA+2 ; DIR=(TO TRK0)
 1433  0FA2  09 04             ORA     #$04
 1434  0FA4  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1435  0FA7  20 FF 0F          JSR     DELAY2
 1436  0FAA  29 F7             AND     #$F7    ; 1111 0111
 1437  0FAC  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN LOW
 1438  0FAF  20 FF 0F          JSR     DELAY2
 1439  0FB2  09 08             ORA     #8              ; 0000 1000
 1440  0FB4  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN HIGH
 1441  0FB7  C6 2E             DEC     TRK
 1442  0FB9  20 E3 0F          JSR     REDWR   ; Set reduced write current
 1443  0FBC  A2 20             LDX     #32     ; 40 MS
 1444  0FBE  4C F4 0F          JMP     DELAY
 1445                  
 1446                  ; STEP TO NEXT TRACK
 1447                  
 1448  0FC1            TNEXT   
 1449  0FC1  AD 02 C0          LDA     DDPIA+2
 1450  0FC4  29 FB             AND     #$FB    ; 1111 1011
 1451                                                  ; DIR=INWARDS
 1452  0FC6  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1453  0FC9  20 FF 0F          JSR     DELAY2
 1454  0FCC  29 F7             AND     #$F7    ; 1111 0111
 1455  0FCE  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' LOW
 1456  0FD1  20 FF 0F          JSR     DELAY2
 1457  0FD4  09 08             ORA     #8              ; 0000 1000
 1458  0FD6  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' HIGH
 1459  0FD9  E6 2E             INC     TRK
 1460  0FDB  20 E3 0F          JSR     REDWR   ; Set reduced write current
 1461  0FDE  A2 20             LDX     #32         ; 40MS
 1462  0FE0  4C F4 0F          JMP     DELAY
 1463                  
 1464                          ; Set reduced write current
 1465  0FE3            REDWR
 1466  0FE3  A5 2E             LDA     TRK
 1467  0FE5  C9 2B             CMP     #43     ; Is track >= 43
 1468  0FE7  AD 02 C0          LDA     DDPIA+2
 1469  0FEA  29 BF             AND     #$BF    ; Set low current active
 1470  0FEC  B0 02             BCS     SETLO   ; Yes
 1471  0FEE  09 40             ORA     #$40    ; Set low current inactive
 1472  0FF0            SETLO
 1473  0FF0  8D 02 C0          STA     DDPIA+2
 1474  0FF3  60                RTS
 1475                  
 1476                  ; DELAY 1.25MS PER LOOP at 1 MHz clock. X,Y modified
 1477                  
 1478  0FF4            DELAY   
 1479  0FF4  A0 F8             LDY     #$F8
 1480  0FF6            DELAY1  
 1481  0FF6  88                DEY
 1482  0FF7  D0 FD             BNE     DELAY1
 1483  0FF9  55 FF             EOR     $FF,X
 1484  0FFB  CA                DEX
 1485  0FFC  D0 F6             BNE     DELAY
 1486  0FFE  60                RTS
 1487                  
 1488  0FFF            DELAY2  
 1489  0FFF  20 02 10          JSR     DELAY21
 1490  1002            DELAY21 
 1491  1002  60                RTS
 1492                  
 1493                  
 1494                  ; PRINT IN-LINE STRING. Y and A modified
 1495                  
 1496  1003            PRINT   
 1497  1003  68                PLA
 1498  1004  85 6E             STA     PTRSTOR
 1499  1006  68                PLA
 1500  1007  85 6F             STA     PTRSTOR+1
 1501  1009  A0 01             LDY     #1
 1502  100B            PRINT1  
 1503  100B  B1 6E             LDA     (PTRSTOR),Y
 1504  100D  F0 0A             BEQ     PRINT2
 1505  100F  20 AF 12          JSR     OUTPUT
 1506  1012  C8                INY
 1507  1013  D0 F6             BNE     PRINT1
 1508  1015  E6 6F             INC     PTRSTOR+1
 1509  1017  D0 F2             BNE     PRINT1
 1510  1019            PRINT2  
 1511  1019  98                TYA
 1512  101A  38                SEC
 1513  101B  65 6E             ADC     PTRSTOR
 1514  101D  A4 6E             LDY     PTRSTOR
 1515  101F  85 6E             STA     PTRSTOR
 1516  1021  90 02             BCC     PRINT3
 1517  1023  E6 6F             INC     PTRSTOR+1
 1518  1025            PRINT3
 1519  1025  18                CLC
 1520  1026  6C 6E 00          JMP     (PTRSTOR)
 1521                  
 1522                  ; PRINT HEX WORD (A,X). ONLY CHANGES A
 1523                  
 1524  1029            PHEX    
 1525  1029  20 2D 10          JSR     PHEXA
 1526  102C  8A                TXA
 1527                  
 1528                  ; PRINT HEX BYTE (A)
 1529  102D            PHEXA   
 1530  102D  48                PHA
 1531  102E  4A                LSR     A
 1532  102F  4A                LSR     A
 1533  1030  4A                LSR     A
 1534  1031  4A                LSR     A
 1535  1032  20 36 10          JSR     PHEXA1
 1536  1035  68                PLA
 1537  1036            PHEXA1  
 1538  1036  29 0F             AND     #$F
 1539  1038  09 30             ORA     #'0'
 1540  103A  C9 3A             CMP     #'9'+1
 1541  103C  30 03             BMI     PHEXA2
 1542  103E  18                CLC
 1543  103F  69 07             ADC     #7
 1544  1041            PHEXA2  
 1545  1041  4C AF 12          JMP     OUTPUT
 1546                  
 1547                  ; PRINT DECIMAL (A)
 1548  1044            PDECA   
 1549  1044  AA                TAX
 1550  1045  A9 00             LDA     #0
 1551                  
 1552                  ; PRINT DECIMAL (A,X). CHANGES A,X,Y. Prints with no leading space
 1553                  
 1554  1047            PDEC    
 1555  1047  86 44             STX num
 1556  1049  85 45             STA num+1
 1557  104B  A9 00             LDA #0
 1558  104D  85 5A             STA pad
 1559  104F  A0 06             LDY #6  ; 4 digits max
 1560  1051  4C 9A 08          JMP PrDec16Lp1
 1561                  
 1562  1054            CRLF    
 1563  1054  A9 0D             LDA     #CR
 1564  1056  20 AF 12          JSR     OUTPUT
 1565  1059  A9 0A             LDA     #LF
 1566  105B  4C AF 12          JMP     OUTPUT
 1567                  
 1568  105E            ANYKEY  
 1569  105E  20 66 12          JSR     Get_Chr
 1570  1061  20 03 10          JSR     PRINT
 1571  1064  0D 0A             .BYTE   CR,LF
 1572  1066  50 52 45          .BYTE   'PRESS ANY KEY WHEN READY >',0
       1069  53 53 20  
       106C  41 4E 59  
       106F  20 4B 45  
       1072  59 20 57  
       1075  48 45 4E  
       1078  20 52 45  
       107B  41 44 59  
       107E  20 3E 00  
 1573  1081  20 7E 12          JSR     INKEY
 1574  1084  48                PHA
 1575  1085  20 03 10          JSR     PRINT
 1576  1088  0D 0A 00          .BYTE   CR,LF,0
 1577  108B  68                PLA
 1578  108C  60                RTS
 1579                  
 1580  108D            DRWMENU
 1581  108D  20 03 10           JSR PRINT
 1582  1090  0D 0A 0D          .BYTE $D,$A,$D,$A
       1093  0A        
 1583  1094  20 4F 53          .BYTE ' OSI DESTRUCTIVE Disk Test',$D,$A          
       1097  49 20 44  
       109A  45 53 54  
       109D  52 55 43  
       10A0  54 49 56  
       10A3  45 20 44  
       10A6  69 73 6B  
       10A9  20 54 65  
       10AC  73 74 0D  
       10AF  0A        
 1584  10B0  2D 2D 2D          .BYTE '--------------------------',$D,$A          
       10B3  2D 2D 2D  
       10B6  2D 2D 2D  
       10B9  2D 2D 2D  
       10BC  2D 2D 2D  
       10BF  2D 2D 2D  
       10C2  2D 2D 2D  
       10C5  2D 2D 2D  
       10C8  2D 2D 0D  
       10CB  0A        
 1585  10CC  31 2E 20          .BYTE '1. Test Disk',$D,$A
       10CF  54 65 73  
       10D2  74 20 44  
       10D5  69 73 6B  
       10D8  0D 0A     
 1586  10DA  32 2E 20          .BYTE '2. Test Track',$D,$A
       10DD  54 65 73  
       10E0  74 20 54  
       10E3  72 61 63  
       10E6  6B 0D 0A  
 1587  10E9  33 2E 20          .BYTE '3. Select Drive',$D,$A      
       10EC  53 65 6C  
       10EF  65 63 74  
       10F2  20 44 72  
       10F5  69 76 65  
       10F8  0D 0A     
 1588  10FA  34 2E 20          .BYTE '4. Set Drive Type',$D,$A      
       10FD  53 65 74  
       1100  20 44 72  
       1103  69 76 65  
       1106  20 54 79  
       1109  70 65 0D  
       110C  0A        
 1589  110D  35 2E 20          .BYTE '5. Set Pattern and passes',$D,$A
       1110  53 65 74  
       1113  20 50 61  
       1116  74 74 65  
       1119  72 6E 20  
       111C  61 6E 64  
       111F  20 70 61  
       1122  73 73 65  
       1125  73 0D 0A  
 1590  1128  36 2E 20          .BYTE '6. Toggle read only',$D,$A
       112B  54 6F 67  
       112E  67 6C 65  
       1131  20 72 65  
       1134  61 64 20  
       1137  6F 6E 6C  
       113A  79 0D 0A  
 1591  113D  37 2E 20          .BYTE '7. RPM Test',$D,$A 
       1140  52 50 4D  
       1143  20 54 65  
       1146  73 74 0D  
       1149  0A        
 1592  114A  38 2E 20          .BYTE '8. Status screen',$D,$A 
       114D  53 74 61  
       1150  74 75 73  
       1153  20 73 63  
       1156  72 65 65  
       1159  6E 0D 0A  
 1593  115C  39 2E 20          .BYTE '9. Exit',$D,$A          
       115F  45 78 69  
       1162  74 0D 0A  
 1594  1165  0D 0A             .BYTE $D,$A
 1595  1167  44 72 76          .BYTE 'Drv=',$0
       116A  3D 00     
 1596  116C  A5 2D             LDA DRVNUM
 1597  116E  18                CLC
 1598  116F  69 41             ADC #$41
 1599  1171  20 AF 12          JSR OUTPUT
 1600  1174  A5 2B             LDA MAXPAG
 1601  1176  C9 0F             CMP #MAXPAG8
 1602  1178  F0 1B             BEQ DRWMN1
 1603  117A  C9 0A             CMP #MAXPAG5
 1604  117C  F0 0B             BEQ DRWMN0
 1605  117E  20 03 10          JSR PRINT
 1606  1181  2F 33 2E          .BYTE '/3.5 ',0
       1184  35 20 00  
 1607  1187  90 13             BCC DRWMN2
 1608                  
 1609  1189  20 03 10  DRWMN0  JSR PRINT
 1610  118C  2F 35 2E          .BYTE '/5.25 ',0
       118F  32 35 20  
       1192  00        
 1611  1193  90 07             BCC DRWMN2
 1612  1195            DRWMN1
 1613  1195  20 03 10          JSR PRINT
 1614  1198  2F 38 20          .BYTE '/8 ',0
       119B  00        
 1615  119C            DRWMN2
 1616  119C  A5 33             LDA PATSEL
 1617  119E  D0 15             BNE DRWMN3
 1618  11A0  20 03 10          JSR PRINT
 1619  11A3  50 61 74          .BYTE 'Pattern $',0
       11A6  74 65 72  
       11A9  6E 20 24  
       11AC  00        
 1620  11AD  A5 34             LDA PATVAL
 1621  11AF  20 2D 10          JSR PHEXA
 1622  11B2  4C C7 11          JMP DRWMN4
 1623  11B5            DRWMN3
 1624  11B5  20 03 10          JSR PRINT
 1625  11B8  50 61 74          .BYTE 'Pattern random',0
       11BB  74 65 72  
       11BE  6E 20 72  
       11C1  61 6E 64  
       11C4  6F 6D 00  
 1626  11C7            DRWMN4
 1627  11C7  20 03 10          JSR PRINT
 1628  11CA  20 20 50          .BYTE '  Passes ',0
       11CD  61 73 73  
       11D0  65 73 20  
       11D3  00        
 1629  11D4  A5 35             LDA PASSES
 1630  11D6  20 44 10          JSR PDECA
 1631  11D9  A5 6C             LDA TESTTYPE
 1632  11DB  F0 12             BEQ NORMTEST
 1633  11DD  20 03 10          JSR PRINT
 1634  11E0  20 53 63          .BYTE ' Scope test',0
       11E3  6F 70 65  
       11E6  20 74 65  
       11E9  73 74 00  
 1635  11EC  4C FF 11          JMP RWRO
 1636  11EF            NORMTEST
 1637  11EF  20 03 10          JSR PRINT
 1638  11F2  20 4E 6F          .BYTE ' Normal test',0
       11F5  72 6D 61  
       11F8  6C 20 74  
       11FB  65 73 74  
       11FE  00        
 1639  11FF            RWRO
 1640  11FF  A5 36             LDA READONLY
 1641  1201  F0 11             BEQ RW
 1642  1203  20 03 10          JSR PRINT
 1643  1206  20 52 65          .BYTE ' Read only',0
       1209  61 64 20  
       120C  6F 6E 6C  
       120F  79 00     
 1644  1211  4C 1C 12          JMP PPROMPT
 1645  1214            RW
 1646  1214  20 03 10          JSR PRINT
 1647  1217  20 52 2F          .BYTE ' R/W',0
       121A  57 00     
 1648  121C            PPROMPT
 1649  121C  20 03 10          JSR PRINT
 1650  121F  20 3E 20          .BYTE ' > ',0
       1222  00        
 1651  1223  60                RTS
 1652                  
 1653                          ; Get key from polled key without waiting. Carry clear if no key
 1654                          ; Key returned in A. X,Y modified
 1655  1224            Get_Chr_Polled
 1656  1224  20 35 12          JSR Check_Keypress      ;any pressed keys?
 1657  1227  90 3B             BCC NOKEY               ;no, dont get stuxk in keypoller
 1658  1229  20 ED FE          JSR $FEED               ;yes - check keypoller
 1659  122C  48                PHA
 1660  122D            UNKEY
 1661  122D  20 35 12          JSR Check_Keypress  ;wait till key unpressed to prevent reading key twice 
 1662  1230  B0 FB             BCS UNKEY
 1663  1232  68                PLA
 1664  1233            HAVEKEY
 1665  1233  38                SEC
 1666  1234  60                RTS
 1667                  
 1668  1235            Check_Keypress
 1669  1235  24 30             BIT MACHINE
 1670  1237  70 2B             BVS NOKEY       ;don't poll C3 machine
 1671  1239  A9 FE             LDA #$FE        ;want all except first row with shift lock
 1672  123B  45 31             EOR INVKEYB
 1673  123D  8D 00 DF          STA $DF00       ; Select row
 1674  1240  8D 00 DF          STA $DF00       ; In case some time needed for signals to propagate
 1675  1243  AD 00 DF          LDA $DF00
 1676  1246  45 31             EOR INVKEYB ;C1 keyboard inverted
 1677  1248  48                PHA
 1678  1249  A9 00             LDA #$00        ;Deselect all rows
 1679  124B  45 31             EOR INVKEYB
 1680  124D  8D 00 DF          STA $DF00
 1681  1250  68                PLA
 1682  1251  F0 11             BEQ NOKEY       ; bail if no key pressed
 1683  1253  A0 07             LDY #$07        ; count bits 7 to 1
 1684  1255  A2 00             LDX #$00
 1685  1257            DEKEY
 1686  1257  0A                ASL A
 1687  1258  90 01             BCC *+3
 1688  125A  E8                INX
 1689  125B  88                DEY
 1690  125C  D0 F9             BNE DEKEY
 1691  125E  E0 01             CPX #$01        ;x has # cols pressed
 1692  1260  D0 02             BNE NOKEY       ;more than one or none = nokey
 1693  1262  38                SEC 
 1694  1263  60                RTS
 1695  1264            NOKEY
 1696  1264  18                CLC
 1697  1265  60                RTS     
 1698                  
 1699  1266            Get_Chr
 1700  1266            FRACIANW  ; read from ACIA no wait      carry clear when no data
 1701  1266  24 30             BIT MACHINE
 1702  1268  30 0A             BMI FRAC1NW
 1703  126A  AD 00 FC          LDA C2ACIA
 1704  126D  4A                LSR A
 1705  126E  90 03             BCC FRAC1NW-1
 1706  1270  AD 01 FC          LDA C2ACIA+1
 1707  1273  60                RTS
 1708  1274            FRAC1NW
 1709  1274  AD 00 F0          LDA C1ACIA
 1710  1277  4A                LSR A    
 1711  1278  90 F9             BCC FRAC1NW-1 
 1712  127A  AD 01 F0          LDA C1ACIA+1
 1713  127D  60                RTS
 1714                  
 1715                          ; Get key from serial or polled keyboard waiting for key.
 1716  127E            INKEY
 1717  127E  24 32             BIT VIDEO
 1718  1280  10 03             BPL *+5         ; No
 1719  1282  4C ED FE          JMP $FEED       ; Polled keyboard
 1720  1285            FRACIA           ;read from ACIA carry set on abort return value in A
 1721  1285  24 30             BIT MACHINE
 1722  1287  30 0B             BMI FRAC1
 1723  1289            FRSER                   ; read from C3
 1724  1289  AD 00 FC          LDA C2ACIA
 1725  128C  4A                LSR A    
 1726  128D  90 FA             BCC FRSER 
 1727  128F  AD 01 FC          LDA C2ACIA+1
 1728  1292  18                CLC      
 1729  1293            ACIARET
 1730  1293  60                RTS
 1731  1294            FRAC1                   ;read from C1
 1732  1294  AD 00 F0          LDA C1ACIA
 1733  1297  4A                LSR A    
 1734  1298  90 FA             BCC FRAC1 
 1735  129A  AD 01 F0          LDA C1ACIA+1
 1736  129D  18                CLC       
 1737  129E  60                RTS
 1738                  
 1739                          ; Check if TX ready bit is set for serial. Carry set if ready
 1740  129F            CheckTXReady
 1741  129F  24 30             BIT MACHINE
 1742  12A1  30 06             BMI TOAC1B
 1743  12A3  AD 00 FC          LDA C2ACIA   ;wait for TxEmpty
 1744  12A6  4A                LSR A     
 1745  12A7  4A                LSR A     
 1746  12A8  60                RTS     ; Carry set if TX ready
 1747  12A9            TOAC1B
 1748  12A9  AD 00 F0          LDA C1ACIA 
 1749  12AC  4A                LSR A     
 1750  12AD  4A                LSR A     
 1751  12AE  60                RTS     ; Carry set if TX ready
 1752                  
 1753                          ; Write a character to serial or video. A modified
 1754  12AF            OUTPUT
 1755  12AF  24 32             BIT VIDEO
 1756  12B1  10 03             BPL TOACIA      ; No, not video system
 1757  12B3  4C 2A 13          JMP VIDOUT
 1758  12B6            TOACIA
 1759  12B6  48                PHA
 1760  12B7  24 30             BIT MACHINE
 1761  12B9  30 0C             BMI TOAC1
 1762  12BB            TOACIA1        
 1763  12BB  AD 00 FC          LDA C2ACIA   ;wait for TxEmpty
 1764  12BE  4A                LSR A     
 1765  12BF  4A                LSR A     
 1766  12C0  90 F9             BCC TOACIA1   
 1767  12C2  68                PLA       
 1768  12C3  8D 01 FC          STA C2ACIA+1 
 1769  12C6  60                RTS       
 1770  12C7            TOAC1
 1771  12C7  AD 00 F0          LDA C1ACIA 
 1772  12CA  4A                LSR A     
 1773  12CB  4A                LSR A     
 1774  12CC  90 F9             BCC TOAC1   
 1775  12CE  68                PLA       
 1776  12CF  8D 01 F0          STA C1ACIA+1 
 1777  12D2  60                RTS 
 1778                  
 1779                          ; Video output routine
 1780                          ; video init for SYN600, SYNMON, CEGMON
 1781                          ; $FFE0 - cursor start
 1782                          ; $FFE1 - line len-1   (wrap position)
 1783                          ; $FFE2 - 00 = 1K vid, 01=2K vid otherwise serial or other ROM
 1784                          ; FFE0 65, 17, 00 (c1 ROM, cegmon)
 1785                          ; FFE0 40, 3F, 01 (c2 ROM)
 1786                          ; FFE0 4D, 2F, 01 (C1E cegmon 64x32)
 1787  12D3            VIDINIT
 1788  12D3  A9 00             LDA #$00
 1789  12D5  85 78             STA VIDOFFSET
 1790  12D7  85 76             STA VIDDST
 1791  12D9  AE E2 FF          LDX $FFE2
 1792  12DC  F0 1A             BEQ C1VID ;1k screen
 1793  12DE  CA                DEX
 1794  12DF  F0 11             BEQ C2VID
 1795                          
 1796                  
 1797  12E1            WHATVID ;assume C2-like video
 1798  12E1  A9 00             LDA #$00
 1799  12E3  8D 4A 13          STA VIDCR+1 ;cursor start
 1800  12E6  85 78             STA VIDOFFSET
 1801  12E8  A9 40             LDA #$40        ;linelen
 1802  12EA  85 7A             STA VIDXMAX
 1803  12EC  A2 D7             LDX #$D7    ;bottom line hi
 1804  12EE  A0 80             LDY #$80    ;bottom line low
 1805  12F0  D0 21             BNE VIDINI2
 1806                          
 1807  12F2            C2VID                   ;C2VID  2k screen
 1808  12F2  A9 40             LDA #$40        ;linelen
 1809  12F4  A2 D7             LDX #$D7    ;bottom line hi
 1810  12F6  D0 04             BNE VIDINI1
 1811                          
 1812                          
 1813  12F8            C1VID   ;C1VID  1K screen
 1814  12F8  A9 20             LDA #$20
 1815  12FA  A2 D3             LDX #$D3
 1816                  
 1817  12FC            VIDINI1 ;read video settings from ROM
 1818  12FC  48                PHA     
 1819  12FD  AD E0 FF          LDA $FFE0
 1820  1300  A8                TAY
 1821  1301  29 0F             AND #$0F
 1822  1303  8D 4A 13          STA VIDCR+1 ;cursor start
 1823  1306  38                SEC
 1824  1307  6D E1 FF          ADC $FFE1
 1825  130A  85 7A             STA VIDXMAX
 1826  130C  98                TYA
 1827  130D  29 F0             AND #$F0
 1828  130F  A8                TAY         ;bottom line low
 1829  1310  85 78             STA VIDOFFSET
 1830  1312  68                PLA
 1831                  
 1832  1313            VIDINI2 
 1833                  
 1834  1313  85 79             STA VIDXLEN
 1835  1315  85 74             STA VIDSRC
 1836                  
 1837  1317  8E 8D 13          STX VIDCLR+2  ;D3E0 or D780
 1838  131A  8C 8C 13          STY VIDCLR+1  
 1839  131D  8E 38 13          STX VIDFIX1+1 ;D3E0 or D780
 1840  1320  8C 37 13          STY VIDFIX1
 1841  1323  A9 D0             LDA #$D0
 1842  1325  85 75             STA VIDSRC+1  ;init to D040 or D020
 1843  1327  85 77             STA VIDDST+1  ;init to D000
 1844  1329  60                RTS
 1845                          
 1846  132A            VIDOUT
 1847  132A  84 6B             STY YHOLD 
 1848  132C  C9 0D             CMP #CR
 1849  132E  F0 19             BEQ VIDCR
 1850  1330  C9 0A             CMP #LF
 1851  1332  F0 1A             BEQ VIDLF
 1852  1334  A4 78             LDY VIDOFFSET
 1853  1337            VIDFIX1=*+1
 1854  1336  99 C0 D6          STA $D6C0,Y
 1855  1339  C8                INY
 1856  133A  84 78             STY VIDOFFSET
 1857  133C  C4 7A             CPY VIDXMAX
 1858  133E  D0 06             BNE VIDRETY
 1859  1340  20 49 13          JSR VIDCR
 1860  1343  4C 4E 13          JMP VIDLF
 1861  1346            VIDRETY
 1862  1346  A4 6B             LDY YHOLD
 1863  1348  60                RTS
 1864  1349            VIDCR
 1865  1349  A9 00             LDA #0
 1866  134B  85 78             STA VIDOFFSET
 1867  134D  60                RTS
 1868                  
 1869  134E            VIDLF
 1870  134E  A0 00             LDY #$00
 1871  1350            VIDLF1
 1872  1350  B1 74             LDA (VIDSRC),Y  ;copy row by row
 1873  1352  91 76             STA (VIDDST),Y
 1874  1354  C8                INY
 1875  1355  C4 79             CPY VIDXLEN
 1876  1357  D0 F7             BNE VIDLF1
 1877  1359  98                TYA
 1878  135A  18                CLC
 1879  135B  65 74             ADC VIDSRC
 1880  135D  85 74             STA VIDSRC
 1881  135F  90 02             BCC VIDLF2
 1882  1361  E6 75             INC VIDSRC+1
 1883  1363            VIDLF2
 1884  1363  98                TYA
 1885  1364  18                CLC
 1886  1365  65 76             ADC VIDDST
 1887  1367  85 76             STA VIDDST
 1888  1369  90 02             BCC VIDLF3
 1889  136B  E6 77             INC VIDDST+1
 1890  136D            VIDLF3  
 1891                  
 1892  136D  A5 77             LDA VIDDST+1
 1893  136F  CD 8D 13          CMP VIDCLR+2
 1894  1372  D0 DA             BNE VIDLF1-2
 1895  1374  A5 76             LDA VIDDST
 1896  1376  CD 8C 13          CMP VIDCLR+1
 1897  1379  D0 D3             BNE VIDLF1-2
 1898                  
 1899  137B  A9 D0             LDA #$D0
 1900  137D  85 75             STA VIDSRC+1
 1901  137F  85 77             STA VIDDST+1
 1902  1381  A9 00             LDA #$00
 1903  1383  85 76             STA VIDDST
 1904  1385  A5 79             LDA VIDXLEN
 1905  1387  85 74             STA VIDSRC
 1906                  
 1907  1389  A9 20             LDA #' '
 1908  138B            VIDCLR
 1909  138B  99 C0 D6          STA $D6C0,Y     ; Clear last line
 1910  138E  C8                INY
 1911  138F  C4 79             CPY VIDXLEN
 1912  1391  D0 F8             BNE VIDCLR
 1913  1393  C8                INY
 1914  1394  4C 46 13          JMP VIDRETY
 1915                          
 1916                          
 1917                  
 1918                  ; Return an 8 bit "random" number in A
 1919                  ; X modified on return
 1920                  ; From http://forum.6502.org/viewtopic.php?f=2&t=5247 modified for better
 1921                  ; randomness
 1922  1397            RAND
 1923  1397  A5 3C             LDA RND+4       ; ADD B shifted, 
 1924  1399  38                SEC             ; carry adds value 0x80
 1925  139A  6A                ROR
 1926  139B  65 39             ADC RND+1       ; add last value (E)
 1927  139D  65 3D             ADC RND+5       ; add C
 1928  139F  85 38             STA RND         ; new number
 1929  13A1  A2 04             LDX #4          ; move 5 numbers
 1930  13A3            RPL
 1931  13A3  B5 38             LDA RND,X
 1932  13A5  95 39             STA RND+1,X     ; ..move over 1
 1933  13A7  CA                DEX
 1934  13A8  10 F9             BPL RPL         ; all moved?
 1935  13AA  A5 38             LDA RND
 1936  13AC  60                RTS
 1937                  
 1938                  ; From https://codebase64.org/doku.php?id=base:24bit_division_24-bit_result
 1939                  ; EXECUTES AN UNSIGNED INTEGER DIVISION OF A 24-BIT DIVIDEND BY A 24-BIT DIVISOR
 1940                  ; THE RESULT GOES TO DIVIDEND AND REMAINDER VARIABLES
 1941                  ;
 1942                  ; VERZ!!! 18-MAR-2017
 1943                  ; A, X, Y modified.
 1944                  
 1945  13AD  A9 00     DIV24   LDA #0          ;PRESET REMAINDER TO 0
 1946  13AF  85 4A             STA REMAINDER
 1947  13B1  85 4B             STA REMAINDER+1
 1948  13B3  85 4C             STA REMAINDER+2
 1949  13B5  A2 18             LDX #24         ;REPEAT FOR EACH BIT: ...
 1950                  
 1951  13B7  06 44     DIVLOOP ASL DIVIDEND    ;DIVIDEND LB & HB*2, MSB -> CARRY
 1952  13B9  26 45             ROL DIVIDEND+1  
 1953  13BB  26 46             ROL DIVIDEND+2
 1954  13BD  26 4A             ROL REMAINDER   ;REMAINDER LB & HB * 2 + MSB FROM CARRY
 1955  13BF  26 4B             ROL REMAINDER+1
 1956  13C1  26 4C             ROL REMAINDER+2
 1957  13C3  A5 4A             LDA REMAINDER
 1958  13C5  38                SEC
 1959  13C6  E5 47             SBC DIVISOR     ;SUBSTRACT DIVISOR TO SEE IF IT FITS IN
 1960  13C8  A8                TAY             ;LB RESULT -> Y, FOR WE MAY NEED IT LATER
 1961  13C9  A5 4B             LDA REMAINDER+1
 1962  13CB  E5 48             SBC DIVISOR+1
 1963  13CD  85 50             STA PZTEMP
 1964  13CF  A5 4C             LDA REMAINDER+2
 1965  13D1  E5 49             SBC DIVISOR+2
 1966  13D3  90 0A             BCC SKIP        ;IF CARRY=0 THEN DIVISOR DIDN'T FIT IN YET
 1967                  
 1968  13D5  85 4C             STA REMAINDER+2 ;ELSE SAVE SUBSTRACTION RESULT AS NEW REMAINDER,
 1969  13D7  A5 50             LDA PZTEMP
 1970  13D9  85 4B             STA REMAINDER+1
 1971  13DB  84 4A             STY REMAINDER   
 1972  13DD  E6 44             INC DIVIDEND    ;AND INCREMENT RESULT CAUSE DIVISOR FIT IN 1 TIMES
 1973                  
 1974  13DF  CA        SKIP    DEX
 1975  13E0  D0 D5             BNE DIVLOOP     
 1976  13E2  60                RTS
 1977                  
 1978                  
 1979                  ; From https://codebase64.org/doku.php?id=base:24bit_multiplication_24bit_product
 1980                  ; Multiply REMAINDER by DIVIDEND with result in DIVIDEND
 1981  004A            factor1 = REMAINDER
 1982  0044            product = DIVIDEND
 1983  13E3            MULT24
 1984  13E3  A9 00             lda #$00                        ; set product to zero
 1985  13E5  85 44             sta product
 1986  13E7  85 45             sta product+1
 1987  13E9  85 46             sta product+2
 1988                  
 1989  13EB            mloop
 1990  13EB  A5 4D             lda factor2                     ; while factor2 != 0
 1991  13ED  D0 09             bne nz
 1992  13EF  A5 4E             lda factor2+1
 1993  13F1  D0 05             bne nz
 1994  13F3  A5 4F             lda factor2+2
 1995  13F5  D0 01             bne nz
 1996  13F7  60                rts
 1997  13F8            nz
 1998  13F8  A5 4D             lda factor2                     ; if factor2 is odd
 1999  13FA  29 01             and #$01
 2000  13FC  F0 13             beq mskip
 2001                          
 2002  13FE  A5 4A             lda factor1                     ; product += factor1
 2003  1400  18                clc
 2004  1401  65 44             adc product
 2005  1403  85 44             sta product
 2006                          
 2007  1405  A5 4B             lda factor1+1
 2008  1407  65 45             adc product+1
 2009  1409  85 45             sta product+1
 2010                          
 2011  140B  A5 4C             lda factor1+2
 2012  140D  65 46             adc product+2
 2013  140F  85 46             sta product+2                   ; end if
 2014                  
 2015  1411            mskip
 2016  1411  06 4A             asl factor1                     ; << factor1 
 2017  1413  26 4B             rol factor1+1
 2018  1415  26 4C             rol factor1+2
 2019  1417  46 4F             lsr factor2+2                   ; >> factor2
 2020  1419  66 4E             ror factor2+1
 2021  141B  66 4D             ror factor2
 2022                  
 2023  141D  4C EB 13          jmp mloop                       ; end while     
 2024                  
 2025                  ; Status screen for displaying drive inputs
 2026                  ;  Commands:
 2027                  ;  Z- Zero Head   U - Step Up  D - Step Down   E Exit
 2028                  ;  R - Read Trk(not implemented) H - load/unload head 
 2029                  ;  S - Select disk, W - Write
 2030                  ;
 2031  002F            LASTPIA = TMP ; need a storage location
 2032  1420            STATSCRN
 2033  1420  A9 AA             LDA #$AA
 2034  1422  85 2F             STA LASTPIA
 2035  1424  20 20 0F          JSR INITPIA     ; Select disk
 2036  1427  20 40 0F          JSR SELDRV
 2037  142A  A9 20             LDA #$20        ; Turn master select back off
 2038  142C  4D 02 C0          EOR DDPIA+2
 2039  142F  8D 02 C0          STA DDPIA+2
 2040                          ; JSR PRINT
 2041                          ;.BYTE $1B,$48,$D,$A,0 ;escape codes to Home cursor no big deal if terminal doesn't respond correctl
 2042                  
 2043  1432  20 03 10          JSR PRINT
 2044  1435  0D 0A 0D          .BYTE $D,$A,$D,$A,'CMDS:(S)el (H)ead (W)rite Step:(U)p (D)own (Z)ero (E)xit',$D, $A
       1438  0A 43 4D  
       143B  44 53 3A  
       143E  28 53 29  
       1441  65 6C 20  
       1444  28 48 29  
       1447  65 61 64  
       144A  20 28 57  
       144D  29 72 69  
       1450  74 65 20  
       1453  53 74 65  
       1456  70 3A 28  
       1459  55 29 70  
       145C  20 28 44  
       145F  29 6F 77  
       1462  6E 20 28  
       1465  5A 29 65  
       1468  72 6F 20  
       146B  28 45 29  
       146E  78 69 74  
       1471  0D 0A     
 2045  1473  20 0D 0A          .BYTE ' ',$D, $A
 2046  1476  52 20 54          .BYTE 'R T F S R W S I',$D, $A
       1479  20 46 20  
       147C  53 20 52  
       147F  20 57 20  
       1482  53 20 49  
       1485  0D 0A     
 2047  1487  44 20 52          .BYTE 'D R A E D R e N',$D, $A
       148A  20 41 20  
       148D  45 20 44  
       1490  20 52 20  
       1493  65 20 4E  
       1496  0D 0A     
 2048  1498  59 20 4B          .BYTE 'Y K U C Y I l D',$D, $A
       149B  20 55 20  
       149E  43 20 59  
       14A1  20 49 20  
       14A4  6C 20 44  
       14A7  0D 0A     
 2049  14A9  31 20 30          .BYTE '1 0 L T 2 T 1 E',$D, $A
       14AC  20 4C 20  
       14AF  54 20 32  
       14B2  20 54 20  
       14B5  31 20 45  
       14B8  0D 0A     
 2050  14BA  20 20 20          .BYTE '    T     P   X',$D, $A
       14BD  20 54 20  
       14C0  20 20 20  
       14C3  20 50 20  
       14C6  20 20 58  
       14C9  0D 0A     
 2051  14CB  00                .BYTE 0
 2052                  
 2053  14CC            STATSCR2
 2054  14CC  AD 00 C0          LDA DDPIA
 2055  14CF            STATSCR5
 2056  14CF  85 2F             STA LASTPIA
 2057  14D1  A2 08             LDX #$08
 2058  14D3            STATSCR1
 2059  14D3  4A                LSR A
 2060  14D4  48                PHA
 2061  14D5  90 01             BCC *+3
 2062  14D7  A9 30             LDA #$30
 2063  14D9  2C A9 31          BIT $31A9
 2064  14DC  20 AF 12          JSR OUTPUT
 2065  14DF  A9 20             LDA #$20
 2066  14E1  20 AF 12          JSR OUTPUT
 2067  14E4  68                PLA
 2068  14E5  CA                DEX
 2069  14E6  D0 EB             BNE STATSCR1
 2070  14E8  20 03 10          JSR PRINT
 2071  14EB  20 54 52          .BYTE ' TRK ',0
       14EE  4B 20 00  
 2072  14F1  A5 2E             LDA TRK
 2073  14F3  20 7C 08          JSR PrDec2Dig
 2074  14F6  A9 0D             LDA #$0D
 2075  14F8  20 AF 12          JSR OUTPUT  ;keep redrawing current line- no LF
 2076  14FB            STATSCR4
 2077  14FB  24 32             BIT VIDEO
 2078  14FD  10 06             BPL STATSER     ; No
 2079  14FF  20 24 12          JSR Get_Chr_Polled
 2080  1502  4C 08 15          JMP *+6
 2081  1505            STATSER
 2082  1505  20 66 12          JSR Get_Chr
 2083  1508  B0 0A             BCS STATSCR3
 2084  150A  AD 00 C0          LDA DDPIA
 2085  150D  C5 2F             CMP LASTPIA
 2086  150F  F0 EA             BEQ STATSCR4  ;no change, no update
 2087  1511  4C CF 14          JMP STATSCR5
 2088  1514            STATSCR3
 2089  1514  29 5F             AND #$5F
 2090  1516  AA                TAX
 2091                          ;CMP #'R     ; READ TRACK/Show Part
 2092                          ;BNE *+8
 2093                          ;JSR VIEWTRK
 2094                          ;JMP STATSCR2
 2095  1517  E0 53             CPX #'S
 2096  1519  D0 0B             BNE CHECKLOAD
 2097  151B  A9 20             LDA #$20
 2098  151D  4D 02 C0          EOR DDPIA+2
 2099  1520  8D 02 C0          STA DDPIA+2
 2100  1523  4C CC 14          JMP STATSCR2
 2101  1526            CHECKLOAD
 2102  1526  E0 48             CPX #'H
 2103  1528  D0 0B             BNE CHKWRITE
 2104  152A  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2105  152D  49 80             EOR #$80        ; TOGGLE HEAD LOAD
 2106  152F  8D 02 C0          STA DDPIA+2     
 2107  1532  4C CC 14          JMP STATSCR2
 2108  1535            CHKWRITE
 2109  1535  E0 57             CPX #'W
 2110  1537  D0 1C             BNE CHKEXIT
 2111  1539  A9 20             LDA #$20
 2112  153B  2C 02 C0          BIT DDPIA+2 ;TEST DRIVE SEL
 2113  153E  F0 0A             BEQ WRITNOIDX
 2114  1540  2C 00 C0          BIT DDPIA       ; WAIT 
 2115  1543  30 FB             BMI *-3 ; INDEX PULSE
 2116  1545  2C 00 C0          BIT DDPIA       ; WAIT END OF
 2117  1548  10 FB             BPL *-3 ; INDEX PULSE
 2118  154A            WRITNOIDX
 2119  154A  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2120  154D  49 03             EOR #$03        ; TOGGLE WRITE AND ERASE ENABLE
 2121  154F  8D 02 C0          STA DDPIA+2     
 2122  1552  4C CC 14          JMP STATSCR2
 2123  1555            CHKEXIT
 2124  1555  E0 45             CPX #'E
 2125  1557  D0 0B             BNE CHKUP
 2126  1559  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2127  155C  09 A3             ORA #$A3        ; TURN OFF HEAD LOAD, SELECT, AND WRITE
 2128  155E  8D 02 C0          STA DDPIA+2     
 2129  1561  4C A1 03          JMP TOP
 2130                  
 2131  1564            CHKUP
 2132  1564  A9 20             LDA #$20
 2133  1566  2C 02 C0          BIT DDPIA+2
 2134  1569  F0 11             BEQ JSTATSCR2   ; Can't move head if drive not selected
 2135                  
 2136  156B  E0 55             CPX #'U
 2137  156D  D0 06             BNE *+8
 2138  156F  20 C1 0F          JSR TNEXT       ; STEP TO NEXT TRACK
 2139  1572  4C CC 14          JMP STATSCR2
 2140  1575  E0 44             CPX #'D
 2141  1577  D0 06             BNE *+8
 2142  1579  20 9F 0F          JSR TPREV   ; STEP TO PREV TRACK
 2143  157C            JSTATSCR2
 2144  157C  4C CC 14          JMP STATSCR2
 2145  157F  E0 5A             CPX #'Z
 2146  1581  D0 03             BNE *+5
 2147  1583  20 5D 0F          JSR TZERO    ; STEP TO TRACK 0
 2148  1586  4C CC 14          JMP STATSCR2
 2149                           
 2150                  
 2151                  ;VIEWTRK ;placeholder for View Track function   
 2152                  ;       RTS     
 2153  1589            BUFFER  =       *
 2154  1589            *=*+BYTES8 ;space for track buffer
 2155  2399            BUFFER2 =       *
 2156                  ;space for track buffer. We may write more data than this but will not
 2157                  ;use the extra data written. Don't put anything that can't be overwritten
 2158                  ;after this
 2159  2399            *=*+[BYTES8+BYTES8+2] 
 2160                  
 2161                  ;*=*+[MAXPAG8*2*256] ;space for track buffer
 2162                  
 2163  3FBB            .END

Errors   = 0
Warnings = 0
