    1                  ;
    2                  ; DISK TEST UTILITY FOR C1P/UK101/C2PDF/C4PMF/C8P/C3-OEM
    3                  ; Supposed to work with serial or video and 8" or 5.25" floppies. Tested 
    4                  ; with C2 with 8" floppies, serial, and 540B video. Tested with OSI emulator
    5                  ; with 5.25" floppies.
    6                  ; Needs 16k memory.
    7                  ; Start at $300
    8                  ; Does write/read or read only test. Disk format is not compatible with
    9                  ; OSI operating systems. Can either print error information or generate
   10                  ; a pulse on fault reset to trigger scope on error. Can also show
   11                  ; drive status lines and allow manual control of drive control lines.
   12                  ; Will also measure drive RPM
   13                  ;
   14                  ; DESTRUCTIVE DISK READ/WRITE TEST
   15                  ; By David Gesswein djg@pdp8online.com
   16                  ; Initial release V1.00 05/04/2020
   17                  ; V1.01 05/16/2020. Fixed ANYKEY not aborting. Prevent specifying illegal
   18                  ;    track to test. Fixed printing false errors when no data read.
   19                  ;    Fixed issues with serial console getting selected on video system.
   20                  
   21                  ; All my changes are released as public domain. The original code did not have
   22                  ; any license specified.
   23                  ; For usage see http://www.pdp8online.com/osi/osi-floppy-test.shtml
   24                  
   25                  ;BASED ON https://osi.marks-lab.com/software/tools.html Universal OSIDump 
   26                  ;BASED ON ED'S OSIDUMP UTILITY
   27                  ;
   28                  ;
   29                  
   30  0300            ORG     =       $0300
   31                  
   32  0028            MAXTRK5 =       40      ; # TRACKS TO READ 5 1/4 disk
   33  000A            MAXPAG5 =       10      ; # PAGES TO READ  5 1/4 disk
   34  004D            MAXTRK8 =   77  ; # Tracks to read 8 disk
   35  000F            MAXPAG8 =   15  ; # Pages to read 8 disk
   36  0877            BYTES5  = 2167
   37  0E10            BYTES8  = 3600
   38                  
   39  C000            DDPIA   =   $C000   ; Disk controller PIA
   40  C010            DDACIA  =   $C010   ; Disk Controller Serial Port
   41  FC00            C2ACIA  =   $FC00   ; ACIA on C2/C4/C8/C3
   42  F000            C1ACIA  =   $F000   ; ACIA on C1
   43                  
   44                  ;Control Character Constants XMODEM etc.
   45  000D            CR              =       $0D
   46  000A            LF              =       $0A
   47  001B            ESC             =       $1B             ; ESC to exit
   48                  
   49                  
   50                  ;storage space (anywhere, so why not page zero?)
   51  0029            STORE   =   $29   ;storage C4P starts stack at 28
   52  002A            MAXTRK  =   STORE+01 ;1 - 40 for 5.25, 77 for 8, 255 for HD
   53  002B            MAXPAG  =   STORE+02 ;1 - 9 for 5.25, 15 for 8, 16 for HD
   54  002C            ACIACTL =   STORE+03 ;1 controls cassette/rs-232 ACIA divisor, format
   55  002D            DRVNUM  =   STORE+04 ;1 drive# 0-3
   56  002E            TRK     =   STORE+05 ;1 current track #
   57  002F            TMP     =   STORE+6  ;1
   58  0030            MACHINE =   STORE+7  ;1 C1/C2/C3 flag 00=C2/4/8, $40=C3Ser, $80=C1
   59                  
   60                  
   61  0031                    *= STORE+8
   62  0031  00        VIDEO           .BYTE 0 ; 0 = Serial $FF = video
   63  0032  00        PATSEL          .BYTE 0 ;  0 = Fixed byte (PATVAL), $FF = random
   64  0033  00        PATVAL          .BYTE 0 ;  Byte to write to disk
   65  0034  00        PASSES          .BYTE 0
   66  0035  00        READONLY        .BYTE 0 ; zero read write
   67  0036  00        PASSCNTR        .BYTE 0
   68  0037  5C 9F 89  RND             .BYTE 92, 159, 137, 36, 210, 89
       003A  24 D2 59  
   69  003D  00 00 00  RNDHLD          .BYTE 0,0,0,0,0,0
       0040  00 00 00  
   70  0043  00 00 00  DIVIDEND        .BYTE 0,0,0
   71                  ;DIVISOR        .BYTE 0,0,0
   72  0046  F6 5C 00  DIVISOR         .BYTE $f6,$5c,0
   73  0049  00 00 00  REMAINDER       .BYTE 0,0,0
   74  004C  00 00 00  factor2         .BYTE 0,0,0
   75  004F  00        PZTEMP          .BYTE 0
   76  0050  00 00 00  MAX             .BYTE 0,0,0
   77  0053  00 00 00  MIN             .BYTE 0,0,0
   78  0056  00 00 00  SUM             .BYTE 0,0,0
   79  0059  00        pad             .BYTE 0
   80  005A  00 00     ERRCNT          .WORD 0
   81  005C  00        PRTERR          .BYTE 0
   82                  ; 8" RPM scale 360 RPM * (250000 bps/10 bits/byte/6 RPS) = 1500000
   83  005D  60 E3 16  RPMSCALE8       .BYTE $60, $e3, $16 
   84                  ; 5.25" RPM scale 300 * (125000/10/5) = 750000
   85  0060  B0 71 0B  RPMSCALE5       .BYTE $b0, $71, $0b 
   86                  ; Allow 3% fast rotation and 1.25 delay after index high and 2.2 ms index
   87                  ; pulse;
   88  0063  00 00     MTRKBYTES       .WORD 0 ; negative number of bytes in track
   89  0065  00 00     BYTECNTR        .WORD 0
   90  0067  00        YHOLD           .BYTE 0
   91  0068  00        TESTTYPE        .BYTE 0 ; 0 normal 1 scope
   92                  
   93                  ;zero page storage
   94  0069  00        DRVACIA         .BYTE 0 ; Current serial word format for DISK ACIA 8E1/8N1
   95  006A  00 00     PTRSTOR         .WORD 0 
   96  006C  00 00     TDATA           .WORD 0
   97  006E  00 00     TDATA2          .WORD 0
   98  0070  40 D0     VIDSRC          .WORD $D040
   99  0072  00 D0     VIDDST          .WORD $D000
  100  0074  00        VIDOFFSET       .BYTE 0
  101  0075  00        MAXERR          .BYTE 0 ; number of errors + 1 to print
  102  0076  00        SINGLETRK       .BYTE 0; non zero if testing single track
  103                  
  104                          ; Serial monitor start values
  105  0129                    *= $129
  106  0129  00 00 00          .BYTE 0,0,0,0,$fd,ORG/256,ORG%256
       012C  00 FD 03  
       012F  00        
  107                  
  108  0300                    *=      ORG
  109  0300                    .EXE *        ;A65 emit OSI .lod start address operation
  110  0300  78                SEI
  111  0301  AD 01 FE          LDA     $FE01     ;determine machine type
  112  0304  F0 0B             BEQ     SERTYP    ;Is this serial system?                                                    
  113  0306  A9 00             LDA     #$00    
  114  0308  2C 00 DF          BIT     $DF00     ;okay check C1/C2-C4
  115  030B  30 01             BMI     C1TYPE
  116  030E            C1TYPE=*+1
  117  030D  2C A9 80          BIT     $80A9     ;
  118  0311            SERTYP=*+1
  119  0310  2C A9 40          BIT     $40A9
  120  0313  85 30             STA     MACHINE   ;bit 7 = C1, bit 6 = C3, none =C2/C4
  121  0315  A9 15             LDA     #$15      ;B1 = 8N2 /16 RTStxIRQ  rxIRQ ;$15 = 8N1 /16 RTSNOtxIRQ NOrxIRQ; $B5 = irqs on 8N1
  122  0317  85 2C             STA     ACIACTL
  123                          ; Not sure how to figure out if we should use serial or video.
  124                          ; First try to determine if a serial port exists. If it does we
  125                          ; print a message to both serial and video and see which the user
  126                          ; hits a key on to select between video and serial
  127  0319  A2 0A             LDX     #10     ; 10*1.25MS wait for last character to be output
  128  031B  20 B4 0F          JSR     DELAY
  129  031E  A2 00             LDX     #0
  130  0320  20 2C 12          JSR     CheckTXReady    ; If serial not ready likely no serial port
  131  0323  B0 01             BCS     SELLP           
  132  0325  CA                DEX                     ; so don't write to serial.
  133  0326            SELLP
  134  0326  20 F3 11          JSR     Get_Chr         ; Flush serial data if any
  135  0329  86 31             STX     VIDEO           ; Select serial first then video
  136  032B  20 C3 0F          JSR     PRINT
  137  032E  0D 0A 48          .BYTE   CR,LF,'HIT ANY KEY TO SELECT CONSOLE DEVICE',CR,LF,0
       0331  49 54 20  
       0334  41 4E 59  
       0337  20 4B 45  
       033A  59 20 54  
       033D  4F 20 53  
       0340  45 4C 45  
       0343  43 54 20  
       0346  43 4F 4E  
       0349  53 4F 4C  
       034C  45 20 44  
       034F  45 56 49  
       0352  43 45 0D  
       0355  0A 00     
  138  0357  20 F3 11          JSR     Get_Chr         ; Flush serial data if any
  139  035A  CA                DEX
  140  035B  E0 FE             CPX     #$FE            ; If we did both then we are done
  141  035D  D0 C7             BNE     SELLP
  142  035F            SELLP2
  143  035F  20 F3 11          JSR     Get_Chr         ; Get serial character if one ready
  144  0362  B0 0C             BCS     SERCON          ; Got one, select serial
  145  0364  20 D5 11          JSR     Get_Chr_Polled  ; Check polled keyboard for key down
  146  0367  90 F6             BCC     SELLP2          ; Didn't find it
  147  0369  A2 FF             LDX     #$FF
  148  036B  A0 04             LDY     #4              ; Set video console and # of errors to print
  149  036D  4C 74 03          JMP     STORECON
  150  0370            SERCON
  151  0370  A2 00             LDX     #0
  152  0372  A0 06             LDY     #6              ; Set serial console and # of errors to print
  153  0374            STORECON
  154  0374  86 31             STX     VIDEO
  155  0376  84 75             STY     MAXERR
  156                  
  157  0378  A9 00             LDA     #$00    ; Reset various variables
  158  037A  85 74             STA     VIDOFFSET
  159  037C  85 2D             STA     DRVNUM
  160  037E  85 32             STA     PATSEL
  161  0380  85 68             STA     TESTTYPE
  162  0382  85 35             STA     READONLY
  163  0384  85 2E             STA     TRK     ; We don't know the track so set to zero
  164  0386  A9 01             LDA     #$01
  165  0388  85 34             STA     PASSES
  166  038A  A9 18             LDA     #$18
  167  038C  85 33             STA     PATVAL
  168  038E  24 30             BIT     MACHINE
  169  0390  50 03             BVC     *+5
  170  0392  4C 52 04          JMP     SETDRV8  ;serial systems use 8" by default
  171  0395  4C 3F 04          JMP     SETDRV5
  172                  
  173  0398            TOP
  174  0398  20 4D 10          JSR     DRWMENU ; Print menu
  175  039B  20 F3 11          JSR     Get_Chr         ; Flush serial data if any
  176  039E  A2 00             LDX     #$00
  177  03A0  20 0B 12          JSR     INKEY   ; Key user input
  178  03A3  20 3C 12          JSR     OUTPUT
  179  03A6  C9 31             CMP     #$31    ; See if its a menu choice and do it
  180  03A8  D0 03             BNE     *+5
  181  03AA  4C A2 08          JMP     TEST
  182  03AD  C9 32             CMP     #$32
  183  03AF  D0 03             BNE     *+5
  184  03B1  4C 65 04          JMP     TESTTRK
  185  03B4  C9 33             CMP     #$33
  186  03B6  D0 03             BNE     *+5
  187  03B8  4C C8 05          JMP     SETDRV
  188  03BB  C9 34             CMP     #$34
  189  03BD  D0 03             BNE     *+5
  190  03BF  4C EE 03          JMP     DRVTYPE
  191  03C2  C9 35             CMP     #$35
  192  03C4  D0 03             BNE     *+5
  193  03C6  4C BC 04          JMP     SETPAT
  194  03C9  C9 36             CMP     #$36
  195  03CB  D0 09             BNE     CHECKNEXT
  196  03CD  A9 FF             LDA     #$FF
  197  03CF  45 35             EOR     READONLY
  198  03D1  85 35             STA     READONLY
  199  03D3  4C 98 03          JMP     TOP
  200  03D6            CHECKNEXT
  201  03D6  C9 37             CMP     #$37
  202  03D8  D0 03             BNE     *+5
  203  03DA  4C 0E 06          JMP     RPMTEST
  204  03DD  C9 38             CMP     #$38
  205  03DF  D0 03             BNE     *+5
  206  03E1  4C 28 13          JMP     STATSCRN
  207  03E4  C9 39             CMP     #$39
  208  03E6  D0 03             BNE     *+5
  209  03E8  6C FC FF          JMP     ($FFFC) ;Exit
  210  03EB  4C 37 04          JMP     INPERR
  211                  
  212  03EE            DRVTYPE
  213  03EE  20 C3 0F          JSR     PRINT
  214  03F1  0D 0A 45          .BYTE $D,$A,'Enter your disk drive type (8) inch or (5).25 inch? >',0
       03F4  6E 74 65  
       03F7  72 20 79  
       03FA  6F 75 72  
       03FD  20 64 69  
       0400  73 6B 20  
       0403  64 72 69  
       0406  76 65 20  
       0409  74 79 70  
       040C  65 20 28  
       040F  38 29 20  
       0412  69 6E 63  
       0415  68 20 6F  
       0418  72 20 28  
       041B  35 29 2E  
       041E  32 35 20  
       0421  69 6E 63  
       0424  68 3F 20  
       0427  3E 00     
  215  0429  20 0B 12          JSR     INKEY
  216  042C  20 3C 12          JSR     OUTPUT
  217  042F  C9 38             CMP     #$38
  218  0431  F0 1F             BEQ     SETDRV8
  219  0433  C9 35             CMP     #$35
  220  0435  F0 08             BEQ     SETDRV5
  221  0437            INPERR
  222  0437  A9 3F             LDA     #'?     ; Print bad choice and menu again
  223  0439  20 3C 12          JSR     OUTPUT
  224  043C  4C 98 03          JMP     TOP
  225                  
  226  043F            SETDRV5
  227  043F  A9 28             LDA     #MAXTRK5
  228  0441  85 2A             STA     MAXTRK
  229  0443  A9 0A             LDA     #MAXPAG5
  230  0445  85 2B             STA     MAXPAG
  231  0447  A9 89             LDA     #-BYTES5%256
  232  0449  85 63             STA     MTRKBYTES
  233  044B  A9 F7             LDA     #-BYTES5/256
  234  044D  85 64             STA     MTRKBYTES+1
  235  044F  4C 98 03          JMP     TOP
  236                  
  237  0452            SETDRV8
  238  0452  A9 4D             LDA     #MAXTRK8
  239  0454  85 2A             STA     MAXTRK
  240  0456  A9 0F             LDA     #MAXPAG8
  241  0458  85 2B             STA     MAXPAG
  242  045A  A9 F0             LDA     #-BYTES8%256
  243  045C  85 63             STA     MTRKBYTES
  244  045E  A9 F1             LDA     #-BYTES8/256
  245  0460  85 64             STA     MTRKBYTES+1
  246  0462  4C 98 03          JMP     TOP
  247                  
  248                  
  249  0465            TESTTRK
  250  0465  20 C3 0F          JSR PRINT
  251  0468  0D 0A 45          .BYTE $D,$A,'Enter 2 digit decimal track to test > ',0
       046B  6E 74 65  
       046E  72 20 32  
       0471  20 64 69  
       0474  67 69 74  
       0477  20 64 65  
       047A  63 69 6D  
       047D  61 6C 20  
       0480  74 72 61  
       0483  63 6B 20  
       0486  74 6F 20  
       0489  74 65 73  
       048C  74 20 3E  
       048F  20 00     
  252  0491  20 A2 05          JSR GETDEC2
  253  0494  90 CF             BCC TESTTRK
  254  0496  85 67             STA YHOLD
  255  0498  C5 2A             CMP MAXTRK      ; Don't allow more than MAXTRK
  256  049A  10 C9             BPL TESTTRK
  257  049C  20 E0 0E          JSR INITPIA
  258  049F  20 00 0F          JSR SELDRV
  259  04A2  20 1D 0F          JSR TZERO       ; STEP TO TRACK 0
  260  04A5  90 03             BCC *+5
  261  04A7  4C A9 0E          JMP NOTRK
  262  04AA  A5 67             LDA YHOLD
  263  04AC  F0 07             BEQ TESTSTART
  264  04AE            TESTTN
  265  04AE  20 81 0F          JSR TNEXT       ; Step to desired track
  266  04B1  C6 67             DEC YHOLD
  267  04B3  D0 F9             BNE TESTTN
  268  04B5            TESTSTART
  269  04B5  A9 01             LDA #1          ; And set flag to only test the one track
  270  04B7  85 76             STA SINGLETRK
  271  04B9  4C A6 08          JMP TEST2
  272                  
  273  04BC            SETPAT
  274  04BC  A9 00             LDA #0
  275  04BE  85 32             STA PATSEL
  276  04C0  20 C3 0F          JSR PRINT
  277  04C3  0D 0A 45          .BYTE $D,$A,'Enter hex fill pattern or space for random > ',0
       04C6  6E 74 65  
       04C9  72 20 68  
       04CC  65 78 20  
       04CF  66 69 6C  
       04D2  6C 20 70  
       04D5  61 74 74  
       04D8  65 72 6E  
       04DB  20 6F 72  
       04DE  20 73 70  
       04E1  61 63 65  
       04E4  20 66 6F  
       04E7  72 20 72  
       04EA  61 6E 64  
       04ED  6F 6D 20  
       04F0  3E 20 00  
  278  04F3  20 0B 12          JSR INKEY
  279  04F6  20 3C 12          JSR OUTPUT
  280  04F9  29 7F             AND #$7F
  281  04FB  C9 20             CMP #' '
  282  04FD  F0 7D             BEQ PATRND
  283  04FF  20 81 05          JSR CONVHDIG
  284  0502  90 B8             BCC SETPAT
  285  0504  0A                ASL     ; Shift to high nibble
  286  0505  0A                ASL
  287  0506  0A                ASL
  288  0507  0A                ASL
  289  0508  AA                TAX
  290  0509  20 0B 12          JSR INKEY       ; Get and combine with low nibble
  291  050C  20 3C 12          JSR OUTPUT
  292  050F  20 81 05          JSR CONVHDIG
  293  0512  90 A8             BCC SETPAT
  294  0514  85 2F             STA TMP
  295  0516  8A                TXA
  296  0517  05 2F             ORA TMP
  297  0519  85 33             STA PATVAL
  298  051B            GETPASSES
  299  051B  20 C3 0F          JSR PRINT
  300  051E  0D 0A 45          .BYTE $D,$A,'Enter two digit passes > ',0
       0521  6E 74 65  
       0524  72 20 74  
       0527  77 6F 20  
       052A  64 69 67  
       052D  69 74 20  
       0530  70 61 73  
       0533  73 65 73  
       0536  20 3E 20  
       0539  00        
  301  053A  20 A2 05          JSR GETDEC2
  302  053D  90 DC             BCC GETPASSES
  303  053F  85 34             STA PASSES
  304                  
  305  0541            GETTYPE
  306  0541  20 C3 0F          JSR PRINT
  307  0544  0D 0A 28          .BYTE $D,$A,'(S)cope test or (N)ormal > ',0
       0547  53 29 63  
       054A  6F 70 65  
       054D  20 74 65  
       0550  73 74 20  
       0553  6F 72 20  
       0556  28 4E 29  
       0559  6F 72 6D  
       055C  61 6C 20  
       055F  3E 20 00  
  308  0562  20 0B 12          JSR INKEY
  309  0565  20 3C 12          JSR OUTPUT
  310  0568  29 7F             AND #$7F
  311  056A  09 20             ORA #$20
  312  056C  A2 00             LDX #0
  313  056E  C9 6E             CMP #'n'
  314  0570  F0 05             BEQ SETTYPE
  315  0572  E8                INX
  316  0573  C9 73             CMP #'s'
  317  0575  D0 CA             BNE GETTYPE
  318  0577            SETTYPE
  319  0577  86 68             STX TESTTYPE
  320  0579  4C 98 03          JMP TOP
  321  057C            PATRND
  322  057C  C6 32             DEC PATSEL
  323  057E  4C 1B 05          JMP GETPASSES
  324                  
  325  0581            CONVHDIG
  326  0581  20 91 05          JSR CONVDIG
  327  0584  B0 0A             BCS CONVHRET
  328  0586  C9 61             CMP #'a'
  329  0588  30 16             BMI CONVERR
  330  058A  C9 67             CMP #'f'+1
  331  058C  10 12             BPL CONVERR
  332  058E  E9 56             SBC #'a'-1-10
  333  0590            CONVHRET
  334  0590  60                RTS
  335  0591            CONVDIG
  336  0591  29 7F             AND #$7F
  337  0593  09 20             ORA #$20
  338  0595  C9 30             CMP #'0'
  339  0597  30 07             BMI CONVERR
  340  0599  C9 3A             CMP #'9'+1
  341  059B  10 03             BPL CONVERR
  342  059D  E9 2F             SBC #'0'-1
  343  059F  60                RTS
  344  05A0            CONVERR
  345  05A0  18                CLC
  346  05A1  60                RTS
  347                  
  348                  ; Return 2 digit decimal number in A. Carry clear if number valid
  349  05A2            GETDEC2
  350  05A2  20 0B 12          JSR INKEY
  351  05A5  20 3C 12          JSR OUTPUT
  352  05A8  20 91 05          JSR CONVDIG
  353  05AB  90 1A             BCC GETDEC2RET
  354  05AD  85 2F             STA TMP
  355  05AF  0A                ASL             ; Multiply by 8
  356  05B0  0A                ASL
  357  05B1  0A                ASL
  358  05B2  65 2F             ADC TMP         ; And add twice to make multiply by 10
  359  05B4  65 2F             ADC TMP
  360  05B6  85 2F             STA TMP
  361  05B8  20 0B 12          JSR INKEY       ; Get and add low digit
  362  05BB  20 3C 12          JSR OUTPUT
  363  05BE  20 91 05          JSR CONVDIG
  364  05C1  90 04             BCC GETDEC2RET
  365  05C3  18                CLC
  366  05C4  65 2F             ADC TMP
  367  05C6  38                SEC
  368  05C7            GETDEC2RET              ; Not valid number, return carry clear
  369  05C7  60                RTS
  370                  
  371  05C8            SETDRV
  372  05C8  20 C3 0F          JSR PRINT
  373  05CB  0D 0A 53          .BYTE $D,$A,'Select drive (A), (B), (C), (D) ? >',0
       05CE  65 6C 65  
       05D1  63 74 20  
       05D4  64 72 69  
       05D7  76 65 20  
       05DA  28 41 29  
       05DD  2C 20 28  
       05E0  42 29 2C  
       05E3  20 28 43  
       05E6  29 2C 20  
       05E9  28 44 29  
       05EC  20 3F 20  
       05EF  3E 00     
  374  05F1  20 0B 12          JSR INKEY
  375  05F4  20 3C 12          JSR OUTPUT
  376  05F7  29 5F             AND #$5F
  377  05F9  C9 41             CMP #'A
  378  05FB  90 0B             BCC SETERR
  379  05FD  C9 45             CMP #'E
  380  05FF  B0 07             BCS SETERR
  381  0601  E9 40             SBC #'@         ;carry is clear so val -1
  382  0603  85 2D             STA DRVNUM
  383  0605  4C 98 03          JMP TOP
  384  0608            SETERR
  385  0608  4C 37 04          JMP INPERR
  386                  
  387  060B            NOTRK2
  388  060B  4C A9 0E          JMP NOTRK
  389                          ; Test drive RPM with head unloaded and loaded
  390                          ; We count number of bytes sent through disk serial port between
  391                          ; index pulses to measure RPM. That is independent of CPU speed.
  392                          ; We use 8N1 for 10 total bits.
  393                          ; 8" = 25,000 characters per second and 5.25" 12,500.
  394                          ; 16 measurements are done with minimum, maximum, and avarage
  395                          ; printed
  396  060E            RPMTEST
  397  060E  20 E0 0E          JSR INITPIA
  398  0611  20 00 0F          JSR SELDRV
  399  0614  20 1D 0F          JSR TZERO       ; STEP TO TRACK 0
  400  0617  B0 F2             BCS NOTRK2
  401  0619  A9 03             LDA #3
  402  061B  8D 10 C0          STA DDACIA      ; RESET ACIA
  403  061E  A9 54             LDA #$54    ;0 10 101 00 ;$54-  recv irq, RTS HIGH no xmit irq,  8N1,  DIVIDE BY 1,
  404  0620  85 69             STA DRVACIA     
  405  0622  8D 10 C0          STA DDACIA      ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  406  0625  20 C3 0F          JSR PRINT
  407  0628  0D 0A 48          .BYTE $D,$A,'Head unloaded ',0
       062B  65 61 64  
       062E  20 75 6E  
       0631  6C 6F 61  
       0634  64 65 64  
       0637  20 00     
  408  0639  20 A9 06          JSR RPMTST2
  409  063C  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
  410  063F  29 7F             AND #$7F        ; 0111 1111
  411  0641  8D 02 C0          STA DDPIA+2     ; LOAD DISK HEAD
  412  0644  A2 FF             LDX #$FF        ; 320MS
  413  0646  20 B4 0F          JSR DELAY
  414  0649  20 C3 0F          JSR PRINT
  415  064C  0D 0A 48          .BYTE $D,$A,'Head loaded   ',0
       064F  65 61 64  
       0652  20 6C 6F  
       0655  61 64 65  
       0658  64 20 20  
       065B  20 00     
  416  065D  20 A9 06          JSR RPMTST2
  417  0660            RPMUNLOAD
  418  0660  AD 02 C0          LDA DDPIA+2
  419  0663  09 80             ORA #$80        
  420  0665  8D 02 C0          STA     DDPIA+2 ; UNLOAD DISK HEAD
  421  0668  4C 98 03          JMP TOP
  422  066B            INDEXACT
  423  066B  20 C3 0F          JSR PRINT
  424  066E  49 6E 64          .BYTE 'Index stuck active',CR,LF,0
       0671  65 78 20  
       0674  73 74 75  
       0677  63 6B 20  
       067A  61 63 74  
       067D  69 76 65  
       0680  0D 0A 00  
  425  0683  20 1E 10          JSR ANYKEY
  426  0686  4C 60 06          JMP RPMUNLOAD
  427  0689            INDEXINACT
  428  0689  20 C3 0F          JSR PRINT
  429  068C  49 6E 64          .BYTE 'Index stuck inactive',CR,LF,0
       068F  65 78 20  
       0692  73 74 75  
       0695  63 6B 20  
       0698  69 6E 61  
       069B  63 74 69  
       069E  76 65 0D  
       06A1  0A 00     
  430  06A3  20 1E 10          JSR ANYKEY
  431  06A6  4C 60 06          JMP RPMUNLOAD
  432  06A9            RPMTST2
  433  06A9  A2 00             LDX #0
  434  06AB  A0 00             LDY #0
  435  06AD            RPMTSTLP
  436  06AD  E8                INX
  437  06AE  D0 01             BNE *+3
  438  06B0  C8                INY
  439  06B1  F0 B8             BEQ INDEXACT
  440  06B3  2C 00 C0          BIT DDPIA       ; WAIT END OF
  441  06B6  10 F5             BPL RPMTSTLP    ; INDEX PULSE
  442  06B8  A9 00             LDA #0
  443  06BA  85 46             STA DIVISOR     ; Clear variables
  444  06BC  85 47             STA DIVISOR+1
  445  06BE  85 48             STA DIVISOR+2
  446  06C0  85 50             STA MAX
  447  06C2  85 51             STA MAX+1
  448  06C4  85 52             STA MAX+2
  449  06C6  85 56             STA SUM
  450  06C8  85 57             STA SUM+1
  451  06CA  85 58             STA SUM+2
  452  06CC  A9 FF             LDA #255
  453  06CE  85 53             STA MIN
  454  06D0  85 54             STA MIN+1
  455  06D2  85 55             STA MIN+2
  456  06D4  A2 10             LDX #16         ; Measure RPM 16 times
  457  06D6  A0 00             LDY #0
  458  06D8  A9 00             LDA #0
  459  06DA  18                CLC
  460  06DB            RPMLP1
  461                          ; Wait for index then write first byte to UART since it
  462                          ; should be ready. Then write a second byte since it should either
  463                          ; be ready immediatly or very shortly after first byte is transferred
  464                          ; to TX shift register. Then start counting with the writes that
  465                          ; will happen at the UART data rate.
  466  06DB  C8                INY
  467  06DC  D0 02             BNE *+4
  468  06DE  69 01             ADC #1
  469  06E0  F0 A7             BEQ INDEXINACT  ; If we wait to long for index inactive print error
  470  06E2  2C 00 C0          BIT DDPIA       ; WAIT for INDEX PULSE
  471  06E5  30 F4             BMI RPMLP1
  472  06E7  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  473  06EA            RPMNDX0
  474  06EA  A9 02             LDA #2
  475  06EC  2D 10 C0          AND DDACIA      ;test tx ready? 
  476  06EF  F0 F9             BEQ RPMNDX0     ;not ready?
  477  06F1  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  478  06F4            RPMNDX1
  479  06F4  A9 02             LDA #2
  480  06F6  2D 10 C0          AND DDACIA      ;test tx ready? 
  481  06F9  F0 F9             BEQ RPMNDX1     ;not ready?
  482  06FB  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  483  06FE  E6 46             INC DIVISOR
  484  0700  D0 02             BNE *+4
  485  0702  E6 47             INC DIVISOR+1
  486  0704  D0 02             BNE *+4
  487  0706  E6 48             INC DIVISOR+2
  488  0708  2C 00 C0          BIT DDPIA       ; WAIT END OF
  489  070B  10 E7             BPL RPMNDX1     ; INDEX PULSE
  490  070D            RPMNDX2
  491  070D  2C 00 C0          BIT DDPIA       ; DONE IF 
  492  0710  10 17             BPL RPMNDX3     ; INDEX PULSE
  493  0712  A9 02             LDA #2
  494  0714  2D 10 C0          AND DDACIA      ;test tx ready? 
  495  0717  F0 F4             BEQ RPMNDX2     ;not ready?
  496  0719  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  497  071C  E6 46             INC DIVISOR     ; Count character sent
  498  071E  D0 02             BNE *+4
  499  0720  E6 47             INC DIVISOR+1
  500  0722  D0 02             BNE *+4
  501  0724  E6 48             INC DIVISOR+2
  502  0726  4C 0D 07          JMP RPMNDX2
  503  0729            RPMNDX3
  504  0729  2C 00 C0          BIT DDPIA       ; WAIT END OF
  505  072C  10 FB             BPL RPMNDX3     ; INDEX PULSE
  506  072E  18                CLC
  507  072F  A5 56             LDA SUM         ; Sum of all rotation time
  508  0731  65 46             ADC DIVISOR
  509  0733  85 56             STA SUM
  510  0735  A5 57             LDA SUM+1
  511  0737  65 47             ADC DIVISOR+1
  512  0739  85 57             STA SUM+1
  513  073B  A5 58             LDA SUM+2
  514  073D  65 48             ADC DIVISOR+2
  515  073F  85 58             STA SUM+2
  516                  
  517  0741  A5 48             LDA DIVISOR+2
  518  0743  C5 55             CMP MIN+2
  519  0745  90 35             BCC LESS1
  520  0747  D0 0E             BNE GE1
  521  0749  A5 47             LDA DIVISOR+1
  522  074B  C5 54             CMP MIN+1
  523  074D  90 2D             BCC LESS1
  524  074F  D0 06             BNE GE1
  525  0751  A5 46             LDA DIVISOR
  526  0753  C5 53             CMP MIN
  527  0755  90 25             BCC LESS1
  528  0757            GE1     ; DIVISOR >= MIN
  529  0757  A5 48             LDA DIVISOR+2
  530  0759  C5 52             CMP MAX+2
  531  075B  90 2E             BCC LESS2
  532  075D  D0 0E             BNE GE2
  533  075F  A5 47             LDA DIVISOR+1
  534  0761  C5 51             CMP MAX+1
  535  0763  90 26             BCC LESS2
  536  0765  D0 06             BNE GE2
  537  0767  A5 46             LDA DIVISOR
  538  0769  C5 50             CMP MAX
  539  076B  90 1E             BCC LESS2
  540  076D            GE2     ; DIVISOR >= MAX
  541  076D  A5 46             LDA DIVISOR
  542  076F  85 50             STA MAX
  543  0771  A5 47             LDA DIVISOR+1
  544  0773  85 51             STA MAX+1
  545  0775  A5 48             LDA DIVISOR+2
  546  0777  85 52             STA MAX+2
  547  0779  4C 8B 07          JMP LESS2
  548                  
  549  077C            LESS1   ; DIVISOR < MIN
  550  077C  A5 46             LDA DIVISOR
  551  077E  85 53             STA MIN
  552  0780  A5 47             LDA DIVISOR+1
  553  0782  85 54             STA MIN+1
  554  0784  A5 48             LDA DIVISOR+2
  555  0786  85 55             STA MIN+2
  556  0788  4C 57 07          JMP GE1
  557                          
  558  078B            LESS2   ; DIVISOR < MAX
  559  078B  CA                DEX
  560  078C  F0 0B             BEQ RPMDONE
  561  078E  A9 00             LDA #0
  562  0790  85 46             STA DIVISOR
  563  0792  85 47             STA DIVISOR+1
  564  0794  85 48             STA DIVISOR+2
  565  0796  4C DB 06          JMP RPMLP1
  566                  
  567  0799            RPMDONE
  568  0799  20 C3 0F          JSR PRINT
  569  079C  52 50 4D          .BYTE 'RPM: AVG ',0
       079F  3A 20 41  
       07A2  56 47 20  
       07A5  00        
  570  07A6  A2 04             LDX #4          ; Divide by 16 to convert sum to average
  571  07A8            RPMDIVL
  572  07A8  18                CLC
  573  07A9  66 58             ROR SUM+2
  574  07AB  66 57             ROR SUM+1
  575  07AD  66 56             ROR SUM
  576  07AF  CA                DEX
  577  07B0  D0 F6             BNE RPMDIVL
  578  07B2  A5 56             LDA SUM
  579  07B4  85 46             STA DIVISOR
  580  07B6  A5 57             LDA SUM+1
  581  07B8  85 47             STA DIVISOR+1
  582  07BA  A5 58             LDA SUM+2
  583  07BC  85 48             STA DIVISOR+2
  584  07BE  20 F2 07          JSR RPMPRT
  585                  
  586  07C1  20 C3 0F          JSR PRINT
  587  07C4  20 20 4D          .BYTE '  MIN',0
       07C7  49 4E 00  
  588                  
  589  07CA  A5 50             LDA MAX
  590  07CC  85 46             STA DIVISOR
  591  07CE  A5 51             LDA MAX+1
  592  07D0  85 47             STA DIVISOR+1
  593  07D2  A5 52             LDA MAX+2
  594  07D4  85 48             STA DIVISOR+2
  595  07D6  20 F2 07          JSR RPMPRT
  596                  
  597  07D9  20 C3 0F          JSR PRINT
  598  07DC  20 20 4D          .BYTE '  MAX',0
       07DF  41 58 00  
  599                  
  600  07E2  A5 53             LDA MIN
  601  07E4  85 46             STA DIVISOR
  602  07E6  A5 54             LDA MIN+1
  603  07E8  85 47             STA DIVISOR+1
  604  07EA  A5 55             LDA MIN+2
  605  07EC  85 48             STA DIVISOR+2
  606  07EE  20 F2 07          JSR RPMPRT
  607  07F1  60                RTS
  608                  
  609                          ; Convert count to RPM with two decimal places
  610  07F2            RPMPRT
  611  07F2  A5 2B             LDA MAXPAG
  612  07F4  C9 0F             CMP #MAXPAG8
  613  07F6  F0 0F             BEQ RPM8
  614  07F8  A5 60             LDA RPMSCALE5
  615  07FA  85 43             STA DIVIDEND
  616  07FC  A5 61             LDA RPMSCALE5+1
  617  07FE  85 44             STA DIVIDEND+1
  618  0800  A5 62             LDA RPMSCALE5+2
  619  0802  85 45             STA DIVIDEND+2
  620  0804  4C 13 08          JMP DODIV
  621  0807            RPM8
  622  0807  A5 5D             LDA RPMSCALE8
  623  0809  85 43             STA DIVIDEND
  624  080B  A5 5E             LDA RPMSCALE8+1
  625  080D  85 44             STA DIVIDEND+1
  626  080F  A5 5F             LDA RPMSCALE8+2
  627  0811  85 45             STA DIVIDEND+2
  628  0813            DODIV
  629  0813  20 B5 12          JSR DIV24       ; Get integer part of RPM
  630  0816  A9 20             LDA #' '
  631  0818  85 59             STA pad
  632  081A  20 58 08          JSR PrDec16
  633  081D  A9 64             LDA #100        ; Multiply remainder by 100 and divide again to get
  634  081F  85 4C             STA factor2     ; fractional part
  635  0821  A9 00             LDA #0
  636  0823  85 4D             STA factor2+1
  637  0825  85 4E             STA factor2+2
  638  0827  20 EB 12          JSR MULT24
  639  082A  20 B5 12          JSR DIV24
  640  082D  A9 2E             LDA #'.'
  641  082F  20 3C 12          JSR OUTPUT
  642  0832  A9 30             LDA #'0'
  643  0834  85 59             STA pad
  644  0836  A0 02             LDY #2                       ; Print 2 digits
  645  0838  20 5A 08          JSR PrDec16Lp1
  646  083B  60                RTS
  647                          
  648                     ; From http://beebwiki.mdfs.net/Number_output_in_6502_machine_code
  649                     ; ---------------------------
  650                     ; Print 16-bit decimal number
  651                     ; ---------------------------
  652                     ; On entry, num=number to print
  653                     ;           pad=0 or pad character (eg '0' or ' ')
  654                     ; On entry at PrDec16Lp1,
  655                     ;           Y=(number of digits)*2-2, eg 8 for 5 digits
  656                     ; On exit,  A,X,Y,num,pad corrupted
  657                     ; Size      69 bytes
  658                     ; -----------------------------------------------------------------
  659  0043            num = DIVIDEND
  660                  
  661  083C            PrDec2Dig
  662  083C  85 43        STA num
  663  083E  A9 00        LDA #0
  664  0840  85 44        STA num+1
  665  0842  A9 20        LDA #' '
  666  0844  85 59        STA pad
  667  0846  A0 02        LDY #2
  668  0848  4C 5A 08     JMP PrDec16Lp1
  669  084B            PrDec4Dig
  670  084B  86 43        STX num
  671  084D  85 44        STA num+1
  672  084F  A9 20        LDA #' '
  673  0851  85 59        STA pad
  674  0853  A0 06        LDY #6
  675  0855  4C 5A 08     JMP PrDec16Lp1
  676                  
  677  0858            PrDec16
  678  0858  A0 08        LDY #8               ; Offset to powers of ten
  679  085A            PrDec16Lp1
  680  085A  A2 FF        LDX #$FF
  681  085C  38           SEC                  ; Start with digit=-1
  682  085D            PrDec16Lp2
  683  085D  A5 43        LDA num+0
  684  085F  F9 98 08     SBC PrDec16Tens+0,Y
  685  0862  85 43        STA num+0            ; Subtract current tens
  686  0864  A5 44        LDA num+1
  687  0866  F9 99 08     SBC PrDec16Tens+1,Y
  688  0869  85 44        STA num+1
  689  086B  E8           INX
  690  086C  B0 EF        BCS PrDec16Lp2       ; Loop until <0
  691  086E  A5 43        LDA num+0
  692  0870  79 98 08     ADC PrDec16Tens+0,Y
  693  0873  85 43        STA num+0            ; Add current tens back in
  694  0875  A5 44        LDA num+1
  695  0877  79 99 08     ADC PrDec16Tens+1,Y
  696  087A  85 44        STA num+1
  697  087C  8A           TXA
  698  087D  C0 00        CPY #0
  699  087F  F0 09        BEQ PrDec16Digit     ; Last digit, always print
  700  0881  8A           TXA
  701  0882  D0 06        BNE PrDec16Digit     ; Not zero, print it
  702  0884  A5 59        LDA pad
  703  0886  D0 08        BNE PrDec16Print
  704  0888  F0 09        BEQ PrDec16Next      ; pad<>0, use it
  705  088A            PrDec16Digit
  706  088A  A2 30        LDX #'0
  707  088C  86 59        STX pad              ; No more zero padding
  708  088E  09 30        ORA #'0              ; Print this digit
  709  0890            PrDec16Print
  710  0890  20 3C 12     JSR OUTPUT
  711  0893            PrDec16Next
  712  0893  88           DEY
  713  0894  88           DEY
  714  0895  10 C3        BPL PrDec16Lp1       ; Loop for next digit
  715  0897  60           RTS
  716  0898            PrDec16Tens
  717  0898  01 00        .WORD 1
  718  089A  0A 00        .WORD 10
  719  089C  64 00        .WORD 100
  720  089E  E8 03        .WORD 1000
  721  08A0  10 27        .WORD 10000
  722                  ;-----------------------------------------------------------
  723                  ; Either write test pattern then check or just check pattern.
  724                  ; Read test only works for data written by this program.
  725  08A2            TEST
  726  08A2  A9 00             LDA     #0
  727  08A4  85 76             STA     SINGLETRK
  728  08A6            TEST2
  729  08A6  20 C3 0F          JSR     PRINT
  730  08A9  0D 0A             .BYTE   CR,LF
  731  08AB  57 52 49          .BYTE   'WRITE PROTECT ALL DISKS EXCEPT TEST DISK!',CR,LF
       08AE  54 45 20  
       08B1  50 52 4F  
       08B4  54 45 43  
       08B7  54 20 41  
       08BA  4C 4C 20  
       08BD  44 49 53  
       08C0  4B 53 20  
       08C3  45 58 43  
       08C6  45 50 54  
       08C9  20 54 45  
       08CC  53 54 20  
       08CF  44 49 53  
       08D2  4B 21 0D  
       08D5  0A        
  732  08D6  0D 0A             .BYTE   CR,LF
  733  08D8  49 4E 53          .BYTE   'INSERT DISK TO BE TESTED',CR,LF
       08DB  45 52 54  
       08DE  20 44 49  
       08E1  53 4B 20  
       08E4  54 4F 20  
       08E7  42 45 20  
       08EA  54 45 53  
       08ED  54 45 44  
       08F0  0D 0A     
  734  08F2  49 66 20          .BYTE   'If errors found the output is DDDD (#### GG BBP)* EEEE',CR,LF
       08F5  65 72 72  
       08F8  6F 72 73  
       08FB  20 66 6F  
       08FE  75 6E 64  
       0901  20 74 68  
       0904  65 20 6F  
       0907  75 74 70  
       090A  75 74 20  
       090D  69 73 20  
       0910  44 44 44  
       0913  44 20 28  
       0916  23 23 23  
       0919  23 20 47  
       091C  47 20 42  
       091F  42 50 29  
       0922  2A 20 45  
       0925  45 45 45  
       0928  0D 0A     
  735  092A  77 68 65          .BYTE   'where DDDD is difference between number of bytes written',CR,LF
       092D  72 65 20  
       0930  44 44 44  
       0933  44 20 69  
       0936  73 20 64  
       0939  69 66 66  
       093C  65 72 65  
       093F  6E 63 65  
       0942  20 62 65  
       0945  74 77 65  
       0948  65 6E 20  
       094B  6E 75 6D  
       094E  62 65 72  
       0951  20 6F 66  
       0954  20 62 79  
       0957  74 65 73  
       095A  20 77 72  
       095D  69 74 74  
       0960  65 6E 0D  
       0963  0A        
  736  0964  61 6E 64          .BYTE   'and read. EEEE is total errors, #### is byte count from', CR,LF
       0967  20 72 65  
       096A  61 64 2E  
       096D  20 45 45  
       0970  45 45 20  
       0973  69 73 20  
       0976  74 6F 74  
       0979  61 6C 20  
       097C  65 72 72  
       097F  6F 72 73  
       0982  2C 20 23  
       0985  23 23 23  
       0988  20 69 73  
       098B  20 62 79  
       098E  74 65 20  
       0991  63 6F 75  
       0994  6E 74 20  
       0997  66 72 6F  
       099A  6D 0D 0A  
  737  099D  73 74 61          .BYTE   'start of track, GG is good byte, BB is bad byte,',CR,LF
       09A0  72 74 20  
       09A3  6F 66 20  
       09A6  74 72 61  
       09A9  63 6B 2C  
       09AC  20 47 47  
       09AF  20 69 73  
       09B2  20 67 6F  
       09B5  6F 64 20  
       09B8  62 79 74  
       09BB  65 2C 20  
       09BE  42 42 20  
       09C1  69 73 20  
       09C4  62 61 64  
       09C7  20 62 79  
       09CA  74 65 2C  
       09CD  0D 0A     
  738  09CF  50 20 69          .BYTE   'P is byte had parity error.',CR,LF
       09D2  73 20 62  
       09D5  79 74 65  
       09D8  20 68 61  
       09DB  64 20 70  
       09DE  61 72 69  
       09E1  74 79 20  
       09E4  65 72 72  
       09E7  6F 72 2E  
       09EA  0D 0A     
  739  09EC  45 72 72          .BYTE   'Errors that fit on line are printed.',CR,LF
       09EF  6F 72 73  
       09F2  20 74 68  
       09F5  61 74 20  
       09F8  66 69 74  
       09FB  20 6F 6E  
       09FE  20 6C 69  
       0A01  6E 65 20  
       0A04  61 72 65  
       0A07  20 70 72  
       0A0A  69 6E 74  
       0A0D  65 64 2E  
       0A10  0D 0A     
  740  0A12  45 53 43          .BYTE   'ESC KEY OR ^X ABORTS...',CR,LF,0
       0A15  20 4B 45  
       0A18  59 20 4F  
       0A1B  52 20 5E  
       0A1E  58 20 41  
       0A21  42 4F 52  
       0A24  54 53 2E  
       0A27  2E 2E 0D  
       0A2A  0A 00     
  741                  
  742  0A2C  20 1E 10          JSR     ANYKEY
  743  0A2F  C9 1B             CMP     #$1B   ;ESC key?
  744  0A31  F0 3B             BEQ     JMP2TOP
  745  0A33  C9 18             CMP     #$18   ;^X
  746  0A35  F0 37             BEQ     JMP2TOP
  747                  
  748                  
  749  0A37  A5 34             LDA     PASSES
  750  0A39  85 36             STA     PASSCNTR
  751  0A3B  20 E0 0E          JSR     INITPIA
  752  0A3E  20 00 0F          JSR     SELDRV
  753  0A41  20 CF 0E          JSR     RESPTR
  754  0A44  A9 20             LDA     #$20
  755  0A46  2C 00 C0          BIT     DDPIA
  756  0A49  D0 26             BNE     WRITEOK
  757  0A4B  20 C3 0F          JSR     PRINT
  758  0A4E  0D 0A             .BYTE   CR,LF
  759  0A50  44 49 53          .BYTE   'DISK IS WRITE PROTECTED!',CR,LF,0
       0A53  4B 20 49  
       0A56  53 20 57  
       0A59  52 49 54  
       0A5C  45 20 50  
       0A5F  52 4F 54  
       0A62  45 43 54  
       0A65  45 44 21  
       0A68  0D 0A 00  
  760  0A6B  20 1E 10          JSR     ANYKEY
  761  0A6E            JMP2TOP
  762  0A6E  4C 98 03          JMP     TOP
  763  0A71            WRITEOK
  764  0A71  A5 76             LDA     SINGLETRK
  765  0A73  D0 08             BNE     TESTFILL ; Head already at desired track
  766  0A75  20 1D 0F          JSR     TZERO   ; STEP TO TRACK 0
  767  0A78  90 03             BCC     TESTFILL
  768  0A7A  4C A9 0E          JMP     NOTRK
  769                  
  770  0A7D            TESTFILL
  771  0A7D  20 CF 0E          JSR     RESPTR
  772  0A80  A0 00             LDY     #0
  773  0A82            TFILL   
  774  0A82  A5 33             LDA     PATVAL
  775  0A84  24 32             BIT     PATSEL          ; Fill with test pattern. 
  776  0A86  10 03             BPL     TSTORE          ; Always fills larger 8" number of bytes
  777  0A88  20 9F 12          JSR     RAND
  778  0A8B            TSTORE
  779  0A8B  91 6C             STA     (TDATA),Y
  780  0A8D  C8                INY
  781  0A8E  D0 02             BNE     TCHKFILLED
  782  0A90  E6 6D             INC     TDATA+1
  783  0A92            TCHKFILLED
  784  0A92  C0 10             CPY     #BYTES8%256
  785  0A94  D0 EC             BNE     TFILL
  786  0A96  A5 6D             LDA     TDATA+1
  787  0A98  38                SEC
  788  0A99  E9 14             SBC     #BUFFER/256
  789  0A9B  C9 0E             CMP     #BYTES8/256
  790  0A9D  D0 E3             BNE     TFILL
  791                  
  792  0A9F  A9 5A             LDA     #$5A            ; Start of track marker
  793  0AA1  8D 8B 14          STA     BUFFER
  794                          
  795  0AA4  A9 58             LDA     #$58    ;0 10 110 00 ;$58-  recv irq, RTS HIGH no xmit irq,  8E1,  DIVIDE BY 1,
  796  0AA6  85 69             STA     DRVACIA 
  797                  
  798  0AA8  AD 02 C0          LDA     DDPIA+2  ; PRESERVE DISK SEL BIT
  799  0AAB  29 7F             AND     #$7F    ; 0111 1111
  800  0AAD  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
  801  0AB0  A2 FF             LDX     #$FF    ; 320MS
  802  0AB2  20 B4 0F          JSR     DELAY
  803                  
  804  0AB5  A5 35             LDA     READONLY        ; If read only skip write
  805  0AB7  F0 03             BEQ     WRNEXT
  806  0AB9  4C 55 0B          JMP     TREAD
  807  0ABC            WRNEXT
  808  0ABC  20 C3 0F          JSR     PRINT
  809  0ABF  57 54 52          .BYTE   'WTRK ',0
       0AC2  4B 20 00  
  810  0AC5  A5 2E             LDA     TRK
  811  0AC7  20 3C 08          JSR     PrDec2Dig
  812  0ACA  A5 63             LDA     MTRKBYTES
  813  0ACC  85 65             STA     BYTECNTR
  814  0ACE  A5 64             LDA     MTRKBYTES+1
  815  0AD0  85 66             STA     BYTECNTR+1
  816  0AD2  20 CF 0E          JSR     RESPTR
  817  0AD5  A5 2E             LDA     TRK     ; Write track to second byte to check for seek errors
  818  0AD7  8D 8C 14          STA     BUFFER+1
  819                  
  820  0ADA  2C 00 C0          BIT     DDPIA   ; WAIT 
  821  0ADD  30 FB             BMI     *-3     ; INDEX PULSE
  822  0ADF  2C 00 C0          BIT     DDPIA   ; WAIT END OF
  823  0AE2  10 FB             BPL     *-3     ; INDEX PULSE
  824  0AE4  AD 02 C0          LDA     DDPIA+2 ; PRESERVE DISK SEL BIT
  825  0AE7  29 FC             AND     #$FC    ; TURN ON WRITE AND ERASE ENABLE
  826  0AE9  8D 02 C0          STA     DDPIA+2
  827                  
  828  0AEC  A9 03             LDA     #3
  829  0AEE  8D 10 C0          STA     DDACIA  ; RESET ACIA
  830  0AF1  A5 69             LDA     DRVACIA ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
  831  0AF3  8D 10 C0          STA     DDACIA  ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  832  0AF6  A2 01             LDX     #1      ; 0.8MS
  833  0AF8  A0 9E             LDY     #$9E
  834  0AFA  20 B6 0F          JSR     DELAY1
  835  0AFD  A0 00             LDY     #0
  836  0AFF            WRDATALP
  837  0AFF  2C 00 C0          BIT     DDPIA   ; WAIT 
  838  0B02  30 03             BMI     WNOINDEXERR     ; Didn't find INDEX PULSE
  839  0B04  4C 5B 0E          JMP     INDEXERR        
  840  0B07            WNOINDEXERR
  841  0B07  A9 02             LDA     #2
  842  0B09  2D 10 C0          AND     DDACIA          ;test tx ready? 
  843  0B0C  F0 F1             BEQ     WRDATALP        ;not ready?
  844  0B0E  B1 6C             LDA     (TDATA),Y
  845  0B10  8D 11 C0          STA     DDACIA+1        ; Write data to floppy
  846  0B13  C8                INY
  847  0B14  D0 02             BNE     *+4
  848  0B16  E6 6D             INC     TDATA+1
  849  0B18  E6 65             INC     BYTECNTR
  850  0B1A  D0 E3             BNE     WRDATALP
  851  0B1C  E6 66             INC     BYTECNTR+1
  852  0B1E  D0 E7             BNE     WNOINDEXERR     ; Not done, write more. Don't check for index
  853                                                  ; to prevent being late writing next char.
  854                  
  855  0B20  2C 00 C0          BIT     DDPIA   ; WAIT FOR
  856  0B23  30 FB             BMI     *-3     ; INDEX PULSE
  857  0B25  2C 00 C0          BIT     DDPIA   ; WAIT FOR
  858  0B28  10 FB             BPL     *-3     ; END INDEX PULSE
  859  0B2A  A2 20             LDX     #32     ; Erase a little past index
  860  0B2C  CA                DEX
  861  0B2D  D0 FD             BNE     *-1
  862                          
  863  0B2F  A9 03             LDA     #$03
  864  0B31  0D 02 C0          ORA     DDPIA+2 ; turn off write and erase
  865  0B34  8D 02 C0          STA     DDPIA+2
  866                  
  867  0B37  A9 0D             LDA     #CR
  868  0B39  20 3C 12          JSR     OUTPUT
  869  0B3C  A5 76             LDA     SINGLETRK
  870  0B3E  D0 15             BNE     TREAD   ; Single track, we are done writing
  871  0B40  A6 2E             LDX     TRK
  872  0B42  E8                INX
  873  0B43  E4 2A             CPX     MAXTRK
  874  0B45  F0 06             BEQ     TWDONE
  875  0B47  20 81 0F          JSR     TNEXT   ; Go to next track
  876  0B4A  4C BC 0A          JMP     WRNEXT
  877  0B4D            TWDONE
  878  0B4D  A9 80             LDA     #$80
  879  0B4F  0D 02 C0          ORA     DDPIA+2 ; Unload head
  880  0B52  8D 02 C0          STA     DDPIA+2
  881                  
  882                  
  883                          ; Read portion of disk test. Enter at TREAD2 if testing
  884                          ; single track. For normal read we save off the data read and the
  885                          ; error flags from the serial chip. We don't have enough time
  886                          ; to handle errors between bytes.
  887                          ; For scope read we check the word in real time and generate
  888                          ; fault reset pulse to trigger a scope. Checking for the track stops
  889                          ; after the first error.
  890  0B55            TREAD
  891  0B55  A5 76             LDA     SINGLETRK
  892  0B57  D0 15             BNE     TREAD2  ; Single track, skip seek to zero
  893  0B59  20 1D 0F          JSR     TZERO   ; STEP TO TRACK 0
  894  0B5C  90 03             BCC     *+5
  895  0B5E  4C A9 0E          JMP     NOTRK
  896  0B61  AD 02 C0          LDA     DDPIA+2  ; PRESERVE DISK SEL BIT
  897  0B64  29 7F             AND     #$7F    ; 0111 1111
  898  0B66  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
  899  0B69  A2 FF             LDX     #$FF    ; 320MS
  900  0B6B  20 B4 0F          JSR     DELAY
  901                  
  902  0B6E            TREAD2
  903  0B6E  20 CF 0E          JSR     RESPTR
  904  0B71  A9 00             LDA     #0
  905  0B73  85 5A             STA     ERRCNT
  906  0B75  85 5B             STA     ERRCNT+1
  907  0B77  85 5C             STA     PRTERR  
  908                  
  909  0B79  20 C3 0F          JSR     PRINT
  910  0B7C  52 54 52          .BYTE   'RTRK ',0
       0B7F  4B 20 00  
  911  0B82  A5 2E             LDA     TRK
  912  0B84  20 3C 08          JSR     PrDec2Dig
  913  0B87  A9 20             LDA     #' '
  914  0B89  20 3C 12          JSR     OUTPUT
  915  0B8C  A5 2E             LDA     TRK             ; Update compare data with track testing
  916  0B8E  8D 8C 14          STA     BUFFER+1
  917                  
  918  0B91  2C 00 C0          BIT     DDPIA   ; WAIT 
  919  0B94  30 FB             BMI     *-3     ; INDEX PULSE
  920  0B96  2C 00 C0          BIT     DDPIA   ; WAIT END OF
  921  0B99  10 FB             BPL     *-3     ; INDEX PULSE
  922  0B9B  A9 03             LDA     #3
  923  0B9D  8D 10 C0          STA     DDACIA  ; RESET ACIA
  924  0BA0  A5 69             LDA     DRVACIA ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
  925  0BA2  8D 10 C0          STA     DDACIA  ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  926  0BA5  A5 68             LDA     TESTTYPE
  927  0BA7  D0 03             BNE     *+5
  928  0BA9  4C D5 0C          JMP     NORMREAD        ; User selected normal read test
  929                  
  930                          ; This is scope read check code
  931  0BAC  A0 00             LDY     #0
  932  0BAE  A9 01             LDA     #1
  933  0BB0            RDATALP2
  934  0BB0  2C 00 C0          BIT     DDPIA
  935  0BB3  10 35             BPL     NODATA          ; INDEX PULSE
  936  0BB5  2C 10 C0          BIT     DDACIA          ; test tx ready?        
  937  0BB8  F0 F6             BEQ     RDATALP2
  938  0BBA  08                PHP
  939  0BBB  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
  940  0BBE  C9 5A             CMP     #$5A            ; Got start byte
  941  0BC0  D0 07             BNE     IGNBYTE         ; No, try one more time. We get one junk
  942                                                  ; byte where write turned on/off
  943  0BC2  28                PLP
  944  0BC3  70 33             BVS     SERROR          ; Did it get a parity error
  945  0BC5  C8                INY                     ; Skip this byte in checking since we checked
  946  0BC6  4C CA 0B          JMP     RDATALP3
  947  0BC9            IGNBYTE
  948  0BC9  28                PLP
  949  0BCA            RDATALP3
  950  0BCA  2C 00 C0          BIT     DDPIA
  951  0BCD  30 03             BMI     NOTINDEX2       ; INDEX PULSE
  952  0BCF  4C E0 0D          JMP     PCRONLY
  953  0BD2            NOTINDEX2
  954  0BD2  A9 01             LDA     #1
  955  0BD4  2C 10 C0          BIT     DDACIA          ; test tx ready?        
  956  0BD7  F0 F1             BEQ     RDATALP3
  957  0BD9  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
  958  0BDC  70 1A             BVS     SERROR          ; Branch if parity error
  959  0BDE  D1 6C             CMP     (TDATA),Y       ; Check data
  960  0BE0  D0 16             BNE     SERROR
  961  0BE2  C8                INY
  962  0BE3  D0 ED             BNE     NOTINDEX2
  963  0BE5  E6 6D             INC     TDATA+1
  964  0BE7  4C D2 0B          JMP     NOTINDEX2
  965  0BEA            NODATA
  966  0BEA  20 C3 0F          JSR     PRINT
  967  0BED  4E 6F 20          .BYTE   'No data',0
       0BF0  64 61 74  
       0BF3  61 00     
  968  0BF5            JPCRLF
  969  0BF5  4C D7 0D          JMP     PCRLF
  970  0BF8            SERROR  ; Print error info and generate scope trigger
  971  0BF8  48                PHA
  972  0BF9  A9 EF             LDA     #$EF
  973  0BFB  2D 02 C0          AND     DDPIA+2 ; Clear fault reset
  974  0BFE  8D 02 C0          STA     DDPIA+2
  975  0C01  20 BF 0F          JSR     DELAY2
  976  0C04  A9 10             LDA     #$10
  977  0C06  0D 02 C0          ORA     DDPIA+2 ; Set fault reset
  978  0C09  8D 02 C0          STA     DDPIA+2
  979                  
  980  0C0C  38                SEC
  981  0C0D  A5 6D             LDA     TDATA+1         ; Calculate offset of byte with error
  982  0C0F  E9 14             SBC     #>BUFFER
  983  0C11  85 44             STA     num+1
  984  0C13  84 67             STY     YHOLD
  985  0C15  84 43             STY     num
  986  0C17  98                TYA
  987  0C18  18                CLC
  988  0C19  65 63             ADC     MTRKBYTES
  989  0C1B  A5 44             LDA     num+1
  990  0C1D  65 64             ADC     MTRKBYTES+1
  991  0C1F  30 16             BMI     SPERR   ; Error was in bytes being tested
  992  0C21  20 C3 0F          JSR     PRINT
  993  0C24  45 78 74          .BYTE   'Extra data read',0
       0C27  72 61 20  
       0C2A  64 61 74  
       0C2D  61 20 72  
       0C30  65 61 64  
       0C33  00        
  994  0C34  4C 5E 0C          JMP     SERRWAIT
  995                          
  996  0C37            SPERR
  997  0C37  A9 30             LDA     #'0'
  998  0C39  85 59             STA     pad
  999  0C3B  A0 06             LDY     #6      ; 4 digits max
 1000  0C3D  20 5A 08          JSR     PrDec16Lp1
 1001  0C40  20 C3 0F          JSR     PRINT
 1002  0C43  20 47 4F          .BYTE   ' GOOD ',0
       0C46  4F 44 20  
       0C49  00        
 1003  0C4A  A4 67             LDY     YHOLD
 1004  0C4C  B1 6C             LDA     (TDATA),Y
 1005  0C4E  20 ED 0F          JSR     PHEXA
 1006  0C51  20 C3 0F          JSR     PRINT
 1007  0C54  20 42 41          .BYTE   ' BAD ',0
       0C57  44 20 00  
 1008  0C5A  68                PLA
 1009  0C5B  20 ED 0F          JSR     PHEXA
 1010  0C5E            SERRWAIT
 1011  0C5E  AD 02 C0          LDA     DDPIA+2
 1012  0C61  09 80             ORA     #$80    
 1013  0C63  8D 02 C0          STA     DDPIA+2 ; UNLOAD DISK HEAD
 1014  0C66  20 F3 11          JSR     Get_Chr
 1015  0C69  20 C3 0F          JSR     PRINT
 1016  0C6C  0D 0A 48          .BYTE   CR,LF,'Hit space to reread E to exit or other key to continue > ',0
       0C6F  69 74 20  
       0C72  73 70 61  
       0C75  63 65 20  
       0C78  74 6F 20  
       0C7B  72 65 72  
       0C7E  65 61 64  
       0C81  20 45 20  
       0C84  74 6F 20  
       0C87  65 78 69  
       0C8A  74 20 6F  
       0C8D  72 20 6F  
       0C90  74 68 65  
       0C93  72 20 6B  
       0C96  65 79 20  
       0C99  74 6F 20  
       0C9C  63 6F 6E  
       0C9F  74 69 6E  
       0CA2  75 65 20  
       0CA5  3E 20 00  
 1017  0CA8  20 0B 12          JSR     INKEY
 1018  0CAB  48                PHA
 1019  0CAC  20 C3 0F          JSR     PRINT
 1020  0CAF  0D 0A 00          .BYTE   CR,LF,0
 1021  0CB2  68                PLA
 1022  0CB3  09 20             ORA     #$20    ; Lower case
 1023  0CB5  C9 65             CMP     #'e'
 1024  0CB7  D0 03             BNE     *+5
 1025  0CB9  4C 98 03          JMP     TOP
 1026  0CBC  48                PHA
 1027  0CBD  AD 02 C0          LDA     DDPIA+2  ; PRESERVE DISK SEL BIT
 1028  0CC0  29 7F             AND     #$7F    ; 0111 1111
 1029  0CC2  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
 1030  0CC5  A2 FF             LDX     #$FF    ; 320MS
 1031  0CC7  20 B4 0F          JSR     DELAY
 1032  0CCA  68                PLA
 1033  0CCB  C9 20             CMP     #' '
 1034  0CCD  F0 03             BEQ     *+5
 1035  0CCF  4C E5 0D          JMP     NEXTTRK
 1036  0CD2  4C 6E 0B          JMP     TREAD2
 1037                          
 1038                          
 1039                  
 1040                          ; This is normal read check code
 1041  0CD5            NORMREAD
 1042  0CD5  A0 00             LDY     #0
 1043  0CD7            RDATALP
 1044  0CD7  2C 00 C0          BIT     DDPIA
 1045  0CDA  10 16             BPL     RINDEX  ; INDEX PULSE
 1046  0CDC            NOTINDEX
 1047  0CDC  AD 10 C0          LDA     DDACIA          ; test tx ready?        
 1048  0CDF  91 6E             STA     (TDATA2),Y      ; store error data
 1049  0CE1  4A                LSR
 1050  0CE2  90 F3             BCC     RDATALP         ; not ready?
 1051  0CE4  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
 1052  0CE7  C8                INY
 1053  0CE8  91 6E             STA     (TDATA2),Y      ; store disk data
 1054  0CEA  C8                INY
 1055  0CEB  D0 EF             BNE     NOTINDEX
 1056  0CED  E6 6F             INC     TDATA2+1
 1057  0CEF  4C DC 0C          JMP     NOTINDEX
 1058                  
 1059  0CF2            RINDEX
 1060  0CF2  18                CLC     ; Found index, determine how many bytes read
 1061  0CF3  98                TYA
 1062  0CF4  65 6E             ADC     TDATA2
 1063  0CF6  85 6E             STA     TDATA2
 1064  0CF8  90 02             BCC     *+4
 1065  0CFA  E6 6F             INC     TDATA2+1
 1066  0CFC  38                SEC
 1067  0CFD  A5 6E             LDA     TDATA2
 1068  0CFF  E9 9B             SBC     #<BUFFER2
 1069  0D01  85 65             STA     BYTECNTR
 1070  0D03  A5 6F             LDA     TDATA2+1
 1071  0D05  E9 22             SBC     #>BUFFER2
 1072  0D07  18                CLC
 1073  0D08  6A                ROR
 1074  0D09  85 66             STA     BYTECNTR+1
 1075  0D0B  A5 65             LDA     BYTECNTR        ; divide by 2 to get bytes data stored
 1076  0D0D  6A                ROR
 1077  0D0E  85 65             STA     BYTECNTR
 1078  0D10  A5 65             LDA     BYTECNTR
 1079  0D12  D0 04             BNE     CHKSTART
 1080  0D14  A5 66             LDA     BYTECNTR+1
 1081  0D16  F0 26             BEQ     NOSKIP          ; If no data don't try to find start of track
 1082  0D18            CHKSTART
 1083                          ; This will skip up to 1 byte looking for $5A start of track flag
 1084                          ; The write turn on/off generates one byte of junk sometimes
 1085  0D18  20 CF 0E          JSR     RESPTR
 1086  0D1B  AD 9C 22          LDA     BUFFER2+1
 1087  0D1E  C9 5A             CMP     #$5A            ; Start of track flag
 1088  0D20  F0 1C             BEQ     NOSKIP
 1089  0D22  AD 9E 22          LDA     BUFFER2+3
 1090  0D25  C9 5A             CMP     #$5A            ; Start of track flag
 1091  0D27  D0 15             BNE     NOSKIP          ; No, assume read error
 1092  0D29  18                CLC
 1093  0D2A  A9 02             LDA     #2
 1094  0D2C  65 6E             ADC     TDATA2
 1095  0D2E  85 6E             STA     TDATA2
 1096  0D30  A9 00             LDA     #0
 1097  0D32  65 6F             ADC     TDATA2+1        ; Ignore one junk character
 1098  0D34  85 6F             STA     TDATA2+1        ; and parity byte
 1099  0D36  A5 65             LDA     BYTECNTR
 1100  0D38  D0 02             BNE     *+4
 1101  0D3A  C6 66             DEC     BYTECNTR+1
 1102  0D3C  C6 65             DEC     BYTECNTR
 1103  0D3E            NOSKIP
 1104  0D3E  18                CLC     ; Print bytes read - bytes written. Skipped byte not
 1105                                  ; included in bytes read 
 1106  0D3F  A5 65             LDA     BYTECNTR
 1107  0D41  65 63             ADC     MTRKBYTES
 1108  0D43  AA                TAX
 1109  0D44  A5 66             LDA     BYTECNTR+1
 1110  0D46  65 64             ADC     MTRKBYTES+1
 1111  0D48  30 0D             BMI     PNEG
 1112  0D4A  48                PHA
 1113  0D4B  A9 20             LDA     #' '
 1114  0D4D  20 3C 12          JSR     OUTPUT
 1115  0D50  68                PLA
 1116  0D51  20 4B 08          JSR     PrDec4Dig
 1117  0D54  4C 8C 0D          JMP     RCHKDATA
 1118  0D57            PNEG
 1119  0D57  85 67             STA     YHOLD
 1120  0D59  86 2F             STX     TMP
 1121  0D5B  A9 2D             LDA     #'-'
 1122  0D5D  20 3C 12          JSR     OUTPUT
 1123  0D60  A9 00             LDA     #0
 1124  0D62  38                SEC
 1125  0D63  E5 2F             SBC     TMP
 1126  0D65  85 43             STA     num
 1127  0D67  A9 00             LDA     #0
 1128  0D69  E5 67             SBC     YHOLD
 1129  0D6B  85 44             STA     num+1
 1130  0D6D  A9 2D             LDA     #'-'
 1131  0D6F  85 59             STA     pad
 1132  0D71  A0 06             LDY     #6
 1133  0D73  20 5A 08          JSR     PrDec16Lp1
 1134                  
 1135  0D76  38                SEC
 1136  0D77  A9 00             LDA     #0
 1137                          ; Bytes read shorter than expected so only check bytes read.
 1138  0D79  E5 65             SBC     BYTECNTR        
 1139  0D7B  85 65             STA     BYTECNTR        ; Convert to negative count
 1140  0D7D  A9 00             LDA     #0
 1141  0D7F  E5 66             SBC     BYTECNTR+1
 1142  0D81  85 66             STA     BYTECNTR+1
 1143  0D83  D0 0F             BNE     RCHKDATALP
 1144  0D85  A5 65             LDA     BYTECNTR
 1145  0D87  D0 0B             BNE     RCHKDATALP
 1146  0D89  4C D7 0D          JMP     PCRLF   ; No bytes read, don't compare. Just print CRLF
 1147  0D8C            RCHKDATA
 1148  0D8C  A5 63             LDA     MTRKBYTES
 1149  0D8E  85 65             STA     BYTECNTR
 1150  0D90  A5 64             LDA     MTRKBYTES+1
 1151  0D92  85 66             STA     BYTECNTR+1
 1152  0D94            RCHKDATALP
 1153  0D94  A0 00             LDY     #0
 1154  0D96  A9 40             LDA     #$40
 1155  0D98  31 6E             AND     (TDATA2),Y
 1156  0D9A  D0 6F             BNE     RERROR  ; Data had parity error
 1157  0D9C  A5 6F             LDA     TDATA2+1
 1158  0D9E  C8                INY
 1159  0D9F  B1 6E             LDA     (TDATA2),Y
 1160  0DA1  88                DEY
 1161  0DA2  D1 6C             CMP     (TDATA),Y
 1162  0DA4  D0 65             BNE     RERROR  ; Miscompare
 1163  0DA6            RCONT
 1164  0DA6  18                CLC
 1165  0DA7  A9 02             LDA     #2
 1166  0DA9  65 6E             ADC     TDATA2  ; Inc data pointers
 1167  0DAB  85 6E             STA     TDATA2
 1168  0DAD  90 02             BCC     *+4
 1169  0DAF  E6 6F             INC     TDATA2+1
 1170  0DB1  E6 6C             INC     TDATA
 1171  0DB3  D0 02             BNE     *+4
 1172  0DB5  E6 6D             INC     TDATA+1
 1173  0DB7  E6 65             INC     BYTECNTR
 1174  0DB9  D0 02             BNE     *+4
 1175  0DBB  E6 66             INC     BYTECNTR+1
 1176  0DBD  D0 D5             BNE     RCHKDATALP
 1177                  
 1178  0DBF            PRTERRCNT
 1179  0DBF  A5 5A             LDA     ERRCNT  ; Done compare, did we get any errors?
 1180  0DC1  D0 04             BNE     PERRCNT
 1181  0DC3  A5 5B             LDA     ERRCNT+1
 1182  0DC5  F0 0C             BEQ     PNOERR  ; no
 1183  0DC7            PERRCNT
 1184  0DC7  A9 20             LDA     #' '
 1185  0DC9  20 3C 12          JSR     OUTPUT
 1186  0DCC  A6 5A             LDX     ERRCNT
 1187  0DCE  A5 5B             LDA     ERRCNT+1
 1188  0DD0  20 4B 08          JSR     PrDec4Dig
 1189  0DD3            PNOERR
 1190  0DD3  A5 5C             LDA     PRTERR
 1191  0DD5  F0 09             BEQ     PCRONLY
 1192  0DD7            PCRLF
 1193  0DD7  20 C3 0F          JSR     PRINT
 1194  0DDA  0D 0A 00          .BYTE   CR,LF,0
 1195  0DDD  4C E5 0D          JMP     NEXTTRK
 1196  0DE0            PCRONLY
 1197  0DE0  A9 0D             LDA     #CR
 1198  0DE2  20 3C 12          JSR     OUTPUT
 1199  0DE5            NEXTTRK
 1200  0DE5  A5 76             LDA     SINGLETRK       ; Done if single track or at max
 1201  0DE7  D0 0D             BNE     TRDONE
 1202  0DE9  A6 2E             LDX     TRK
 1203  0DEB  E8                INX
 1204  0DEC  E4 2A             CPX     MAXTRK
 1205  0DEE  F0 06             BEQ     TRDONE
 1206  0DF0  20 81 0F          JSR     TNEXT   ; seek to next track
 1207  0DF3            JTREAD2
 1208  0DF3  4C 6E 0B          JMP     TREAD2
 1209  0DF6            TRDONE
 1210  0DF6  A9 80             LDA     #$80
 1211  0DF8  0D 02 C0          ORA     DDPIA+2 ; Unload head
 1212  0DFB  8D 02 C0          STA     DDPIA+2
 1213  0DFE  C6 36             DEC     PASSCNTR
 1214  0E00  F0 03             BEQ     JMPTOP
 1215  0E02  4C 71 0A          JMP     WRITEOK
 1216  0E05            JMPTOP
 1217  0E05  20 1E 10          JSR     ANYKEY
 1218  0E08  4C 98 03          JMP     TOP
 1219                  
 1220                          ; Print offset of error and good and bad data
 1221  0E0B            RERROR
 1222  0E0B  E6 5A             INC     ERRCNT
 1223  0E0D  D0 02             BNE     *+4
 1224  0E0F  E6 5B             INC     ERRCNT+1
 1225  0E11  A5 5A             LDA     ERRCNT
 1226  0E13  C5 75             CMP     MAXERR          ; Only print first MAXERR errors
 1227  0E15  B0 41             BCS     NOPRT
 1228  0E17  A5 5B             LDA     ERRCNT+1
 1229  0E19  D0 3D             BNE     NOPRT
 1230  0E1B  A9 20             LDA     #' '
 1231  0E1D  85 5C             STA     PRTERR
 1232  0E1F  20 3C 12          JSR     OUTPUT
 1233  0E22  38                SEC
 1234  0E23  A5 6C             LDA     TDATA
 1235  0E25  E9 8B             SBC     #<BUFFER
 1236  0E27  AA                TAX
 1237  0E28  A5 6D             LDA     TDATA+1
 1238  0E2A  E9 14             SBC     #>BUFFER        
 1239  0E2C  20 4B 08          JSR     PrDec4Dig
 1240  0E2F  A9 20             LDA     #' '
 1241  0E31  20 3C 12          JSR     OUTPUT
 1242  0E34  A0 00             LDY     #0
 1243  0E36  B1 6C             LDA     (TDATA),Y       ; Good value
 1244  0E38  20 ED 0F          JSR     PHEXA
 1245  0E3B  A9 20             LDA     #' '
 1246  0E3D  20 3C 12          JSR     OUTPUT
 1247  0E40  C8                INY
 1248  0E41  B1 6E             LDA     (TDATA2),Y      ; Bad value
 1249  0E43  88                DEY
 1250  0E44  20 ED 0F          JSR     PHEXA
 1251  0E47  A2 20             LDX     #' '
 1252  0E49  A9 40             LDA     #$40
 1253  0E4B  31 6E             AND     (TDATA2),Y
 1254  0E4D  F0 02             BEQ     *+4
 1255  0E4F  A2 50             LDX     #'P'            ; Parity error
 1256  0E51  8A                TXA
 1257  0E52  20 3C 12          JSR     OUTPUT
 1258  0E55  4C A6 0D          JMP     RCONT
 1259  0E58            NOPRT
 1260  0E58  4C A6 0D          JMP     RCONT
 1261                          
 1262  0E5B            INDEXERR
 1263                          ; Found index before we wrote all our data
 1264  0E5B  A9 83             LDA     #$83
 1265  0E5D  0D 02 C0          ORA     DDPIA+2 ; Unload head, turn off write and erase
 1266  0E60  8D 02 C0          STA     DDPIA+2
 1267  0E63  20 C3 0F          JSR     PRINT
 1268  0E66  0D 0A             .BYTE   CR,LF
 1269  0E68  49 4E 44          .BYTE   'INDEX ACTIVE DURING WRITE, BYTES LEFT: ',0
       0E6B  45 58 20  
       0E6E  41 43 54  
       0E71  49 56 45  
       0E74  20 44 55  
       0E77  52 49 4E  
       0E7A  47 20 57  
       0E7D  52 49 54  
       0E80  45 2C 20  
       0E83  42 59 54  
       0E86  45 53 20  
       0E89  4C 45 46  
       0E8C  54 3A 20  
       0E8F  00        
 1270  0E90  38                SEC
 1271  0E91  A9 00             LDA     #0
 1272  0E93  E5 65             SBC     BYTECNTR
 1273  0E95  AA                TAX
 1274  0E96  A9 00             LDA     #0
 1275  0E98  E5 66             SBC     BYTECNTR+1      
 1276  0E9A  20 07 10          JSR     PDEC
 1277  0E9D  20 C3 0F          JSR     PRINT
 1278  0EA0  0D 0A 00          .BYTE   CR,LF,0
 1279  0EA3  20 1E 10          JSR     ANYKEY
 1280  0EA6  4C 98 03          JMP     TOP
 1281                          
 1282  0EA9            NOTRK
 1283  0EA9  20 E0 0E          JSR     INITPIA
 1284  0EAC  20 C3 0F          JSR     PRINT
 1285  0EAF  0D 0A 0D          .BYTE CR,LF,CR,LF, 'ERROR Seeking Track 0',0
       0EB2  0A 45 52  
       0EB5  52 4F 52  
       0EB8  20 53 65  
       0EBB  65 6B 69  
       0EBE  6E 67 20  
       0EC1  54 72 61  
       0EC4  63 6B 20  
       0EC7  30 00     
 1286  0EC9  20 1E 10          JSR     ANYKEY
 1287  0ECC  4C 98 03          JMP     TOP     
 1288                  
 1289                  ; RESET BUFFER POINTERS
 1290  0ECF            RESPTR  
 1291  0ECF  A9 8B             LDA     #<BUFFER
 1292  0ED1  85 6C             STA     TDATA
 1293  0ED3  A9 14             LDA     #>BUFFER
 1294  0ED5  85 6D             STA     TDATA+1
 1295  0ED7  A9 9B             LDA     #<BUFFER2
 1296  0ED9  85 6E             STA     TDATA2
 1297  0EDB  A9 22             LDA     #>BUFFER2
 1298  0EDD  85 6F             STA     TDATA2+1
 1299                  
 1300  0EDF  60                RTS
 1301                  
 1302                  ; INIT DISK CONTROLLER PIA
 1303  0EE0            INITPIA 
 1304  0EE0  A0 00             LDY     #0
 1305  0EE2  A9 40             LDA     #$40
 1306  0EE4  8C 01 C0          STY     DDPIA+1 ; SELECT DDRA
 1307  0EE7  8D 00 C0          STA     DDPIA   ; SET PORTA TO ALL INPUTS except PA6
 1308  0EEA  A2 04             LDX     #4              ; 0000 0100
 1309  0EEC  8E 01 C0          STX     DDPIA+1 ; SELECT PORTA
 1310  0EEF  8D 00 C0          STA     DDPIA    ; SET PB6 HIGH
 1311  0EF2  8C 03 C0          STY     DDPIA+3 ; SELECT DDRB
 1312  0EF5  88                DEY
 1313  0EF6  8C 02 C0          STY     DDPIA+2 ; SET PORTB TO ALL OUTPUTS
 1314  0EF9  8E 03 C0          STX     DDPIA+3 ; SELECT PORTB
 1315  0EFC  8C 02 C0          STY     DDPIA+2 ; SET PORTB OUTPUTS HIGH
 1316  0EFF  60                RTS
 1317                  
 1318                  
 1319                  ;SELECT DRIVE PB5 PA6  DRIVE (1-4)
 1320                  ;              0   0    #4
 1321                  ;              0   1    #3
 1322                  ;              1   0    #2
 1323                  ;              1   1    #1
 1324                  
 1325  0F00            SELDRV
 1326  0F00  A5 2D             LDA     DRVNUM
 1327  0F02  4A                LSR     A
 1328  0F03  A8                TAY
 1329  0F04  90 03             BCC     *+5
 1330  0F06  A9 00             LDA     #$00
 1331  0F08  2C A9 40          BIT     $40A9   ; This is LDA #$40 if BCC branches
 1332  0F0B  8D 00 C0          STA     DDPIA   ; This is A/B select in port A
 1333  0F0E  AD 02 C0          LDA     DDPIA+2
 1334  0F11  09 20             ORA     #$20
 1335  0F13  C0 01             CPY     #$01
 1336  0F15  90 02             BCC     *+4
 1337  0F17  29 DF             AND     #$DF
 1338  0F19  8D 02 C0          STA     DDPIA+2 ; This is master select in port B
 1339  0F1C  60                RTS
 1340                  
 1341                  
 1342                  ; STEP TO TRACK 0. Carry clear if no error. A modified. TRK set to 0
 1343                  ; if no error.
 1344                  
 1345  0F1D            TZERO
 1346  0F1D  A5 2A             LDA     MAXTRK  ;max num tracks
 1347  0F1F  69 08             ADC     #$08    ;plus a few more
 1348  0F21  85 2F             STA     TMP             ;MAX times to step before abort
 1349  0F23  AD 02 C0          LDA     DDPIA+2
 1350  0F26  29 FB             AND     #$FB    ; 1111 1011
 1351  0F28  D0 1B             BNE     TZERO3  ; DIR=INWARDS, start with one step away from track 0
 1352                  
 1353  0F2A            TZERO1
 1354  0F2A  C6 2F             DEC     TMP
 1355  0F2C  D0 02             BNE     TZERO5
 1356  0F2E  38                SEC
 1357  0F2F  60                RTS
 1358  0F30            TZERO5  
 1359  0F30  A9 02             LDA     #2              ; 0000 0010
 1360  0F32  2C 00 C0          BIT     DDPIA   ; TEST 'TRK0' PIN
 1361  0F35  D0 09             BNE     TZERO2  ; AT TRACK 0
 1362  0F37  A9 00             LDA     #0
 1363  0F39  85 2E             STA     TRK
 1364  0F3B  20 A3 0F          JSR     REDWR
 1365  0F3E  18                CLC
 1366  0F3F  60                RTS
 1367                  
 1368  0F40            TZERO2  
 1369  0F40  AD 02 C0          LDA     DDPIA+2 ; DIR=OUTWARDS (TO TRK0)
 1370  0F43  09 04             ORA     #$04
 1371  0F45            TZERO3  
 1372  0F45  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1373  0F48  20 BF 0F          JSR     DELAY2
 1374  0F4B  29 F7             AND     #$F7    ; 1111 0111
 1375  0F4D  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN LOW
 1376  0F50  20 BF 0F          JSR     DELAY2
 1377  0F53  09 08             ORA     #8              ; 0000 1000
 1378  0F55  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN HIGH
 1379  0F58  A2 20             LDX     #32     ; 40 MS
 1380  0F5A  20 B4 0F          JSR     DELAY
 1381  0F5D  F0 CB             BEQ     TZERO1  ; ALWAYS
 1382                  
 1383                  ; STEP TO PREVIOUS TRACK
 1384  0F5F            TPREV
 1385  0F5F  AD 02 C0          LDA     DDPIA+2 ; DIR=(TO TRK0)
 1386  0F62  09 04             ORA     #$04
 1387  0F64  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1388  0F67  20 BF 0F          JSR     DELAY2
 1389  0F6A  29 F7             AND     #$F7    ; 1111 0111
 1390  0F6C  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN LOW
 1391  0F6F  20 BF 0F          JSR     DELAY2
 1392  0F72  09 08             ORA     #8              ; 0000 1000
 1393  0F74  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN HIGH
 1394  0F77  C6 2E             DEC     TRK
 1395  0F79  20 A3 0F          JSR     REDWR   ; Set reduced write current
 1396  0F7C  A2 20             LDX     #32     ; 40 MS
 1397  0F7E  4C B4 0F          JMP     DELAY
 1398                  
 1399                  ; STEP TO NEXT TRACK
 1400                  
 1401  0F81            TNEXT   
 1402  0F81  AD 02 C0          LDA DDPIA+2
 1403  0F84  29 FB             AND     #$FB    ; 1111 1011
 1404                                                  ; DIR=INWARDS
 1405  0F86  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1406  0F89  20 BF 0F          JSR     DELAY2
 1407  0F8C  29 F7             AND     #$F7    ; 1111 0111
 1408  0F8E  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' LOW
 1409  0F91  20 BF 0F          JSR     DELAY2
 1410  0F94  09 08             ORA     #8              ; 0000 1000
 1411  0F96  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' HIGH
 1412  0F99  E6 2E             INC     TRK
 1413  0F9B  20 A3 0F          JSR     REDWR   ; Set reduced write current
 1414  0F9E  A2 20             LDX     #32         ; 40MS
 1415  0FA0  4C B4 0F          JMP     DELAY
 1416                  
 1417                          ; Set reduced write current
 1418  0FA3            REDWR
 1419  0FA3  A5 2E             LDA     TRK
 1420  0FA5  C9 2B             CMP     #43     ; Is track >= 43
 1421  0FA7  AD 02 C0          LDA     DDPIA+2
 1422  0FAA  29 BF             AND     #$BF    ; Set low current active
 1423  0FAC  B0 02             BCS     SETLO   ; Yes
 1424  0FAE  09 40             ORA     #$40    ; Set low current inactive
 1425  0FB0            SETLO
 1426  0FB0  8D 02 C0          STA     DDPIA+2
 1427  0FB3  60                RTS
 1428                  
 1429                  ; DELAY 1.25MS PER LOOP at 1 MHz clock. X,Y modified
 1430                  
 1431  0FB4            DELAY   
 1432  0FB4  A0 F8             LDY     #$F8
 1433  0FB6            DELAY1  
 1434  0FB6  88                DEY
 1435  0FB7  D0 FD             BNE     DELAY1
 1436  0FB9  55 FF             EOR     $FF,X
 1437  0FBB  CA                DEX
 1438  0FBC  D0 F6             BNE     DELAY
 1439  0FBE  60                RTS
 1440                  
 1441  0FBF            DELAY2  
 1442  0FBF  20 C2 0F          JSR     DELAY21
 1443  0FC2            DELAY21 
 1444  0FC2  60                RTS
 1445                  
 1446                  
 1447                  ; PRINT IN-LINE STRING. Y and A modified
 1448                  
 1449  0FC3            PRINT   
 1450  0FC3  68                PLA
 1451  0FC4  85 6A             STA     PTRSTOR
 1452  0FC6  68                PLA
 1453  0FC7  85 6B             STA     PTRSTOR+1
 1454  0FC9  A0 01             LDY     #1
 1455  0FCB            PRINT1  
 1456  0FCB  B1 6A             LDA     (PTRSTOR),Y
 1457  0FCD  F0 0A             BEQ     PRINT2
 1458  0FCF  20 3C 12          JSR     OUTPUT
 1459  0FD2  C8                INY
 1460  0FD3  D0 F6             BNE     PRINT1
 1461  0FD5  E6 6B             INC PTRSTOR+1
 1462  0FD7  D0 F2             BNE PRINT1
 1463  0FD9            PRINT2  
 1464  0FD9  98                TYA
 1465  0FDA  38                SEC
 1466  0FDB  65 6A             ADC     PTRSTOR
 1467  0FDD  A4 6A             LDY     PTRSTOR
 1468  0FDF  85 6A             STA     PTRSTOR
 1469  0FE1  90 02             BCC     PRINT3
 1470  0FE3  E6 6B             INC     PTRSTOR+1
 1471  0FE5            PRINT3
 1472  0FE5  18                CLC
 1473  0FE6  6C 6A 00          JMP     (PTRSTOR)
 1474                  
 1475                  ; PRINT HEX WORD (A,X). ONLY CHANGES A
 1476                  
 1477  0FE9            PHEX    
 1478  0FE9  20 ED 0F          JSR     PHEXA
 1479  0FEC  8A                TXA
 1480                  
 1481                  ; PRINT HEX BYTE (A)
 1482  0FED            PHEXA   
 1483  0FED  48                PHA
 1484  0FEE  4A                LSR     A
 1485  0FEF  4A                LSR     A
 1486  0FF0  4A                LSR     A
 1487  0FF1  4A                LSR     A
 1488  0FF2  20 F6 0F          JSR     PHEXA1
 1489  0FF5  68                PLA
 1490  0FF6            PHEXA1  
 1491  0FF6  29 0F             AND     #$F
 1492  0FF8  09 30             ORA     #'0'
 1493  0FFA  C9 3A             CMP     #'9'+1
 1494  0FFC  30 03             BMI     PHEXA2
 1495  0FFE  18                CLC
 1496  0FFF  69 07             ADC     #7
 1497  1001            PHEXA2  
 1498  1001  4C 3C 12          JMP     OUTPUT
 1499                  
 1500                  ; PRINT DECIMAL (A)
 1501  1004            PDECA   
 1502  1004  AA                TAX
 1503  1005  A9 00             LDA     #0
 1504                  
 1505                  ; PRINT DECIMAL (A,X). CHANGES A,X,Y. Prints with no leading space
 1506                  
 1507  1007            PDEC    
 1508  1007  86 43             STX num
 1509  1009  85 44             STA num+1
 1510  100B  A9 00             LDA #0
 1511  100D  85 59             STA pad
 1512  100F  A0 06             LDY #6  ; 4 digits max
 1513  1011  4C 5A 08          JMP PrDec16Lp1
 1514                  
 1515  1014            CRLF    
 1516  1014  A9 0D             LDA     #CR
 1517  1016  20 3C 12          JSR     OUTPUT
 1518  1019  A9 0A             LDA     #LF
 1519  101B  4C 3C 12          JMP     OUTPUT
 1520                  
 1521  101E            ANYKEY  
 1522  101E  20 F3 11          JSR     Get_Chr
 1523  1021  20 C3 0F          JSR     PRINT
 1524  1024  0D 0A             .BYTE   CR,LF
 1525  1026  50 52 45          .BYTE   'PRESS ANY KEY WHEN READY >',0
       1029  53 53 20  
       102C  41 4E 59  
       102F  20 4B 45  
       1032  59 20 57  
       1035  48 45 4E  
       1038  20 52 45  
       103B  41 44 59  
       103E  20 3E 00  
 1526  1041  20 0B 12          JSR     INKEY
 1527  1044  48                PHA
 1528  1045  20 C3 0F          JSR     PRINT
 1529  1048  0D 0A 00          .BYTE   CR,LF,0
 1530  104B  68                PLA
 1531  104C  60                RTS
 1532                  
 1533  104D            DRWMENU
 1534  104D  20 C3 0F           JSR PRINT
 1535  1050  0D 0A 0D          .BYTE $D,$A,$D,$A
       1053  0A        
 1536  1054  20 4F 53          .BYTE ' OSI DESTRUCTIVE Disk Test',$D,$A          
       1057  49 20 44  
       105A  45 53 54  
       105D  52 55 43  
       1060  54 49 56  
       1063  45 20 44  
       1066  69 73 6B  
       1069  20 54 65  
       106C  73 74 0D  
       106F  0A        
 1537  1070  2D 2D 2D          .BYTE '--------------------------',$D,$A          
       1073  2D 2D 2D  
       1076  2D 2D 2D  
       1079  2D 2D 2D  
       107C  2D 2D 2D  
       107F  2D 2D 2D  
       1082  2D 2D 2D  
       1085  2D 2D 2D  
       1088  2D 2D 0D  
       108B  0A        
 1538  108C  31 2E 20          .BYTE '1. Test Disk',$D,$A
       108F  54 65 73  
       1092  74 20 44  
       1095  69 73 6B  
       1098  0D 0A     
 1539  109A  32 2E 20          .BYTE '2. Test Track',$D,$A
       109D  54 65 73  
       10A0  74 20 54  
       10A3  72 61 63  
       10A6  6B 0D 0A  
 1540  10A9  33 2E 20          .BYTE '3. Select Drive',$D,$A      
       10AC  53 65 6C  
       10AF  65 63 74  
       10B2  20 44 72  
       10B5  69 76 65  
       10B8  0D 0A     
 1541  10BA  34 2E 20          .BYTE '4. Set Drive Type',$D,$A      
       10BD  53 65 74  
       10C0  20 44 72  
       10C3  69 76 65  
       10C6  20 54 79  
       10C9  70 65 0D  
       10CC  0A        
 1542  10CD  35 2E 20          .BYTE '5. Set Pattern and passes',$D,$A
       10D0  53 65 74  
       10D3  20 50 61  
       10D6  74 74 65  
       10D9  72 6E 20  
       10DC  61 6E 64  
       10DF  20 70 61  
       10E2  73 73 65  
       10E5  73 0D 0A  
 1543  10E8  36 2E 20          .BYTE '6. Toggle read only',$D,$A
       10EB  54 6F 67  
       10EE  67 6C 65  
       10F1  20 72 65  
       10F4  61 64 20  
       10F7  6F 6E 6C  
       10FA  79 0D 0A  
 1544  10FD  37 2E 20          .BYTE '7. RPM Test',$D,$A 
       1100  52 50 4D  
       1103  20 54 65  
       1106  73 74 0D  
       1109  0A        
 1545  110A  38 2E 20          .BYTE '8. Status screen',$D,$A 
       110D  53 74 61  
       1110  74 75 73  
       1113  20 73 63  
       1116  72 65 65  
       1119  6E 0D 0A  
 1546  111C  39 2E 20          .BYTE '9. Exit',$D,$A          
       111F  45 78 69  
       1122  74 0D 0A  
 1547  1125  0D 0A             .BYTE $D,$A
 1548  1127  44 72 76          .BYTE 'Drv=',$0
       112A  3D 00     
 1549  112C  A5 2D             LDA DRVNUM
 1550  112E  18                CLC
 1551  112F  69 41             ADC #$41
 1552  1131  20 3C 12          JSR OUTPUT
 1553  1134  A5 2B             LDA MAXPAG
 1554  1136  C9 0F             CMP #MAXPAG8
 1555  1138  F0 0C             BEQ DRWMN1
 1556  113A  20 C3 0F          JSR PRINT
 1557  113D  2F 35 2E          .BYTE '/5.25 ',0
       1140  32 35 20  
       1143  00        
 1558  1144  90 07             BCC DRWMN2
 1559  1146            DRWMN1
 1560  1146  20 C3 0F          JSR PRINT
 1561  1149  2F 38 20          .BYTE '/8 ',0
       114C  00        
 1562  114D            DRWMN2
 1563  114D  A5 32             LDA PATSEL
 1564  114F  D0 15             BNE DRWMN3
 1565  1151  20 C3 0F          JSR PRINT
 1566  1154  50 61 74          .BYTE 'Pattern $',0
       1157  74 65 72  
       115A  6E 20 24  
       115D  00        
 1567  115E  A5 33             LDA PATVAL
 1568  1160  20 ED 0F          JSR PHEXA
 1569  1163  4C 78 11          JMP DRWMN4
 1570  1166            DRWMN3
 1571  1166  20 C3 0F          JSR PRINT
 1572  1169  50 61 74          .BYTE 'Pattern random',0
       116C  74 65 72  
       116F  6E 20 72  
       1172  61 6E 64  
       1175  6F 6D 00  
 1573  1178            DRWMN4
 1574  1178  20 C3 0F          JSR PRINT
 1575  117B  20 20 50          .BYTE '  Passes ',0
       117E  61 73 73  
       1181  65 73 20  
       1184  00        
 1576  1185  A5 34             LDA PASSES
 1577  1187  20 04 10          JSR PDECA
 1578  118A  A5 68             LDA TESTTYPE
 1579  118C  F0 12             BEQ NORMTEST
 1580  118E  20 C3 0F          JSR PRINT
 1581  1191  20 53 63          .BYTE ' Scope test',0
       1194  6F 70 65  
       1197  20 74 65  
       119A  73 74 00  
 1582  119D  4C B0 11          JMP RWRO
 1583  11A0            NORMTEST
 1584  11A0  20 C3 0F          JSR PRINT
 1585  11A3  20 4E 6F          .BYTE ' Normal test',0
       11A6  72 6D 61  
       11A9  6C 20 74  
       11AC  65 73 74  
       11AF  00        
 1586  11B0            RWRO
 1587  11B0  A5 35             LDA READONLY
 1588  11B2  F0 11             BEQ RW
 1589  11B4  20 C3 0F          JSR PRINT
 1590  11B7  20 52 65          .BYTE ' Read only',0
       11BA  61 64 20  
       11BD  6F 6E 6C  
       11C0  79 00     
 1591  11C2  4C CD 11          JMP PPROMPT
 1592  11C5            RW
 1593  11C5  20 C3 0F          JSR PRINT
 1594  11C8  20 52 2F          .BYTE ' R/W',0
       11CB  57 00     
 1595  11CD            PPROMPT
 1596  11CD  20 C3 0F          JSR PRINT
 1597  11D0  20 3E 20          .BYTE ' > ',0
       11D3  00        
 1598  11D4  60                RTS
 1599                  
 1600                          ; Get key from polled key without waiting. Carry clear if no key
 1601                          ; Key returned in A. X,Y modified
 1602  11D5            Get_Chr_Polled
 1603  11D5  A9 02             LDA #2          ; Ignore shift lock
 1604  11D7  A0 00             LDY #0
 1605  11D9            Check_Polled_Loop
 1606  11D9  8D 00 DF          STA $DF00       ; Select row
 1607  11DC  8D 00 DF          STA $DF00       ; In case some time needed for signals to propagate
 1608  11DF  AE 00 DF          LDX $DF00
 1609  11E2  F0 01             BEQ Polled_No_Key       ; Jmp if no pressed?
 1610  11E4  C8                INY
 1611  11E5            Polled_No_Key
 1612  11E5  0A                ASL
 1613  11E6  D0 F1             BNE Check_Polled_Loop
 1614  11E8  C0 01             CPY #1          ; If we found other than 1 key pressed assume no
 1615                                          ; key pressed. May not have a keyboard port
 1616  11EA  F0 02             BEQ Polled_Got_Key
 1617  11EC  18                CLC
 1618  11ED  60                RTS
 1619  11EE            Polled_Got_Key
 1620  11EE  20 ED FE          JSR $FEED
 1621  11F1  38                SEC
 1622  11F2  60                RTS
 1623                          
 1624                  
 1625  11F3            Get_Chr
 1626  11F3            FRACIANW  ; read from ACIA no wait      carry clear when no data
 1627  11F3  24 30             BIT MACHINE
 1628  11F5  30 0A             BMI FRAC1NW
 1629  11F7  AD 00 FC          LDA C2ACIA
 1630  11FA  4A                LSR A
 1631  11FB  90 03             BCC FRAC1NW-1
 1632  11FD  AD 01 FC          LDA C2ACIA+1
 1633  1200  60                RTS
 1634  1201            FRAC1NW
 1635  1201  AD 00 F0          LDA C1ACIA
 1636  1204  4A                LSR A    
 1637  1205  90 F9             BCC FRAC1NW-1 
 1638  1207  AD 01 F0          LDA C1ACIA+1
 1639  120A  60                RTS
 1640                  
 1641                          ; Get key from serial or polled keyboard waiting for key.
 1642  120B            INKEY
 1643  120B  24 31             BIT VIDEO
 1644  120D  10 03             BPL *+5         ; No
 1645  120F  4C ED FE          JMP $FEED       ; Polled keyboard
 1646  1212  24 30             BIT MACHINE
 1647  1214            FRACIA           ;read from ACIA carry set on abort return value in A
 1648  1214  30 0B             BMI FRAC1
 1649  1216            FRSER                   ; read from C3
 1650  1216  AD 00 FC          LDA C2ACIA
 1651  1219  4A                LSR A    
 1652  121A  90 F8             BCC FRACIA 
 1653  121C  AD 01 FC          LDA C2ACIA+1
 1654  121F  18                CLC      
 1655  1220            ACIARET
 1656  1220  60                RTS
 1657  1221            FRAC1                   ;read from C1
 1658  1221  AD 00 F0          LDA C1ACIA
 1659  1224  4A                LSR A    
 1660  1225  90 ED             BCC FRACIA 
 1661  1227  AD 01 F0          LDA C1ACIA+1
 1662  122A  18                CLC       
 1663  122B  60                RTS
 1664                  
 1665                          ; Check if TX ready bit is set for serial. Carry set if ready
 1666  122C            CheckTXReady
 1667  122C  24 30             BIT MACHINE
 1668  122E  30 06             BMI TOAC1B
 1669  1230  AD 00 FC          LDA C2ACIA   ;wait for TxEmpty
 1670  1233  4A                LSR A     
 1671  1234  4A                LSR A     
 1672  1235  60                RTS     ; Carry set if TX ready
 1673  1236            TOAC1B
 1674  1236  AD 00 F0          LDA C1ACIA 
 1675  1239  4A                LSR A     
 1676  123A  4A                LSR A     
 1677  123B  60                RTS     ; Carry set if TX ready
 1678                  
 1679                          ; Write a character to serial or video. A modified
 1680  123C            OUTPUT
 1681  123C            Put_Chr
 1682  123C            TOACIA    
 1683  123C  24 31             BIT VIDEO
 1684  123E  10 03             BPL TOACIA2     ; No, not video system
 1685  1240  4C 60 12          JMP VIDOUT
 1686  1243            TOACIA2
 1687  1243  48                PHA
 1688  1244  24 30             BIT MACHINE
 1689  1246  30 0C             BMI TOAC1
 1690  1248            TOACIA1        
 1691  1248  AD 00 FC          LDA C2ACIA   ;wait for TxEmpty
 1692  124B  4A                LSR A     
 1693  124C  4A                LSR A     
 1694  124D  90 F9             BCC TOACIA1   
 1695  124F  68                PLA       
 1696  1250  8D 01 FC          STA C2ACIA+1 
 1697  1253  60                RTS       
 1698  1254            TOAC1
 1699  1254  AD 00 F0          LDA C1ACIA 
 1700  1257  4A                LSR A     
 1701  1258  4A                LSR A     
 1702  1259  90 F9             BCC TOAC1   
 1703  125B  68                PLA       
 1704  125C  8D 01 F0          STA C1ACIA+1 
 1705  125F  60                RTS 
 1706                  
 1707                          ; Video output routine
 1708  1260            VIDOUT
 1709  1260  84 67             STY YHOLD 
 1710  1262  C9 0D             CMP #CR
 1711  1264  F0 0F             BEQ VIDCR
 1712  1266  C9 0A             CMP #LF
 1713  1268  F0 10             BEQ VIDLF
 1714  126A  A4 74             LDY VIDOFFSET
 1715  126C  99 C0 D6          STA $D6C0,Y
 1716  126F  C8                INY
 1717  1270  84 74             STY VIDOFFSET
 1718  1272            VIDRETY
 1719  1272  A4 67             LDY YHOLD
 1720  1274  60                RTS
 1721  1275            VIDCR
 1722  1275  A9 00             LDA #0
 1723  1277  85 74             STA VIDOFFSET
 1724  1279  60                RTS     
 1725  127A            VIDLF
 1726  127A  B1 70             LDA (VIDSRC),Y
 1727  127C  91 72             STA (VIDDST),Y
 1728  127E  C8                INY
 1729  127F  D0 F9             BNE VIDLF
 1730  1281  E6 71             INC VIDSRC+1
 1731  1283  E6 73             INC VIDDST+1
 1732  1285  A5 71             LDA VIDSRC+1
 1733  1287  C9 D7             CMP #$D7
 1734  1289  D0 EF             BNE VIDLF
 1735  128B  A9 D0             LDA #$D0
 1736  128D  85 71             STA VIDSRC+1
 1737  128F  85 73             STA VIDDST+1
 1738  1291  A9 20             LDA #' '
 1739  1293            VIDCLR
 1740  1293  99 C0 D6          STA $D6C0,Y     ; Clear last line
 1741  1296  C8                INY
 1742  1297  C0 40             CPY #$40
 1743  1299  D0 F8             BNE VIDCLR
 1744  129B  C8                INY
 1745  129C  4C 72 12          JMP VIDRETY
 1746                          
 1747                          
 1748                  
 1749                  ; Return an 8 bit "random" number in A
 1750                  ; X modified on return
 1751                  ; From http://forum.6502.org/viewtopic.php?f=2&t=5247 modified for better
 1752                  ; randomness
 1753  129F            RAND
 1754  129F  A5 3B             LDA RND+4       ; ADD B shifted, 
 1755  12A1  38                SEC             ; carry adds value 0x80
 1756  12A2  6A                ROR
 1757  12A3  65 38             ADC RND+1       ; add last value (E)
 1758  12A5  65 3C             ADC RND+5       ; add C
 1759  12A7  85 37             STA RND         ; new number
 1760  12A9  A2 04             LDX #4          ; move 5 numbers
 1761  12AB            RPL
 1762  12AB  B5 37             LDA RND,X
 1763  12AD  95 38             STA RND+1,X     ; ..move over 1
 1764  12AF  CA                DEX
 1765  12B0  10 F9             BPL RPL         ; all moved?
 1766  12B2  A5 37             LDA RND
 1767  12B4  60                RTS
 1768                  
 1769                  ; From https://codebase64.org/doku.php?id=base:24bit_division_24-bit_result
 1770                  ; EXECUTES AN UNSIGNED INTEGER DIVISION OF A 24-BIT DIVIDEND BY A 24-BIT DIVISOR
 1771                  ; THE RESULT GOES TO DIVIDEND AND REMAINDER VARIABLES
 1772                  ;
 1773                  ; VERZ!!! 18-MAR-2017
 1774                  ; A, X, Y modified.
 1775                  
 1776  12B5  A9 00     DIV24   LDA #0          ;PRESET REMAINDER TO 0
 1777  12B7  85 49             STA REMAINDER
 1778  12B9  85 4A             STA REMAINDER+1
 1779  12BB  85 4B             STA REMAINDER+2
 1780  12BD  A2 18             LDX #24         ;REPEAT FOR EACH BIT: ...
 1781                  
 1782  12BF  06 43     DIVLOOP ASL DIVIDEND    ;DIVIDEND LB & HB*2, MSB -> CARRY
 1783  12C1  26 44             ROL DIVIDEND+1  
 1784  12C3  26 45             ROL DIVIDEND+2
 1785  12C5  26 49             ROL REMAINDER   ;REMAINDER LB & HB * 2 + MSB FROM CARRY
 1786  12C7  26 4A             ROL REMAINDER+1
 1787  12C9  26 4B             ROL REMAINDER+2
 1788  12CB  A5 49             LDA REMAINDER
 1789  12CD  38                SEC
 1790  12CE  E5 46             SBC DIVISOR     ;SUBSTRACT DIVISOR TO SEE IF IT FITS IN
 1791  12D0  A8                TAY             ;LB RESULT -> Y, FOR WE MAY NEED IT LATER
 1792  12D1  A5 4A             LDA REMAINDER+1
 1793  12D3  E5 47             SBC DIVISOR+1
 1794  12D5  85 4F             STA PZTEMP
 1795  12D7  A5 4B             LDA REMAINDER+2
 1796  12D9  E5 48             SBC DIVISOR+2
 1797  12DB  90 0A             BCC SKIP        ;IF CARRY=0 THEN DIVISOR DIDN'T FIT IN YET
 1798                  
 1799  12DD  85 4B             STA REMAINDER+2 ;ELSE SAVE SUBSTRACTION RESULT AS NEW REMAINDER,
 1800  12DF  A5 4F             LDA PZTEMP
 1801  12E1  85 4A             STA REMAINDER+1
 1802  12E3  84 49             STY REMAINDER   
 1803  12E5  E6 43             INC DIVIDEND    ;AND INCREMENT RESULT CAUSE DIVISOR FIT IN 1 TIMES
 1804                  
 1805  12E7  CA        SKIP    DEX
 1806  12E8  D0 D5             BNE DIVLOOP     
 1807  12EA  60                RTS
 1808                  
 1809                  
 1810                  ; From https://codebase64.org/doku.php?id=base:24bit_multiplication_24bit_product
 1811                  ; Multiply REMAINDER by DIVIDEND with result in DIVIDEND
 1812  0049            factor1 = REMAINDER
 1813  0043            product = DIVIDEND
 1814  12EB            MULT24
 1815  12EB  A9 00             lda #$00                        ; set product to zero
 1816  12ED  85 43             sta product
 1817  12EF  85 44             sta product+1
 1818  12F1  85 45             sta product+2
 1819                  
 1820  12F3            mloop
 1821  12F3  A5 4C             lda factor2                     ; while factor2 != 0
 1822  12F5  D0 09             bne nz
 1823  12F7  A5 4D             lda factor2+1
 1824  12F9  D0 05             bne nz
 1825  12FB  A5 4E             lda factor2+2
 1826  12FD  D0 01             bne nz
 1827  12FF  60                rts
 1828  1300            nz
 1829  1300  A5 4C             lda factor2                     ; if factor2 is odd
 1830  1302  29 01             and #$01
 1831  1304  F0 13             beq mskip
 1832                          
 1833  1306  A5 49             lda factor1                     ; product += factor1
 1834  1308  18                clc
 1835  1309  65 43             adc product
 1836  130B  85 43             sta product
 1837                          
 1838  130D  A5 4A             lda factor1+1
 1839  130F  65 44             adc product+1
 1840  1311  85 44             sta product+1
 1841                          
 1842  1313  A5 4B             lda factor1+2
 1843  1315  65 45             adc product+2
 1844  1317  85 45             sta product+2                   ; end if
 1845                  
 1846  1319            mskip
 1847  1319  06 49             asl factor1                     ; << factor1 
 1848  131B  26 4A             rol factor1+1
 1849  131D  26 4B             rol factor1+2
 1850  131F  46 4E             lsr factor2+2                   ; >> factor2
 1851  1321  66 4D             ror factor2+1
 1852  1323  66 4C             ror factor2
 1853                  
 1854  1325  4C F3 12          jmp mloop                       ; end while     
 1855                  
 1856                  ; Status screen for displaying drive inputs
 1857                  ;  Commands:
 1858                  ;  Z- Zero Head   U - Step Up  D - Step Down   E Exit
 1859                  ;  R - Read Trk(not implemented) H - load/unload head 
 1860                  ;  S - Select disk, W - Write
 1861                  ;
 1862  002F            LASTPIA = TMP ; need a storage location
 1863  1328            STATSCRN
 1864  1328  A9 AA             LDA #$AA
 1865  132A  85 2F             STA LASTPIA
 1866  132C  20 E0 0E          JSR INITPIA     ; Select disk
 1867  132F  20 00 0F          JSR SELDRV
 1868  1332  A9 20             LDA #$20        ; Turn master select back off
 1869  1334  4D 02 C0          EOR DDPIA+2
 1870  1337  8D 02 C0          STA DDPIA+2
 1871                          ; JSR PRINT
 1872                          ;.BYTE $1B,$48,$D,$A,0 ;escape codes to Home cursor no big deal if terminal doesn't respond correctl
 1873                  
 1874  133A  20 C3 0F          JSR PRINT
 1875  133D  0D 0A 0D          .BYTE $D,$A,$D,$A,'CMDS:(S)el (H)ead (W)rite Step:(U)p (D)own (Z)ero (E)xit',$D, $A
       1340  0A 43 4D  
       1343  44 53 3A  
       1346  28 53 29  
       1349  65 6C 20  
       134C  28 48 29  
       134F  65 61 64  
       1352  20 28 57  
       1355  29 72 69  
       1358  74 65 20  
       135B  53 74 65  
       135E  70 3A 28  
       1361  55 29 70  
       1364  20 28 44  
       1367  29 6F 77  
       136A  6E 20 28  
       136D  5A 29 65  
       1370  72 6F 20  
       1373  28 45 29  
       1376  78 69 74  
       1379  0D 0A     
 1876  137B  20 0D 0A          .BYTE ' ',$D, $A
 1877  137E  52 20 54          .BYTE 'R T F S R W S I',$D, $A
       1381  20 46 20  
       1384  53 20 52  
       1387  20 57 20  
       138A  53 20 49  
       138D  0D 0A     
 1878  138F  44 20 52          .BYTE 'D R A E D R e N',$D, $A
       1392  20 41 20  
       1395  45 20 44  
       1398  20 52 20  
       139B  65 20 4E  
       139E  0D 0A     
 1879  13A0  59 20 4B          .BYTE 'Y K U C Y I l D',$D, $A
       13A3  20 55 20  
       13A6  43 20 59  
       13A9  20 49 20  
       13AC  6C 20 44  
       13AF  0D 0A     
 1880  13B1  31 20 30          .BYTE '1 0 L T 2 T 1 E',$D, $A
       13B4  20 4C 20  
       13B7  54 20 32  
       13BA  20 54 20  
       13BD  31 20 45  
       13C0  0D 0A     
 1881  13C2  20 20 20          .BYTE '    T     P   X',$D, $A
       13C5  20 54 20  
       13C8  20 20 20  
       13CB  20 50 20  
       13CE  20 20 58  
       13D1  0D 0A     
 1882  13D3  00                .BYTE 0
 1883                          ;, $1B, $48,0
 1884                  
 1885  13D4            STATSCR2
 1886  13D4  AD 00 C0          LDA DDPIA
 1887  13D7            STATSCR5
 1888  13D7  85 2F             STA LASTPIA
 1889  13D9  A2 08             LDX #$08
 1890  13DB            STATSCR1
 1891  13DB  4A                LSR A
 1892  13DC  48                PHA
 1893  13DD  90 01             BCC *+3
 1894  13DF  A9 30             LDA #$30
 1895  13E1  2C A9 31          BIT $31A9
 1896  13E4  20 3C 12          JSR OUTPUT
 1897  13E7  A9 20             LDA #$20
 1898  13E9  20 3C 12          JSR OUTPUT
 1899  13EC  68                PLA
 1900  13ED  CA                DEX
 1901  13EE  D0 EB             BNE STATSCR1
 1902  13F0  20 C3 0F          JSR PRINT
 1903  13F3  20 54 52          .BYTE ' TRK ',0
       13F6  4B 20 00  
 1904  13F9  A5 2E             LDA TRK
 1905  13FB  20 3C 08          JSR PrDec2Dig
 1906  13FE  A9 0D             LDA #$0D
 1907  1400  20 3C 12          JSR OUTPUT  ;keep redrawing current line- no LF
 1908  1403            STATSCR4
 1909  1403  24 31             BIT VIDEO
 1910  1405  10 06             BPL STATSER     ; No
 1911  1407  20 D5 11          JSR Get_Chr_Polled
 1912  140A  4C 10 14          JMP *+6
 1913  140D            STATSER
 1914  140D  20 F3 11          JSR Get_Chr
 1915  1410  B0 0A             BCS STATSCR3
 1916  1412  AD 00 C0          LDA DDPIA
 1917  1415  C5 2F             CMP LASTPIA
 1918  1417  F0 EA             BEQ STATSCR4  ;no change, no update
 1919  1419  4C D7 13          JMP STATSCR5
 1920  141C            STATSCR3
 1921  141C  29 5F             AND #$5F
 1922                          ;CMP #'R     ; READ TRACK/Show Part
 1923                          ;BNE *+8
 1924                          ;JSR VIEWTRK
 1925                          ;JMP STATSCR2
 1926  141E  C9 53             CMP #'S
 1927  1420  D0 0B             BNE CHECKLOAD
 1928  1422  A9 20             LDA #$20
 1929  1424  4D 02 C0          EOR DDPIA+2
 1930  1427  8D 02 C0          STA DDPIA+2
 1931  142A  4C D4 13          JMP STATSCR2
 1932  142D            CHECKLOAD
 1933  142D  C9 48             CMP #'H
 1934  142F  D0 0B             BNE CHKWRITE
 1935  1431  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 1936  1434  49 80             EOR #$80        ; TOGGLE HEAD LOAD
 1937  1436  8D 02 C0          STA DDPIA+2     
 1938  1439  4C D4 13          JMP STATSCR2
 1939  143C            CHKWRITE
 1940  143C  C9 57             CMP #'W
 1941  143E  D0 15             BNE CHKEXIT
 1942  1440  2C 00 C0          BIT DDPIA       ; WAIT 
 1943  1443  30 FB             BMI *-3 ; INDEX PULSE
 1944  1445  2C 00 C0          BIT DDPIA       ; WAIT END OF
 1945  1448  10 FB             BPL *-3 ; INDEX PULSE
 1946  144A  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 1947  144D  49 03             EOR #$03        ; TOGGLE WRITE AND ERASE ENABLE
 1948  144F  8D 02 C0          STA DDPIA+2     
 1949  1452  4C D4 13          JMP STATSCR2
 1950  1455            CHKEXIT
 1951  1455  C9 45             CMP #'E
 1952  1457  D0 0B             BNE CHKUP
 1953  1459  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 1954  145C  09 A3             ORA #$A3        ; TURN OFF HEAD LOAD, SELECT, AND WRITE
 1955  145E  8D 02 C0          STA DDPIA+2     
 1956  1461  4C 98 03          JMP TOP
 1957  1464            CHKUP
 1958  1464  48                PHA
 1959  1465  A9 20             LDA #$20
 1960  1467  2C 02 C0          BIT DDPIA+2
 1961  146A  68                PLA
 1962  146B  F0 11             BEQ JSTATSCR2   ; Can't move head if drive not selected
 1963                  
 1964  146D  C9 55             CMP #'U
 1965  146F  D0 06             BNE *+8
 1966  1471  20 81 0F          JSR TNEXT       ; STEP TO NEXT TRACK
 1967  1474  4C D4 13          JMP STATSCR2
 1968  1477  C9 44             CMP #'D
 1969  1479  D0 06             BNE *+8
 1970  147B  20 5F 0F          JSR TPREV   ; STEP TO PREV TRACK
 1971  147E            JSTATSCR2
 1972  147E  4C D4 13          JMP STATSCR2
 1973  1481  C9 5A             CMP #'Z
 1974  1483  D0 03             BNE *+5
 1975  1485  20 1D 0F          JSR TZERO    ; STEP TO TRACK 0
 1976  1488  4C D4 13          JMP STATSCR2
 1977                           
 1978                  
 1979                  ;VIEWTRK ;placeholder for View Track function   
 1980                  ;       RTS     
 1981  148B            BUFFER  =       *
 1982  148B            *=*+BYTES8 ;space for track buffer
 1983  229B            BUFFER2 =       *
 1984                  ;space for track buffer. We may write more data than this but will not
 1985                  ;use the extra data written. Don't put anything that can't be overwritten
 1986                  ;after this
 1987  229B            *=*+[BYTES8+BYTES8+2] 
 1988                  
 1989                  ;*=*+[MAXPAG8*2*256] ;space for track buffer
 1990                  
 1991  3EBD            .END

Errors   = 0
Warnings = 0
