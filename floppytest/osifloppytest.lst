    1                  ;
    2                  ; DISK TEST UTILITY FOR C1P/UK101/C2PDF/C4PMF/C8P/C3-OEM
    3                  ; Supposed to work with serial or video and 8" or 5.25" floppies. Tested 
    4                  ; with C2 with 8" floppies, serial, and 540B video. Tested with OSI emulator
    5                  ; with 5.25" floppies.
    6                  ; Needs 16k memory.
    7                  ; Start at $300
    8                  ; Does write/read or read only test. Disk format is not compatible with
    9                  ; OSI operating systems. Can either print error information or generate
   10                  ; a pulse on fault reset to trigger scope on error. Can also show
   11                  ; drive status lines and allow manual control of drive control lines.
   12                  ; Will also measure drive RPM
   13                  ;
   14                  ; DESTRUCTIVE DISK READ/WRITE TEST
   15                  ; By David Gesswein djg@pdp8online.com
   16                  ; Initial release V1.00 05/04/2020
   17                  ; V1.02 05/28/2020. Fixes from Mark Spankus. Fixed W in status test hanging if
   18                  ;    drive not selected. Fixed C1 serial I/O code. Simplified code. Fixed
   19                  ;    polled keyboard code to work reliably on C1 and other machines. Fixed
   20                  ;    video to work with C1P though messages may not fit in 30 columns. Fixed
   21                  ;    video for SYNMON, SYN600, and CEGMON.
   22                  ; V1.01 05/16/2020. Fixed ANYKEY not aborting. Prevent specifying illegal
   23                  ;    track to test. Fixed printing false errors when no data read.
   24                  ;    Fixed issues with serial console getting selected on video system.
   25                  
   26                  ; All my changes are released as public domain. The original code did not have
   27                  ; any license specified.
   28                  ; For usage see http://www.pdp8online.com/osi/osi-floppy-test.shtml
   29                  
   30                  ;BASED ON https://osi.marks-lab.com/software/tools.html Universal OSIDump 
   31                  ;BASED ON ED'S OSIDUMP UTILITY
   32                  ;
   33                  ;
   34                  
   35  0300            ORG     =       $0300
   36                  
   37  0028            MAXTRK5 =       40      ; # TRACKS TO READ 5 1/4 disk
   38  000A            MAXPAG5 =       10      ; # PAGES TO READ  5 1/4 disk
   39  004D            MAXTRK8 =   77  ; # Tracks to read 8 disk
   40  000F            MAXPAG8 =   15  ; # Pages to read 8 disk
   41  0877            BYTES5  = 2167
   42  0E10            BYTES8  = 3600
   43                  
   44  C000            DDPIA   =   $C000   ; Disk controller PIA
   45  C010            DDACIA  =   $C010   ; Disk Controller Serial Port
   46  FC00            C2ACIA  =   $FC00   ; ACIA on C2/C4/C8/C3
   47  F000            C1ACIA  =   $F000   ; ACIA on C1
   48                  
   49                  ;Control Character Constants XMODEM etc.
   50  000D            CR              =       $0D
   51  000A            LF              =       $0A
   52  001B            ESC             =       $1B             ; ESC to exit
   53                  
   54                  
   55                  ;storage space (anywhere, so why not page zero?)
   56  0029            STORE   =   $29   ;storage C4P starts stack at 28
   57  002A            MAXTRK  =   STORE+01 ;1 - 40 for 5.25, 77 for 8, 255 for HD
   58  002B            MAXPAG  =   STORE+02 ;1 - 9 for 5.25, 15 for 8, 16 for HD
   59  002C            ACIACTL =   STORE+03 ;1 controls cassette/rs-232 ACIA divisor, format
   60  002D            DRVNUM  =   STORE+04 ;1 drive# 0-3
   61  002E            TRK     =   STORE+05 ;1 current track #
   62  002F            TMP     =   STORE+6  ;1
   63  0030            MACHINE =   STORE+7  ;1 C1/C2/C3 flag 00=C2/4/8, $40=C3Ser, $80=C1
   64  0031            INVKEYB =   STORE+8  ;C1 polled = FF C2 polled = 00
   65                  
   66  0032                            *= STORE+9
   67  0032  00        VIDEO           .BYTE 0 ; 0 = Serial $FF = video
   68  0033  00        PATSEL          .BYTE 0 ;  0 = Fixed byte (PATVAL), $FF = random
   69  0034  00        PATVAL          .BYTE 0 ;  Byte to write to disk
   70  0035  00        PASSES          .BYTE 0
   71  0036  00        READONLY        .BYTE 0 ; zero read write
   72  0037  00        PASSCNTR        .BYTE 0
   73  0038  5C 9F 89  RND             .BYTE 92, 159, 137, 36, 210, 89
       003B  24 D2 59  
   74  003E  00 00 00  RNDHLD          .BYTE 0,0,0,0,0,0
       0041  00 00 00  
   75  0044  00 00 00  DIVIDEND        .BYTE 0,0,0
   76  0047  00 00 00  DIVISOR         .BYTE 0,0,0
   77  004A  00 00 00  REMAINDER       .BYTE 0,0,0
   78  004D  00 00 00  factor2         .BYTE 0,0,0
   79  0050  00        PZTEMP          .BYTE 0
   80  0051  00 00 00  MAX             .BYTE 0,0,0
   81  0054  00 00 00  MIN             .BYTE 0,0,0
   82  0057  00 00 00  SUM             .BYTE 0,0,0
   83  005A  00        pad             .BYTE 0
   84  005B  00 00     ERRCNT          .WORD 0
   85  005D  00        PRTERR          .BYTE 0
   86                  ; 8" RPM scale 360 RPM * (250000 bps/10 bits/byte/6 RPS) = 1500000
   87  005E  60 E3 16  RPMSCALE8       .BYTE $60, $e3, $16 
   88                  ; 5.25" RPM scale 300 * (125000/10/5) = 750000
   89  0061  B0 71 0B  RPMSCALE5       .BYTE $b0, $71, $0b 
   90                  ; Allow 3% fast rotation and 1.25 delay after index high and 2.2 ms index
   91                  ; pulse;
   92  0064  00 00     MTRKBYTES       .WORD 0 ; negative number of bytes in track
   93  0066  00 00     BYTECNTR        .WORD 0
   94  0068  00        YHOLD           .BYTE 0
   95  0069  00        TESTTYPE        .BYTE 0 ; 0 normal 1 scope
   96                  
   97                  ;zero page storage
   98  006A  00        DRVACIA         .BYTE 0 ; Current serial word format for DISK ACIA 8E1/8N1
   99  006B  00 00     PTRSTOR         .WORD 0 
  100  006D  00 00     TDATA           .WORD 0
  101  006F  00 00     TDATA2          .WORD 0
  102  0071  40 D0     VIDSRC          .WORD $D040
  103  0073  00 D0     VIDDST          .WORD $D000
  104  0075  00        VIDOFFSET       .BYTE 0
  105  0076  00        VIDXLEN         .BYTE 0
  106  0077  00        VIDXMAX         .BYTE 0
  107  0078  00        MAXERR          .BYTE 0 ; number of errors + 1 to print
  108  0079  00        SINGLETRK       .BYTE 0; non zero if testing single track
  109                  
  110                          ; Serial monitor start values
  111  0129                    *= $129
  112  0129  00 00 00          .BYTE 0,0,0,0,$fd,ORG/256,ORG%256
       012C  00 FD 03  
       012F  00        
  113                  
  114  0300                    *=      ORG
  115  0300                    .EXE *        ;A65 emit OSI .lod start address operation
  116  0300  78                SEI
  117  0301  20 89 12          JSR     VIDINIT
  118  0304  AD 01 FE          LDA     $FE01     ;determine machine type
  119  0307  F0 10             BEQ     SERTYP    ;Is this serial system?                                                    
  120  0309  A9 00             LDA     #$00
  121  030B  AA                TAX
  122  030C  8D 00 DF          STA     $DF00   
  123  030F  2C 00 DF          BIT     $DF00     ;okay check C1/C2-C4
  124  0312  30 02             BMI     C1TYPE
  125  0314  E8                INX
  126  0316            C1TYPE=*+1
  127  0315  2C A9 80          BIT     $80A9
  128  0319            SERTYP=*+1
  129  0318  2C A9 40          BIT     $40A9
  130  031B  CA                DEX
  131  031C  85 30             STA     MACHINE   ;bit 7 = C1, bit 6 = C3, none =C2/C4
  132  031E  86 31             STX     INVKEYB
  133  0320  A9 15             LDA     #$15      ;B1 = 8N2 /16 RTStxIRQ  rxIRQ ;$15 = 8N1 /16 RTSNOtxIRQ NOrxIRQ; $B5 = irqs on 8N1
  134  0322  85 2C             STA     ACIACTL
  135                          ; Not sure how to figure out if we should use serial or video.
  136                          ; First try to determine if a serial port exists. If it does we
  137                          ; print a message to both serial and video and see which the user
  138                          ; hits a key on to select between video and serial
  139  0324  A2 0A             LDX     #10     ; 10*1.25MS wait for last character to be output
  140  0326  20 BD 0F          JSR     DELAY
  141  0329  A2 00             LDX     #0
  142  032B  20 55 12          JSR     CheckTXReady    ; If serial not ready likely no serial port
  143  032E  B0 01             BCS     SELLP           
  144  0330  CA                DEX                     ; so don't write to serial.
  145  0331            SELLP
  146  0331  20 1C 12          JSR     Get_Chr         ; Flush serial data if any
  147  0334  86 32             STX     VIDEO           ; Select serial first then video
  148  0336  20 CC 0F          JSR     PRINT
  149  0339  0D 0A 48          .BYTE   CR,LF,'HIT ANY KEY TO SELECT CONSOLE DEVICE',CR,LF,0
       033C  49 54 20  
       033F  41 4E 59  
       0342  20 4B 45  
       0345  59 20 54  
       0348  4F 20 53  
       034B  45 4C 45  
       034E  43 54 20  
       0351  43 4F 4E  
       0354  53 4F 4C  
       0357  45 20 44  
       035A  45 56 49  
       035D  43 45 0D  
       0360  0A 00     
  150  0362  20 1C 12          JSR     Get_Chr         ; Flush serial data if any
  151  0365  CA                DEX
  152  0366  E0 FE             CPX     #$FE            ; If we did both then we are done
  153  0368  D0 C7             BNE     SELLP
  154  036A            SELLP2
  155  036A  20 1C 12          JSR     Get_Chr         ; Get serial character if one ready
  156  036D  B0 0C             BCS     SERCON          ; Got one, select serial
  157  036F  20 EF 11          JSR     Check_Keypress  ; Check polled keyboard for key down
  158  0372  90 F6             BCC     SELLP2          ; Didn't find it
  159  0374  A2 FF             LDX     #$FF
  160  0376  A0 04             LDY     #4              ; Set video console and # of errors to print
  161  0378  4C 7F 03          JMP     STORECON
  162  037B            SERCON
  163  037B  A2 00             LDX     #0
  164  037D  A0 06             LDY     #6              ; Set serial console and # of errors to print
  165  037F            STORECON
  166  037F  86 32             STX     VIDEO
  167  0381  84 78             STY     MAXERR
  168                  
  169  0383  A9 00             LDA     #$00    ; Reset various variables
  170  0385  85 2D             STA     DRVNUM
  171  0387  85 33             STA     PATSEL
  172  0389  85 69             STA     TESTTYPE
  173  038B  85 36             STA     READONLY
  174  038D  85 2E             STA     TRK     ; We don't know the track so set to zero
  175                  
  176  038F  A9 01             LDA     #$01
  177  0391  85 35             STA     PASSES
  178  0393  A9 18             LDA     #$18
  179  0395  85 34             STA     PATVAL
  180  0397  24 30             BIT     MACHINE
  181  0399  50 03             BVC     *+5
  182  039B  4C 5B 04          JMP     SETDRV8  ;serial systems use 8" by default
  183  039E  4C 48 04          JMP     SETDRV5
  184                  
  185  03A1            TOP
  186  03A1  20 56 10          JSR     DRWMENU ; Print menu
  187  03A4  20 1C 12          JSR     Get_Chr         ; Flush serial data if any
  188  03A7  A2 00             LDX     #$00
  189  03A9  20 34 12          JSR     INKEY   ; Key user input
  190  03AC  20 65 12          JSR     OUTPUT
  191  03AF  C9 31             CMP     #$31    ; See if its a menu choice and do it
  192  03B1  D0 03             BNE     *+5
  193  03B3  4C AB 08          JMP     TEST
  194  03B6  C9 32             CMP     #$32
  195  03B8  D0 03             BNE     *+5
  196  03BA  4C 6E 04          JMP     TESTTRK
  197  03BD  C9 33             CMP     #$33
  198  03BF  D0 03             BNE     *+5
  199  03C1  4C D1 05          JMP     SETDRV
  200  03C4  C9 34             CMP     #$34
  201  03C6  D0 03             BNE     *+5
  202  03C8  4C F7 03          JMP     DRVTYPE
  203  03CB  C9 35             CMP     #$35
  204  03CD  D0 03             BNE     *+5
  205  03CF  4C C5 04          JMP     SETPAT
  206  03D2  C9 36             CMP     #$36
  207  03D4  D0 09             BNE     CHECKNEXT
  208  03D6  A9 FF             LDA     #$FF
  209  03D8  45 36             EOR     READONLY
  210  03DA  85 36             STA     READONLY
  211  03DC  4C A1 03          JMP     TOP
  212  03DF            CHECKNEXT
  213  03DF  C9 37             CMP     #$37
  214  03E1  D0 03             BNE     *+5
  215  03E3  4C 17 06          JMP     RPMTEST
  216  03E6  C9 38             CMP     #$38
  217  03E8  D0 03             BNE     *+5
  218  03EA  4C D6 13          JMP     STATSCRN
  219  03ED  C9 39             CMP     #$39
  220  03EF  D0 03             BNE     *+5
  221  03F1  6C FC FF          JMP     ($FFFC) ;Exit
  222  03F4  4C 40 04          JMP     INPERR
  223                  
  224  03F7            DRVTYPE
  225  03F7  20 CC 0F          JSR     PRINT
  226  03FA  0D 0A 45          .BYTE $D,$A,'Enter your disk drive type (8) inch or (5).25 inch? >',0
       03FD  6E 74 65  
       0400  72 20 79  
       0403  6F 75 72  
       0406  20 64 69  
       0409  73 6B 20  
       040C  64 72 69  
       040F  76 65 20  
       0412  74 79 70  
       0415  65 20 28  
       0418  38 29 20  
       041B  69 6E 63  
       041E  68 20 6F  
       0421  72 20 28  
       0424  35 29 2E  
       0427  32 35 20  
       042A  69 6E 63  
       042D  68 3F 20  
       0430  3E 00     
  227  0432  20 34 12          JSR     INKEY
  228  0435  20 65 12          JSR     OUTPUT
  229  0438  C9 38             CMP     #$38
  230  043A  F0 1F             BEQ     SETDRV8
  231  043C  C9 35             CMP     #$35
  232  043E  F0 08             BEQ     SETDRV5
  233  0440            INPERR
  234  0440  A9 3F             LDA     #'?     ; Print bad choice and menu again
  235  0442  20 65 12          JSR     OUTPUT
  236  0445  4C A1 03          JMP     TOP
  237                  
  238  0448            SETDRV5
  239  0448  A9 28             LDA     #MAXTRK5
  240  044A  85 2A             STA     MAXTRK
  241  044C  A9 0A             LDA     #MAXPAG5
  242  044E  85 2B             STA     MAXPAG
  243  0450  A9 89             LDA     #-BYTES5%256
  244  0452  85 64             STA     MTRKBYTES
  245  0454  A9 F7             LDA     #-BYTES5/256
  246  0456  85 65             STA     MTRKBYTES+1
  247  0458  4C A1 03          JMP     TOP
  248                  
  249  045B            SETDRV8
  250  045B  A9 4D             LDA     #MAXTRK8
  251  045D  85 2A             STA     MAXTRK
  252  045F  A9 0F             LDA     #MAXPAG8
  253  0461  85 2B             STA     MAXPAG
  254  0463  A9 F0             LDA     #-BYTES8%256
  255  0465  85 64             STA     MTRKBYTES
  256  0467  A9 F1             LDA     #-BYTES8/256
  257  0469  85 65             STA     MTRKBYTES+1
  258  046B  4C A1 03          JMP     TOP
  259                  
  260                  
  261  046E            TESTTRK
  262  046E  20 CC 0F          JSR PRINT
  263  0471  0D 0A 45          .BYTE $D,$A,'Enter 2 digit decimal track to test > ',0
       0474  6E 74 65  
       0477  72 20 32  
       047A  20 64 69  
       047D  67 69 74  
       0480  20 64 65  
       0483  63 69 6D  
       0486  61 6C 20  
       0489  74 72 61  
       048C  63 6B 20  
       048F  74 6F 20  
       0492  74 65 73  
       0495  74 20 3E  
       0498  20 00     
  264  049A  20 AB 05          JSR GETDEC2
  265  049D  90 CF             BCC TESTTRK
  266  049F  85 68             STA YHOLD
  267  04A1  C5 2A             CMP MAXTRK      ; Don't allow more than MAXTRK
  268  04A3  10 C9             BPL TESTTRK
  269  04A5  20 E9 0E          JSR INITPIA
  270  04A8  20 09 0F          JSR SELDRV
  271  04AB  20 26 0F          JSR TZERO       ; STEP TO TRACK 0
  272  04AE  90 03             BCC *+5
  273  04B0  4C B2 0E          JMP NOTRK
  274  04B3  A5 68             LDA YHOLD
  275  04B5  F0 07             BEQ TESTSTART
  276  04B7            TESTTN
  277  04B7  20 8A 0F          JSR TNEXT       ; Step to desired track
  278  04BA  C6 68             DEC YHOLD
  279  04BC  D0 F9             BNE TESTTN
  280  04BE            TESTSTART
  281  04BE  A9 01             LDA #1          ; And set flag to only test the one track
  282  04C0  85 79             STA SINGLETRK
  283  04C2  4C AF 08          JMP TEST2
  284                  
  285  04C5            SETPAT
  286  04C5  A9 00             LDA #0
  287  04C7  85 33             STA PATSEL
  288  04C9  20 CC 0F          JSR PRINT
  289  04CC  0D 0A 45          .BYTE $D,$A,'Enter hex fill pattern or space for random > ',0
       04CF  6E 74 65  
       04D2  72 20 68  
       04D5  65 78 20  
       04D8  66 69 6C  
       04DB  6C 20 70  
       04DE  61 74 74  
       04E1  65 72 6E  
       04E4  20 6F 72  
       04E7  20 73 70  
       04EA  61 63 65  
       04ED  20 66 6F  
       04F0  72 20 72  
       04F3  61 6E 64  
       04F6  6F 6D 20  
       04F9  3E 20 00  
  290  04FC  20 34 12          JSR INKEY
  291  04FF  20 65 12          JSR OUTPUT
  292  0502  29 7F             AND #$7F
  293  0504  C9 20             CMP #' '
  294  0506  F0 7D             BEQ PATRND
  295  0508  20 8A 05          JSR CONVHDIG
  296  050B  90 B8             BCC SETPAT
  297  050D  0A                ASL     ; Shift to high nibble
  298  050E  0A                ASL
  299  050F  0A                ASL
  300  0510  0A                ASL
  301  0511  AA                TAX
  302  0512  20 34 12          JSR INKEY       ; Get and combine with low nibble
  303  0515  20 65 12          JSR OUTPUT
  304  0518  20 8A 05          JSR CONVHDIG
  305  051B  90 A8             BCC SETPAT
  306  051D  85 2F             STA TMP
  307  051F  8A                TXA
  308  0520  05 2F             ORA TMP
  309  0522  85 34             STA PATVAL
  310  0524            GETPASSES
  311  0524  20 CC 0F          JSR PRINT
  312  0527  0D 0A 45          .BYTE $D,$A,'Enter two digit passes > ',0
       052A  6E 74 65  
       052D  72 20 74  
       0530  77 6F 20  
       0533  64 69 67  
       0536  69 74 20  
       0539  70 61 73  
       053C  73 65 73  
       053F  20 3E 20  
       0542  00        
  313  0543  20 AB 05          JSR GETDEC2
  314  0546  90 DC             BCC GETPASSES
  315  0548  85 35             STA PASSES
  316                  
  317  054A            GETTYPE
  318  054A  20 CC 0F          JSR PRINT
  319  054D  0D 0A 28          .BYTE $D,$A,'(S)cope test or (N)ormal > ',0
       0550  53 29 63  
       0553  6F 70 65  
       0556  20 74 65  
       0559  73 74 20  
       055C  6F 72 20  
       055F  28 4E 29  
       0562  6F 72 6D  
       0565  61 6C 20  
       0568  3E 20 00  
  320  056B  20 34 12          JSR INKEY
  321  056E  20 65 12          JSR OUTPUT
  322  0571  29 7F             AND #$7F
  323  0573  09 20             ORA #$20
  324  0575  A2 00             LDX #0
  325  0577  C9 6E             CMP #'n'
  326  0579  F0 05             BEQ SETTYPE
  327  057B  E8                INX
  328  057C  C9 73             CMP #'s'
  329  057E  D0 CA             BNE GETTYPE
  330  0580            SETTYPE
  331  0580  86 69             STX TESTTYPE
  332  0582  4C A1 03          JMP TOP
  333  0585            PATRND
  334  0585  C6 33             DEC PATSEL
  335  0587  4C 24 05          JMP GETPASSES
  336                  
  337  058A            CONVHDIG
  338  058A  20 9A 05          JSR CONVDIG
  339  058D  B0 0A             BCS CONVHRET
  340  058F  C9 61             CMP #'a'
  341  0591  30 16             BMI CONVERR
  342  0593  C9 67             CMP #'f'+1
  343  0595  10 12             BPL CONVERR
  344  0597  E9 56             SBC #'a'-1-10
  345  0599            CONVHRET
  346  0599  60                RTS
  347  059A            CONVDIG
  348  059A  29 7F             AND #$7F
  349  059C  09 20             ORA #$20
  350  059E  C9 30             CMP #'0'
  351  05A0  30 07             BMI CONVERR
  352  05A2  C9 3A             CMP #'9'+1
  353  05A4  10 03             BPL CONVERR
  354  05A6  E9 2F             SBC #'0'-1
  355  05A8  60                RTS
  356  05A9            CONVERR
  357  05A9  18                CLC
  358  05AA  60                RTS
  359                  
  360                  ; Return 2 digit decimal number in A. Carry clear if number valid
  361  05AB            GETDEC2
  362  05AB  20 34 12          JSR INKEY
  363  05AE  20 65 12          JSR OUTPUT
  364  05B1  20 9A 05          JSR CONVDIG
  365  05B4  90 1A             BCC GETDEC2RET
  366  05B6  85 2F             STA TMP
  367  05B8  0A                ASL             ; Multiply by 8
  368  05B9  0A                ASL
  369  05BA  0A                ASL
  370  05BB  65 2F             ADC TMP         ; And add twice to make multiply by 10
  371  05BD  65 2F             ADC TMP
  372  05BF  85 2F             STA TMP
  373  05C1  20 34 12          JSR INKEY       ; Get and add low digit
  374  05C4  20 65 12          JSR OUTPUT
  375  05C7  20 9A 05          JSR CONVDIG
  376  05CA  90 04             BCC GETDEC2RET
  377  05CC  18                CLC
  378  05CD  65 2F             ADC TMP
  379  05CF  38                SEC
  380  05D0            GETDEC2RET              ; Not valid number, return carry clear
  381  05D0  60                RTS
  382                  
  383  05D1            SETDRV
  384  05D1  20 CC 0F          JSR PRINT
  385  05D4  0D 0A 53          .BYTE $D,$A,'Select drive (A), (B), (C), (D) ? >',0
       05D7  65 6C 65  
       05DA  63 74 20  
       05DD  64 72 69  
       05E0  76 65 20  
       05E3  28 41 29  
       05E6  2C 20 28  
       05E9  42 29 2C  
       05EC  20 28 43  
       05EF  29 2C 20  
       05F2  28 44 29  
       05F5  20 3F 20  
       05F8  3E 00     
  386  05FA  20 34 12          JSR INKEY
  387  05FD  20 65 12          JSR OUTPUT
  388  0600  29 5F             AND #$5F
  389  0602  C9 41             CMP #'A
  390  0604  90 0B             BCC SETERR
  391  0606  C9 45             CMP #'E
  392  0608  B0 07             BCS SETERR
  393  060A  E9 40             SBC #'@         ;carry is clear so val -1
  394  060C  85 2D             STA DRVNUM
  395  060E  4C A1 03          JMP TOP
  396  0611            SETERR
  397  0611  4C 40 04          JMP INPERR
  398                  
  399  0614            NOTRK2
  400  0614  4C B2 0E          JMP NOTRK
  401                          ; Test drive RPM with head unloaded and loaded
  402                          ; We count number of bytes sent through disk serial port between
  403                          ; index pulses to measure RPM. That is independent of CPU speed.
  404                          ; We use 8N1 for 10 total bits.
  405                          ; 8" = 25,000 characters per second and 5.25" 12,500.
  406                          ; 16 measurements are done with minimum, maximum, and avarage
  407                          ; printed
  408  0617            RPMTEST
  409  0617  20 E9 0E          JSR INITPIA
  410  061A  20 09 0F          JSR SELDRV
  411  061D  20 26 0F          JSR TZERO       ; STEP TO TRACK 0
  412  0620  B0 F2             BCS NOTRK2
  413  0622  A9 03             LDA #3
  414  0624  8D 10 C0          STA DDACIA      ; RESET ACIA
  415  0627  A9 54             LDA #$54    ;0 10 101 00 ;$54-  recv irq, RTS HIGH no xmit irq,  8N1,  DIVIDE BY 1,
  416  0629  85 6A             STA DRVACIA     
  417  062B  8D 10 C0          STA DDACIA      ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  418  062E  20 CC 0F          JSR PRINT
  419  0631  0D 0A 48          .BYTE $D,$A,'Head unloaded ',0
       0634  65 61 64  
       0637  20 75 6E  
       063A  6C 6F 61  
       063D  64 65 64  
       0640  20 00     
  420  0642  20 B2 06          JSR RPMTST2
  421  0645  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
  422  0648  29 7F             AND #$7F        ; 0111 1111
  423  064A  8D 02 C0          STA DDPIA+2     ; LOAD DISK HEAD
  424  064D  A2 FF             LDX #$FF        ; 320MS
  425  064F  20 BD 0F          JSR DELAY
  426  0652  20 CC 0F          JSR PRINT
  427  0655  0D 0A 48          .BYTE $D,$A,'Head loaded   ',0
       0658  65 61 64  
       065B  20 6C 6F  
       065E  61 64 65  
       0661  64 20 20  
       0664  20 00     
  428  0666  20 B2 06          JSR RPMTST2
  429  0669            RPMUNLOAD
  430  0669  AD 02 C0          LDA DDPIA+2
  431  066C  09 80             ORA #$80        
  432  066E  8D 02 C0          STA DDPIA+2     ; UNLOAD DISK HEAD
  433  0671  4C A1 03          JMP TOP
  434  0674            INDEXACT
  435  0674  20 CC 0F          JSR PRINT
  436  0677  49 6E 64          .BYTE 'Index stuck active',CR,LF,0
       067A  65 78 20  
       067D  73 74 75  
       0680  63 6B 20  
       0683  61 63 74  
       0686  69 76 65  
       0689  0D 0A 00  
  437  068C  20 27 10          JSR ANYKEY
  438  068F  4C 69 06          JMP RPMUNLOAD
  439  0692            INDEXINACT
  440  0692  20 CC 0F          JSR PRINT
  441  0695  49 6E 64          .BYTE 'Index stuck inactive',CR,LF,0
       0698  65 78 20  
       069B  73 74 75  
       069E  63 6B 20  
       06A1  69 6E 61  
       06A4  63 74 69  
       06A7  76 65 0D  
       06AA  0A 00     
  442  06AC  20 27 10          JSR ANYKEY
  443  06AF  4C 69 06          JMP RPMUNLOAD
  444  06B2            RPMTST2
  445  06B2  A2 00             LDX #0
  446  06B4  A0 00             LDY #0
  447  06B6            RPMTSTLP
  448  06B6  E8                INX
  449  06B7  D0 01             BNE *+3
  450  06B9  C8                INY
  451  06BA  F0 B8             BEQ INDEXACT
  452  06BC  2C 00 C0          BIT DDPIA       ; WAIT END OF
  453  06BF  10 F5             BPL RPMTSTLP    ; INDEX PULSE
  454  06C1  A9 00             LDA #0
  455  06C3  85 47             STA DIVISOR     ; Clear variables
  456  06C5  85 48             STA DIVISOR+1
  457  06C7  85 49             STA DIVISOR+2
  458  06C9  85 51             STA MAX
  459  06CB  85 52             STA MAX+1
  460  06CD  85 53             STA MAX+2
  461  06CF  85 57             STA SUM
  462  06D1  85 58             STA SUM+1
  463  06D3  85 59             STA SUM+2
  464  06D5  A9 FF             LDA #255
  465  06D7  85 54             STA MIN
  466  06D9  85 55             STA MIN+1
  467  06DB  85 56             STA MIN+2
  468  06DD  A2 10             LDX #16         ; Measure RPM 16 times
  469  06DF  A0 00             LDY #0
  470  06E1  A9 00             LDA #0
  471  06E3  18                CLC
  472  06E4            RPMLP1
  473                          ; Wait for index then write first byte to UART since it
  474                          ; should be ready. Then write a second byte since it should either
  475                          ; be ready immediatly or very shortly after first byte is transferred
  476                          ; to TX shift register. Then start counting with the writes that
  477                          ; will happen at the UART data rate.
  478  06E4  C8                INY
  479  06E5  D0 02             BNE *+4
  480  06E7  69 01             ADC #1
  481  06E9  F0 A7             BEQ INDEXINACT  ; If we wait to long for index inactive print error
  482  06EB  2C 00 C0          BIT DDPIA       ; WAIT for INDEX PULSE
  483  06EE  30 F4             BMI RPMLP1
  484  06F0  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  485  06F3            RPMNDX0
  486  06F3  A9 02             LDA #2
  487  06F5  2D 10 C0          AND DDACIA      ;test tx ready? 
  488  06F8  F0 F9             BEQ RPMNDX0     ;not ready?
  489  06FA  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  490  06FD            RPMNDX1
  491  06FD  A9 02             LDA #2
  492  06FF  2D 10 C0          AND DDACIA      ;test tx ready? 
  493  0702  F0 F9             BEQ RPMNDX1     ;not ready?
  494  0704  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  495  0707  E6 47             INC DIVISOR
  496  0709  D0 02             BNE *+4
  497  070B  E6 48             INC DIVISOR+1
  498  070D  D0 02             BNE *+4
  499  070F  E6 49             INC DIVISOR+2
  500  0711  2C 00 C0          BIT DDPIA       ; WAIT END OF
  501  0714  10 E7             BPL RPMNDX1     ; INDEX PULSE
  502  0716            RPMNDX2
  503  0716  2C 00 C0          BIT DDPIA       ; DONE IF 
  504  0719  10 17             BPL RPMNDX3     ; INDEX PULSE
  505  071B  A9 02             LDA #2
  506  071D  2D 10 C0          AND DDACIA      ;test tx ready? 
  507  0720  F0 F4             BEQ RPMNDX2     ;not ready?
  508  0722  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  509  0725  E6 47             INC DIVISOR     ; Count character sent
  510  0727  D0 02             BNE *+4
  511  0729  E6 48             INC DIVISOR+1
  512  072B  D0 02             BNE *+4
  513  072D  E6 49             INC DIVISOR+2
  514  072F  4C 16 07          JMP RPMNDX2
  515  0732            RPMNDX3
  516  0732  2C 00 C0          BIT DDPIA       ; WAIT END OF
  517  0735  10 FB             BPL RPMNDX3     ; INDEX PULSE
  518  0737  18                CLC
  519  0738  A5 57             LDA SUM         ; Sum of all rotation time
  520  073A  65 47             ADC DIVISOR
  521  073C  85 57             STA SUM
  522  073E  A5 58             LDA SUM+1
  523  0740  65 48             ADC DIVISOR+1
  524  0742  85 58             STA SUM+1
  525  0744  A5 59             LDA SUM+2
  526  0746  65 49             ADC DIVISOR+2
  527  0748  85 59             STA SUM+2
  528                  
  529  074A  A5 49             LDA DIVISOR+2
  530  074C  C5 56             CMP MIN+2
  531  074E  90 35             BCC LESS1
  532  0750  D0 0E             BNE GE1
  533  0752  A5 48             LDA DIVISOR+1
  534  0754  C5 55             CMP MIN+1
  535  0756  90 2D             BCC LESS1
  536  0758  D0 06             BNE GE1
  537  075A  A5 47             LDA DIVISOR
  538  075C  C5 54             CMP MIN
  539  075E  90 25             BCC LESS1
  540  0760            GE1     ; DIVISOR >= MIN
  541  0760  A5 49             LDA DIVISOR+2
  542  0762  C5 53             CMP MAX+2
  543  0764  90 2E             BCC LESS2
  544  0766  D0 0E             BNE GE2
  545  0768  A5 48             LDA DIVISOR+1
  546  076A  C5 52             CMP MAX+1
  547  076C  90 26             BCC LESS2
  548  076E  D0 06             BNE GE2
  549  0770  A5 47             LDA DIVISOR
  550  0772  C5 51             CMP MAX
  551  0774  90 1E             BCC LESS2
  552  0776            GE2     ; DIVISOR >= MAX
  553  0776  A5 47             LDA DIVISOR
  554  0778  85 51             STA MAX
  555  077A  A5 48             LDA DIVISOR+1
  556  077C  85 52             STA MAX+1
  557  077E  A5 49             LDA DIVISOR+2
  558  0780  85 53             STA MAX+2
  559  0782  4C 94 07          JMP LESS2
  560                  
  561  0785            LESS1   ; DIVISOR < MIN
  562  0785  A5 47             LDA DIVISOR
  563  0787  85 54             STA MIN
  564  0789  A5 48             LDA DIVISOR+1
  565  078B  85 55             STA MIN+1
  566  078D  A5 49             LDA DIVISOR+2
  567  078F  85 56             STA MIN+2
  568  0791  4C 60 07          JMP GE1
  569                          
  570  0794            LESS2   ; DIVISOR < MAX
  571  0794  CA                DEX
  572  0795  F0 0B             BEQ RPMDONE
  573  0797  A9 00             LDA #0
  574  0799  85 47             STA DIVISOR
  575  079B  85 48             STA DIVISOR+1
  576  079D  85 49             STA DIVISOR+2
  577  079F  4C E4 06          JMP RPMLP1
  578                  
  579  07A2            RPMDONE
  580  07A2  20 CC 0F          JSR PRINT
  581  07A5  52 50 4D          .BYTE 'RPM: AVG ',0
       07A8  3A 20 41  
       07AB  56 47 20  
       07AE  00        
  582  07AF  A2 04             LDX #4          ; Divide by 16 to convert sum to average
  583  07B1            RPMDIVL
  584  07B1  18                CLC
  585  07B2  66 59             ROR SUM+2
  586  07B4  66 58             ROR SUM+1
  587  07B6  66 57             ROR SUM
  588  07B8  CA                DEX
  589  07B9  D0 F6             BNE RPMDIVL
  590  07BB  A5 57             LDA SUM
  591  07BD  85 47             STA DIVISOR
  592  07BF  A5 58             LDA SUM+1
  593  07C1  85 48             STA DIVISOR+1
  594  07C3  A5 59             LDA SUM+2
  595  07C5  85 49             STA DIVISOR+2
  596  07C7  20 FB 07          JSR RPMPRT
  597                  
  598  07CA  20 CC 0F          JSR PRINT
  599  07CD  20 20 4D          .BYTE '  MIN',0
       07D0  49 4E 00  
  600                  
  601  07D3  A5 51             LDA MAX
  602  07D5  85 47             STA DIVISOR
  603  07D7  A5 52             LDA MAX+1
  604  07D9  85 48             STA DIVISOR+1
  605  07DB  A5 53             LDA MAX+2
  606  07DD  85 49             STA DIVISOR+2
  607  07DF  20 FB 07          JSR RPMPRT
  608                  
  609  07E2  20 CC 0F          JSR PRINT
  610  07E5  20 20 4D          .BYTE '  MAX',0
       07E8  41 58 00  
  611                  
  612  07EB  A5 54             LDA MIN
  613  07ED  85 47             STA DIVISOR
  614  07EF  A5 55             LDA MIN+1
  615  07F1  85 48             STA DIVISOR+1
  616  07F3  A5 56             LDA MIN+2
  617  07F5  85 49             STA DIVISOR+2
  618  07F7  20 FB 07          JSR RPMPRT
  619  07FA  60                RTS
  620                  
  621                          ; Convert count to RPM with two decimal places
  622  07FB            RPMPRT
  623  07FB  A5 2B             LDA MAXPAG
  624  07FD  C9 0F             CMP #MAXPAG8
  625  07FF  F0 0F             BEQ RPM8
  626  0801  A5 61             LDA RPMSCALE5
  627  0803  85 44             STA DIVIDEND
  628  0805  A5 62             LDA RPMSCALE5+1
  629  0807  85 45             STA DIVIDEND+1
  630  0809  A5 63             LDA RPMSCALE5+2
  631  080B  85 46             STA DIVIDEND+2
  632  080D  4C 1C 08          JMP DODIV
  633  0810            RPM8
  634  0810  A5 5E             LDA RPMSCALE8
  635  0812  85 44             STA DIVIDEND
  636  0814  A5 5F             LDA RPMSCALE8+1
  637  0816  85 45             STA DIVIDEND+1
  638  0818  A5 60             LDA RPMSCALE8+2
  639  081A  85 46             STA DIVIDEND+2
  640  081C            DODIV
  641  081C  20 63 13          JSR DIV24       ; Get integer part of RPM
  642  081F  A9 20             LDA #' '
  643  0821  85 5A             STA pad
  644  0823  20 61 08          JSR PrDec16
  645  0826  A9 64             LDA #100        ; Multiply remainder by 100 and divide again to get
  646  0828  85 4D             STA factor2     ; fractional part
  647  082A  A9 00             LDA #0
  648  082C  85 4E             STA factor2+1
  649  082E  85 4F             STA factor2+2
  650  0830  20 99 13          JSR MULT24
  651  0833  20 63 13          JSR DIV24
  652  0836  A9 2E             LDA #'.'
  653  0838  20 65 12          JSR OUTPUT
  654  083B  A9 30             LDA #'0'
  655  083D  85 5A             STA pad
  656  083F  A0 02             LDY #2                       ; Print 2 digits
  657  0841  20 63 08          JSR PrDec16Lp1
  658  0844  60                RTS
  659                          
  660                     ; From http://beebwiki.mdfs.net/Number_output_in_6502_machine_code
  661                     ; ---------------------------
  662                     ; Print 16-bit decimal number
  663                     ; ---------------------------
  664                     ; On entry, num=number to print
  665                     ;           pad=0 or pad character (eg '0' or ' ')
  666                     ; On entry at PrDec16Lp1,
  667                     ;           Y=(number of digits)*2-2, eg 8 for 5 digits
  668                     ; On exit,  A,X,Y,num,pad corrupted
  669                     ; Size      69 bytes
  670                     ; -----------------------------------------------------------------
  671  0044            num = DIVIDEND
  672                  
  673  0845            PrDec2Dig
  674  0845  85 44        STA num
  675  0847  A9 00        LDA #0
  676  0849  85 45        STA num+1
  677  084B  A9 20        LDA #' '
  678  084D  85 5A        STA pad
  679  084F  A0 02        LDY #2
  680  0851  4C 63 08     JMP PrDec16Lp1
  681  0854            PrDec4Dig
  682  0854  86 44        STX num
  683  0856  85 45        STA num+1
  684  0858  A9 20        LDA #' '
  685  085A  85 5A        STA pad
  686  085C  A0 06        LDY #6
  687  085E  4C 63 08     JMP PrDec16Lp1
  688                  
  689  0861            PrDec16
  690  0861  A0 08        LDY #8               ; Offset to powers of ten
  691  0863            PrDec16Lp1
  692  0863  A2 FF        LDX #$FF
  693  0865  38           SEC                  ; Start with digit=-1
  694  0866            PrDec16Lp2
  695  0866  A5 44        LDA num+0
  696  0868  F9 A1 08     SBC PrDec16Tens+0,Y
  697  086B  85 44        STA num+0            ; Subtract current tens
  698  086D  A5 45        LDA num+1
  699  086F  F9 A2 08     SBC PrDec16Tens+1,Y
  700  0872  85 45        STA num+1
  701  0874  E8           INX
  702  0875  B0 EF        BCS PrDec16Lp2       ; Loop until <0
  703  0877  A5 44        LDA num+0
  704  0879  79 A1 08     ADC PrDec16Tens+0,Y
  705  087C  85 44        STA num+0            ; Add current tens back in
  706  087E  A5 45        LDA num+1
  707  0880  79 A2 08     ADC PrDec16Tens+1,Y
  708  0883  85 45        STA num+1
  709  0885  8A           TXA
  710  0886  C0 00        CPY #0
  711  0888  F0 09        BEQ PrDec16Digit     ; Last digit, always print
  712  088A  8A           TXA
  713  088B  D0 06        BNE PrDec16Digit     ; Not zero, print it
  714  088D  A5 5A        LDA pad
  715  088F  D0 08        BNE PrDec16Print
  716  0891  F0 09        BEQ PrDec16Next      ; pad<>0, use it
  717  0893            PrDec16Digit
  718  0893  A2 30        LDX #'0
  719  0895  86 5A        STX pad              ; No more zero padding
  720  0897  09 30        ORA #'0              ; Print this digit
  721  0899            PrDec16Print
  722  0899  20 65 12     JSR OUTPUT
  723  089C            PrDec16Next
  724  089C  88           DEY
  725  089D  88           DEY
  726  089E  10 C3        BPL PrDec16Lp1       ; Loop for next digit
  727  08A0  60           RTS
  728  08A1            PrDec16Tens
  729  08A1  01 00        .WORD 1
  730  08A3  0A 00        .WORD 10
  731  08A5  64 00        .WORD 100
  732  08A7  E8 03        .WORD 1000
  733  08A9  10 27        .WORD 10000
  734                  ;-----------------------------------------------------------
  735                  ; Either write test pattern then check or just check pattern.
  736                  ; Read test only works for data written by this program.
  737  08AB            TEST
  738  08AB  A9 00             LDA     #0
  739  08AD  85 79             STA     SINGLETRK
  740  08AF            TEST2
  741  08AF  20 CC 0F          JSR     PRINT
  742  08B2  0D 0A             .BYTE   CR,LF
  743  08B4  57 52 49          .BYTE   'WRITE PROTECT ALL DISKS EXCEPT TEST DISK!',CR,LF
       08B7  54 45 20  
       08BA  50 52 4F  
       08BD  54 45 43  
       08C0  54 20 41  
       08C3  4C 4C 20  
       08C6  44 49 53  
       08C9  4B 53 20  
       08CC  45 58 43  
       08CF  45 50 54  
       08D2  20 54 45  
       08D5  53 54 20  
       08D8  44 49 53  
       08DB  4B 21 0D  
       08DE  0A        
  744  08DF  0D 0A             .BYTE   CR,LF
  745  08E1  49 4E 53          .BYTE   'INSERT DISK TO BE TESTED',CR,LF
       08E4  45 52 54  
       08E7  20 44 49  
       08EA  53 4B 20  
       08ED  54 4F 20  
       08F0  42 45 20  
       08F3  54 45 53  
       08F6  54 45 44  
       08F9  0D 0A     
  746  08FB  49 66 20          .BYTE   'If errors found the output is DDDD (#### GG BBP)* EEEE',CR,LF
       08FE  65 72 72  
       0901  6F 72 73  
       0904  20 66 6F  
       0907  75 6E 64  
       090A  20 74 68  
       090D  65 20 6F  
       0910  75 74 70  
       0913  75 74 20  
       0916  69 73 20  
       0919  44 44 44  
       091C  44 20 28  
       091F  23 23 23  
       0922  23 20 47  
       0925  47 20 42  
       0928  42 50 29  
       092B  2A 20 45  
       092E  45 45 45  
       0931  0D 0A     
  747  0933  77 68 65          .BYTE   'where DDDD is difference between number of bytes written',CR,LF
       0936  72 65 20  
       0939  44 44 44  
       093C  44 20 69  
       093F  73 20 64  
       0942  69 66 66  
       0945  65 72 65  
       0948  6E 63 65  
       094B  20 62 65  
       094E  74 77 65  
       0951  65 6E 20  
       0954  6E 75 6D  
       0957  62 65 72  
       095A  20 6F 66  
       095D  20 62 79  
       0960  74 65 73  
       0963  20 77 72  
       0966  69 74 74  
       0969  65 6E 0D  
       096C  0A        
  748  096D  61 6E 64          .BYTE   'and read. EEEE is total errors, #### is byte count from', CR,LF
       0970  20 72 65  
       0973  61 64 2E  
       0976  20 45 45  
       0979  45 45 20  
       097C  69 73 20  
       097F  74 6F 74  
       0982  61 6C 20  
       0985  65 72 72  
       0988  6F 72 73  
       098B  2C 20 23  
       098E  23 23 23  
       0991  20 69 73  
       0994  20 62 79  
       0997  74 65 20  
       099A  63 6F 75  
       099D  6E 74 20  
       09A0  66 72 6F  
       09A3  6D 0D 0A  
  749  09A6  73 74 61          .BYTE   'start of track, GG is good byte, BB is bad byte,',CR,LF
       09A9  72 74 20  
       09AC  6F 66 20  
       09AF  74 72 61  
       09B2  63 6B 2C  
       09B5  20 47 47  
       09B8  20 69 73  
       09BB  20 67 6F  
       09BE  6F 64 20  
       09C1  62 79 74  
       09C4  65 2C 20  
       09C7  42 42 20  
       09CA  69 73 20  
       09CD  62 61 64  
       09D0  20 62 79  
       09D3  74 65 2C  
       09D6  0D 0A     
  750  09D8  50 20 69          .BYTE   'P is byte had parity error.',CR,LF
       09DB  73 20 62  
       09DE  79 74 65  
       09E1  20 68 61  
       09E4  64 20 70  
       09E7  61 72 69  
       09EA  74 79 20  
       09ED  65 72 72  
       09F0  6F 72 2E  
       09F3  0D 0A     
  751  09F5  45 72 72          .BYTE   'Errors that fit on line are printed.',CR,LF
       09F8  6F 72 73  
       09FB  20 74 68  
       09FE  61 74 20  
       0A01  66 69 74  
       0A04  20 6F 6E  
       0A07  20 6C 69  
       0A0A  6E 65 20  
       0A0D  61 72 65  
       0A10  20 70 72  
       0A13  69 6E 74  
       0A16  65 64 2E  
       0A19  0D 0A     
  752  0A1B  45 53 43          .BYTE   'ESC KEY OR ^X ABORTS...',CR,LF,0
       0A1E  20 4B 45  
       0A21  59 20 4F  
       0A24  52 20 5E  
       0A27  58 20 41  
       0A2A  42 4F 52  
       0A2D  54 53 2E  
       0A30  2E 2E 0D  
       0A33  0A 00     
  753                  
  754  0A35  20 27 10          JSR     ANYKEY
  755  0A38  C9 1B             CMP     #$1B   ;ESC key?
  756  0A3A  F0 3B             BEQ     JMP2TOP
  757  0A3C  C9 18             CMP     #$18   ;^X
  758  0A3E  F0 37             BEQ     JMP2TOP
  759                  
  760                  
  761  0A40  A5 35             LDA     PASSES
  762  0A42  85 37             STA     PASSCNTR
  763  0A44  20 E9 0E          JSR     INITPIA
  764  0A47  20 09 0F          JSR     SELDRV
  765  0A4A  20 D8 0E          JSR     RESPTR
  766  0A4D  A9 20             LDA     #$20
  767  0A4F  2C 00 C0          BIT     DDPIA
  768  0A52  D0 26             BNE     WRITEOK
  769  0A54  20 CC 0F          JSR     PRINT
  770  0A57  0D 0A             .BYTE   CR,LF
  771  0A59  44 49 53          .BYTE   'DISK IS WRITE PROTECTED!',CR,LF,0
       0A5C  4B 20 49  
       0A5F  53 20 57  
       0A62  52 49 54  
       0A65  45 20 50  
       0A68  52 4F 54  
       0A6B  45 43 54  
       0A6E  45 44 21  
       0A71  0D 0A 00  
  772  0A74  20 27 10          JSR     ANYKEY
  773  0A77            JMP2TOP
  774  0A77  4C A1 03          JMP     TOP
  775  0A7A            WRITEOK
  776  0A7A  A5 79             LDA     SINGLETRK
  777  0A7C  D0 08             BNE     TESTFILL ; Head already at desired track
  778  0A7E  20 26 0F          JSR     TZERO   ; STEP TO TRACK 0
  779  0A81  90 03             BCC     TESTFILL
  780  0A83  4C B2 0E          JMP     NOTRK
  781                  
  782  0A86            TESTFILL
  783  0A86  20 D8 0E          JSR     RESPTR
  784  0A89  A0 00             LDY     #0
  785  0A8B            TFILL   
  786  0A8B  A5 34             LDA     PATVAL
  787  0A8D  24 33             BIT     PATSEL          ; Fill with test pattern. 
  788  0A8F  10 03             BPL     TSTORE          ; Always fills larger 8" number of bytes
  789  0A91  20 4D 13          JSR     RAND
  790  0A94            TSTORE
  791  0A94  91 6D             STA     (TDATA),Y
  792  0A96  C8                INY
  793  0A97  D0 02             BNE     TCHKFILLED
  794  0A99  E6 6E             INC     TDATA+1
  795  0A9B            TCHKFILLED
  796  0A9B  C0 10             CPY     #BYTES8%256
  797  0A9D  D0 EC             BNE     TFILL
  798  0A9F  A5 6E             LDA     TDATA+1
  799  0AA1  38                SEC
  800  0AA2  E9 15             SBC     #BUFFER/256
  801  0AA4  C9 0E             CMP     #BYTES8/256
  802  0AA6  D0 E3             BNE     TFILL
  803                  
  804  0AA8  A9 5A             LDA     #$5A            ; Start of track marker
  805  0AAA  8D 3F 15          STA     BUFFER
  806                          
  807  0AAD  A9 58             LDA     #$58    ;0 10 110 00 ;$58-  recv irq, RTS HIGH no xmit irq,  8E1,  DIVIDE BY 1,
  808  0AAF  85 6A             STA     DRVACIA 
  809                  
  810  0AB1  AD 02 C0          LDA     DDPIA+2  ; PRESERVE DISK SEL BIT
  811  0AB4  29 7F             AND     #$7F    ; 0111 1111
  812  0AB6  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
  813  0AB9  A2 FF             LDX     #$FF    ; 320MS
  814  0ABB  20 BD 0F          JSR     DELAY
  815                  
  816  0ABE  A5 36             LDA     READONLY        ; If read only skip write
  817  0AC0  F0 03             BEQ     WRNEXT
  818  0AC2  4C 5E 0B          JMP     TREAD
  819  0AC5            WRNEXT
  820  0AC5  20 CC 0F          JSR     PRINT
  821  0AC8  57 54 52          .BYTE   'WTRK ',0
       0ACB  4B 20 00  
  822  0ACE  A5 2E             LDA     TRK
  823  0AD0  20 45 08          JSR     PrDec2Dig
  824  0AD3  A5 64             LDA     MTRKBYTES
  825  0AD5  85 66             STA     BYTECNTR
  826  0AD7  A5 65             LDA     MTRKBYTES+1
  827  0AD9  85 67             STA     BYTECNTR+1
  828  0ADB  20 D8 0E          JSR     RESPTR
  829  0ADE  A5 2E             LDA     TRK     ; Write track to second byte to check for seek errors
  830  0AE0  8D 40 15          STA     BUFFER+1
  831                  
  832  0AE3  2C 00 C0          BIT     DDPIA   ; WAIT 
  833  0AE6  30 FB             BMI     *-3     ; INDEX PULSE
  834  0AE8  2C 00 C0          BIT     DDPIA   ; WAIT END OF
  835  0AEB  10 FB             BPL     *-3     ; INDEX PULSE
  836  0AED  AD 02 C0          LDA     DDPIA+2 ; PRESERVE DISK SEL BIT
  837  0AF0  29 FC             AND     #$FC    ; TURN ON WRITE AND ERASE ENABLE
  838  0AF2  8D 02 C0          STA     DDPIA+2
  839                  
  840  0AF5  A9 03             LDA     #3
  841  0AF7  8D 10 C0          STA     DDACIA  ; RESET ACIA
  842  0AFA  A5 6A             LDA     DRVACIA ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
  843  0AFC  8D 10 C0          STA     DDACIA  ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  844  0AFF  A2 01             LDX     #1      ; 0.8MS
  845  0B01  A0 9E             LDY     #$9E
  846  0B03  20 BF 0F          JSR     DELAY1
  847  0B06  A0 00             LDY     #0
  848  0B08            WRDATALP
  849  0B08  2C 00 C0          BIT     DDPIA   ; WAIT 
  850  0B0B  30 03             BMI     WNOINDEXERR     ; Didn't find INDEX PULSE
  851  0B0D  4C 64 0E          JMP     INDEXERR        
  852  0B10            WNOINDEXERR
  853  0B10  A9 02             LDA     #2
  854  0B12  2D 10 C0          AND     DDACIA          ;test tx ready? 
  855  0B15  F0 F1             BEQ     WRDATALP        ;not ready?
  856  0B17  B1 6D             LDA     (TDATA),Y
  857  0B19  8D 11 C0          STA     DDACIA+1        ; Write data to floppy
  858  0B1C  C8                INY
  859  0B1D  D0 02             BNE     *+4
  860  0B1F  E6 6E             INC     TDATA+1
  861  0B21  E6 66             INC     BYTECNTR
  862  0B23  D0 E3             BNE     WRDATALP
  863  0B25  E6 67             INC     BYTECNTR+1
  864  0B27  D0 E7             BNE     WNOINDEXERR     ; Not done, write more. Don't check for index
  865                                                  ; to prevent being late writing next char.
  866                  
  867  0B29  2C 00 C0          BIT     DDPIA   ; WAIT FOR
  868  0B2C  30 FB             BMI     *-3     ; INDEX PULSE
  869  0B2E  2C 00 C0          BIT     DDPIA   ; WAIT FOR
  870  0B31  10 FB             BPL     *-3     ; END INDEX PULSE
  871  0B33  A2 20             LDX     #32     ; Erase a little past index
  872  0B35  CA                DEX
  873  0B36  D0 FD             BNE     *-1
  874                          
  875  0B38  A9 03             LDA     #$03
  876  0B3A  0D 02 C0          ORA     DDPIA+2 ; turn off write and erase
  877  0B3D  8D 02 C0          STA     DDPIA+2
  878                  
  879  0B40  A9 0D             LDA     #CR
  880  0B42  20 65 12          JSR     OUTPUT
  881  0B45  A5 79             LDA     SINGLETRK
  882  0B47  D0 15             BNE     TREAD   ; Single track, we are done writing
  883  0B49  A6 2E             LDX     TRK
  884  0B4B  E8                INX
  885  0B4C  E4 2A             CPX     MAXTRK
  886  0B4E  F0 06             BEQ     TWDONE
  887  0B50  20 8A 0F          JSR     TNEXT   ; Go to next track
  888  0B53  4C C5 0A          JMP     WRNEXT
  889  0B56            TWDONE
  890  0B56  A9 80             LDA     #$80
  891  0B58  0D 02 C0          ORA     DDPIA+2 ; Unload head
  892  0B5B  8D 02 C0          STA     DDPIA+2
  893                  
  894                  
  895                          ; Read portion of disk test. Enter at TREAD2 if testing
  896                          ; single track. For normal read we save off the data read and the
  897                          ; error flags from the serial chip. We don't have enough time
  898                          ; to handle errors between bytes.
  899                          ; For scope read we check the word in real time and generate
  900                          ; fault reset pulse to trigger a scope. Checking for the track stops
  901                          ; after the first error.
  902  0B5E            TREAD
  903  0B5E  A5 79             LDA     SINGLETRK
  904  0B60  D0 15             BNE     TREAD2  ; Single track, skip seek to zero
  905  0B62  20 26 0F          JSR     TZERO   ; STEP TO TRACK 0
  906  0B65  90 03             BCC     *+5
  907  0B67  4C B2 0E          JMP     NOTRK
  908  0B6A  AD 02 C0          LDA     DDPIA+2  ; PRESERVE DISK SEL BIT
  909  0B6D  29 7F             AND     #$7F    ; 0111 1111
  910  0B6F  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
  911  0B72  A2 FF             LDX     #$FF    ; 320MS
  912  0B74  20 BD 0F          JSR     DELAY
  913                  
  914  0B77            TREAD2
  915  0B77  20 D8 0E          JSR     RESPTR
  916  0B7A  A9 00             LDA     #0
  917  0B7C  85 5B             STA     ERRCNT
  918  0B7E  85 5C             STA     ERRCNT+1
  919  0B80  85 5D             STA     PRTERR  
  920                  
  921  0B82  20 CC 0F          JSR     PRINT
  922  0B85  52 54 52          .BYTE   'RTRK ',0
       0B88  4B 20 00  
  923  0B8B  A5 2E             LDA     TRK
  924  0B8D  20 45 08          JSR     PrDec2Dig
  925  0B90  A9 20             LDA     #' '
  926  0B92  20 65 12          JSR     OUTPUT
  927  0B95  A5 2E             LDA     TRK             ; Update compare data with track testing
  928  0B97  8D 40 15          STA     BUFFER+1
  929                  
  930  0B9A  2C 00 C0          BIT     DDPIA   ; WAIT 
  931  0B9D  30 FB             BMI     *-3     ; INDEX PULSE
  932  0B9F  2C 00 C0          BIT     DDPIA   ; WAIT END OF
  933  0BA2  10 FB             BPL     *-3     ; INDEX PULSE
  934  0BA4  A9 03             LDA     #3
  935  0BA6  8D 10 C0          STA     DDACIA  ; RESET ACIA
  936  0BA9  A5 6A             LDA     DRVACIA ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
  937  0BAB  8D 10 C0          STA     DDACIA  ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  938  0BAE  A5 69             LDA     TESTTYPE
  939  0BB0  D0 03             BNE     *+5
  940  0BB2  4C DE 0C          JMP     NORMREAD        ; User selected normal read test
  941                  
  942                          ; This is scope read check code
  943  0BB5  A0 00             LDY     #0
  944  0BB7  A9 01             LDA     #1
  945  0BB9            RDATALP2
  946  0BB9  2C 00 C0          BIT     DDPIA
  947  0BBC  10 35             BPL     NODATA          ; INDEX PULSE
  948  0BBE  2C 10 C0          BIT     DDACIA          ; test tx ready?        
  949  0BC1  F0 F6             BEQ     RDATALP2
  950  0BC3  08                PHP
  951  0BC4  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
  952  0BC7  C9 5A             CMP     #$5A            ; Got start byte
  953  0BC9  D0 07             BNE     IGNBYTE         ; No, try one more time. We get one junk
  954                                                  ; byte where write turned on/off
  955  0BCB  28                PLP
  956  0BCC  70 33             BVS     SERROR          ; Did it get a parity error
  957  0BCE  C8                INY                     ; Skip this byte in checking since we checked
  958  0BCF  4C D3 0B          JMP     RDATALP3
  959  0BD2            IGNBYTE
  960  0BD2  28                PLP
  961  0BD3            RDATALP3
  962  0BD3  2C 00 C0          BIT     DDPIA
  963  0BD6  30 03             BMI     NOTINDEX2       ; INDEX PULSE
  964  0BD8  4C E9 0D          JMP     PCRONLY
  965  0BDB            NOTINDEX2
  966  0BDB  A9 01             LDA     #1
  967  0BDD  2C 10 C0          BIT     DDACIA          ; test tx ready?        
  968  0BE0  F0 F1             BEQ     RDATALP3
  969  0BE2  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
  970  0BE5  70 1A             BVS     SERROR          ; Branch if parity error
  971  0BE7  D1 6D             CMP     (TDATA),Y       ; Check data
  972  0BE9  D0 16             BNE     SERROR
  973  0BEB  C8                INY
  974  0BEC  D0 ED             BNE     NOTINDEX2
  975  0BEE  E6 6E             INC     TDATA+1
  976  0BF0  4C DB 0B          JMP     NOTINDEX2
  977  0BF3            NODATA
  978  0BF3  20 CC 0F          JSR     PRINT
  979  0BF6  4E 6F 20          .BYTE   'No data',0
       0BF9  64 61 74  
       0BFC  61 00     
  980  0BFE            JPCRLF
  981  0BFE  4C E0 0D          JMP     PCRLF
  982  0C01            SERROR  ; Print error info and generate scope trigger
  983  0C01  48                PHA
  984  0C02  A9 EF             LDA     #$EF
  985  0C04  2D 02 C0          AND     DDPIA+2 ; Clear fault reset
  986  0C07  8D 02 C0          STA     DDPIA+2
  987  0C0A  20 C8 0F          JSR     DELAY2
  988  0C0D  A9 10             LDA     #$10
  989  0C0F  0D 02 C0          ORA     DDPIA+2 ; Set fault reset
  990  0C12  8D 02 C0          STA     DDPIA+2
  991                  
  992  0C15  38                SEC
  993  0C16  A5 6E             LDA     TDATA+1         ; Calculate offset of byte with error
  994  0C18  E9 15             SBC     #>BUFFER
  995  0C1A  85 45             STA     num+1
  996  0C1C  84 68             STY     YHOLD
  997  0C1E  84 44             STY     num
  998  0C20  98                TYA
  999  0C21  18                CLC
 1000  0C22  65 64             ADC     MTRKBYTES
 1001  0C24  A5 45             LDA     num+1
 1002  0C26  65 65             ADC     MTRKBYTES+1
 1003  0C28  30 16             BMI     SPERR   ; Error was in bytes being tested
 1004  0C2A  20 CC 0F          JSR     PRINT
 1005  0C2D  45 78 74          .BYTE   'Extra data read',0
       0C30  72 61 20  
       0C33  64 61 74  
       0C36  61 20 72  
       0C39  65 61 64  
       0C3C  00        
 1006  0C3D  4C 67 0C          JMP     SERRWAIT
 1007                          
 1008  0C40            SPERR
 1009  0C40  A9 30             LDA     #'0'
 1010  0C42  85 5A             STA     pad
 1011  0C44  A0 06             LDY     #6      ; 4 digits max
 1012  0C46  20 63 08          JSR     PrDec16Lp1
 1013  0C49  20 CC 0F          JSR     PRINT
 1014  0C4C  20 47 4F          .BYTE   ' GOOD ',0
       0C4F  4F 44 20  
       0C52  00        
 1015  0C53  A4 68             LDY     YHOLD
 1016  0C55  B1 6D             LDA     (TDATA),Y
 1017  0C57  20 F6 0F          JSR     PHEXA
 1018  0C5A  20 CC 0F          JSR     PRINT
 1019  0C5D  20 42 41          .BYTE   ' BAD ',0
       0C60  44 20 00  
 1020  0C63  68                PLA
 1021  0C64  20 F6 0F          JSR     PHEXA
 1022  0C67            SERRWAIT
 1023  0C67  AD 02 C0          LDA     DDPIA+2
 1024  0C6A  09 80             ORA     #$80    
 1025  0C6C  8D 02 C0          STA     DDPIA+2 ; UNLOAD DISK HEAD
 1026  0C6F  20 1C 12          JSR     Get_Chr
 1027  0C72  20 CC 0F          JSR     PRINT
 1028  0C75  0D 0A 48          .BYTE   CR,LF,'Hit space to reread E to exit or other key to continue > ',0
       0C78  69 74 20  
       0C7B  73 70 61  
       0C7E  63 65 20  
       0C81  74 6F 20  
       0C84  72 65 72  
       0C87  65 61 64  
       0C8A  20 45 20  
       0C8D  74 6F 20  
       0C90  65 78 69  
       0C93  74 20 6F  
       0C96  72 20 6F  
       0C99  74 68 65  
       0C9C  72 20 6B  
       0C9F  65 79 20  
       0CA2  74 6F 20  
       0CA5  63 6F 6E  
       0CA8  74 69 6E  
       0CAB  75 65 20  
       0CAE  3E 20 00  
 1029  0CB1  20 34 12          JSR     INKEY
 1030  0CB4  48                PHA
 1031  0CB5  20 CC 0F          JSR     PRINT
 1032  0CB8  0D 0A 00          .BYTE   CR,LF,0
 1033  0CBB  68                PLA
 1034  0CBC  09 20             ORA     #$20    ; Lower case
 1035  0CBE  C9 65             CMP     #'e'
 1036  0CC0  D0 03             BNE     *+5
 1037  0CC2  4C A1 03          JMP     TOP
 1038  0CC5  48                PHA
 1039  0CC6  AD 02 C0          LDA     DDPIA+2 ; PRESERVE DISK SEL BIT
 1040  0CC9  29 7F             AND     #$7F    ; 0111 1111
 1041  0CCB  8D 02 C0          STA     DDPIA+2 ; LOAD DISK HEAD
 1042  0CCE  A2 FF             LDX     #$FF    ; 320MS
 1043  0CD0  20 BD 0F          JSR     DELAY
 1044  0CD3  68                PLA
 1045  0CD4  C9 20             CMP     #' '
 1046  0CD6  F0 03             BEQ     *+5
 1047  0CD8  4C EE 0D          JMP     NEXTTRK
 1048  0CDB  4C 77 0B          JMP     TREAD2
 1049                          
 1050                          
 1051                  
 1052                          ; This is normal read check code
 1053  0CDE            NORMREAD
 1054  0CDE  A0 00             LDY     #0
 1055  0CE0            RDATALP
 1056  0CE0  2C 00 C0          BIT     DDPIA
 1057  0CE3  10 16             BPL     RINDEX          ; INDEX PULSE
 1058  0CE5            NOTINDEX
 1059  0CE5  AD 10 C0          LDA     DDACIA          ; test tx ready?        
 1060  0CE8  91 6F             STA     (TDATA2),Y      ; store error data
 1061  0CEA  4A                LSR
 1062  0CEB  90 F3             BCC     RDATALP         ; not ready?
 1063  0CED  AD 11 C0          LDA     DDACIA+1        ; read data from floppy
 1064  0CF0  C8                INY
 1065  0CF1  91 6F             STA     (TDATA2),Y      ; store disk data
 1066  0CF3  C8                INY
 1067  0CF4  D0 EF             BNE     NOTINDEX
 1068  0CF6  E6 70             INC     TDATA2+1
 1069  0CF8  4C E5 0C          JMP     NOTINDEX
 1070                  
 1071  0CFB            RINDEX
 1072  0CFB  18                CLC     ; Found index, determine how many bytes read
 1073  0CFC  98                TYA
 1074  0CFD  65 6F             ADC     TDATA2
 1075  0CFF  85 6F             STA     TDATA2
 1076  0D01  90 02             BCC     *+4
 1077  0D03  E6 70             INC     TDATA2+1
 1078  0D05  38                SEC
 1079  0D06  A5 6F             LDA     TDATA2
 1080  0D08  E9 4F             SBC     #<BUFFER2
 1081  0D0A  85 66             STA     BYTECNTR
 1082  0D0C  A5 70             LDA     TDATA2+1
 1083  0D0E  E9 23             SBC     #>BUFFER2
 1084  0D10  18                CLC
 1085  0D11  6A                ROR
 1086  0D12  85 67             STA     BYTECNTR+1
 1087  0D14  A5 66             LDA     BYTECNTR        ; divide by 2 to get bytes data stored
 1088  0D16  6A                ROR
 1089  0D17  85 66             STA     BYTECNTR
 1090  0D19  A5 66             LDA     BYTECNTR
 1091  0D1B  D0 04             BNE     CHKSTART
 1092  0D1D  A5 67             LDA     BYTECNTR+1
 1093  0D1F  F0 26             BEQ     NOSKIP          ; If no data don't try to find start of track
 1094  0D21            CHKSTART
 1095                          ; This will skip up to 1 byte looking for $5A start of track flag
 1096                          ; The write turn on/off generates one byte of junk sometimes
 1097  0D21  20 D8 0E          JSR     RESPTR
 1098  0D24  AD 50 23          LDA     BUFFER2+1
 1099  0D27  C9 5A             CMP     #$5A            ; Start of track flag
 1100  0D29  F0 1C             BEQ     NOSKIP
 1101  0D2B  AD 52 23          LDA     BUFFER2+3
 1102  0D2E  C9 5A             CMP     #$5A            ; Start of track flag
 1103  0D30  D0 15             BNE     NOSKIP          ; No, assume read error
 1104  0D32  18                CLC
 1105  0D33  A9 02             LDA     #2
 1106  0D35  65 6F             ADC     TDATA2
 1107  0D37  85 6F             STA     TDATA2
 1108  0D39  A9 00             LDA     #0
 1109  0D3B  65 70             ADC     TDATA2+1        ; Ignore one junk character
 1110  0D3D  85 70             STA     TDATA2+1        ; and parity byte
 1111  0D3F  A5 66             LDA     BYTECNTR
 1112  0D41  D0 02             BNE     *+4
 1113  0D43  C6 67             DEC     BYTECNTR+1
 1114  0D45  C6 66             DEC     BYTECNTR
 1115  0D47            NOSKIP
 1116  0D47  18                CLC     ; Print bytes read - bytes written. Skipped byte not
 1117                                  ; included in bytes read 
 1118  0D48  A5 66             LDA     BYTECNTR
 1119  0D4A  65 64             ADC     MTRKBYTES
 1120  0D4C  AA                TAX
 1121  0D4D  A5 67             LDA     BYTECNTR+1
 1122  0D4F  65 65             ADC     MTRKBYTES+1
 1123  0D51  30 0D             BMI     PNEG
 1124  0D53  48                PHA
 1125  0D54  A9 20             LDA     #' '
 1126  0D56  20 65 12          JSR     OUTPUT
 1127  0D59  68                PLA
 1128  0D5A  20 54 08          JSR     PrDec4Dig
 1129  0D5D  4C 95 0D          JMP     RCHKDATA
 1130  0D60            PNEG
 1131  0D60  85 68             STA     YHOLD
 1132  0D62  86 2F             STX     TMP
 1133  0D64  A9 2D             LDA     #'-'
 1134  0D66  20 65 12          JSR     OUTPUT
 1135  0D69  A9 00             LDA     #0
 1136  0D6B  38                SEC
 1137  0D6C  E5 2F             SBC     TMP
 1138  0D6E  85 44             STA     num
 1139  0D70  A9 00             LDA     #0
 1140  0D72  E5 68             SBC     YHOLD
 1141  0D74  85 45             STA     num+1
 1142  0D76  A9 2D             LDA     #'-'
 1143  0D78  85 5A             STA     pad
 1144  0D7A  A0 06             LDY     #6
 1145  0D7C  20 63 08          JSR     PrDec16Lp1
 1146                  
 1147  0D7F  38                SEC
 1148  0D80  A9 00             LDA     #0
 1149                          ; Bytes read shorter than expected so only check bytes read.
 1150  0D82  E5 66             SBC     BYTECNTR        
 1151  0D84  85 66             STA     BYTECNTR        ; Convert to negative count
 1152  0D86  A9 00             LDA     #0
 1153  0D88  E5 67             SBC     BYTECNTR+1
 1154  0D8A  85 67             STA     BYTECNTR+1
 1155  0D8C  D0 0F             BNE     RCHKDATALP
 1156  0D8E  A5 66             LDA     BYTECNTR
 1157  0D90  D0 0B             BNE     RCHKDATALP
 1158  0D92  4C E0 0D          JMP     PCRLF   ; No bytes read, don't compare. Just print CRLF
 1159  0D95            RCHKDATA
 1160  0D95  A5 64             LDA     MTRKBYTES
 1161  0D97  85 66             STA     BYTECNTR
 1162  0D99  A5 65             LDA     MTRKBYTES+1
 1163  0D9B  85 67             STA     BYTECNTR+1
 1164  0D9D            RCHKDATALP
 1165  0D9D  A0 00             LDY     #0
 1166  0D9F  A9 40             LDA     #$40
 1167  0DA1  31 6F             AND     (TDATA2),Y
 1168  0DA3  D0 6F             BNE     RERROR  ; Data had parity error
 1169  0DA5  A5 70             LDA     TDATA2+1
 1170  0DA7  C8                INY
 1171  0DA8  B1 6F             LDA     (TDATA2),Y
 1172  0DAA  88                DEY
 1173  0DAB  D1 6D             CMP     (TDATA),Y
 1174  0DAD  D0 65             BNE     RERROR  ; Miscompare
 1175  0DAF            RCONT
 1176  0DAF  18                CLC
 1177  0DB0  A9 02             LDA     #2
 1178  0DB2  65 6F             ADC     TDATA2  ; Inc data pointers
 1179  0DB4  85 6F             STA     TDATA2
 1180  0DB6  90 02             BCC     *+4
 1181  0DB8  E6 70             INC     TDATA2+1
 1182  0DBA  E6 6D             INC     TDATA
 1183  0DBC  D0 02             BNE     *+4
 1184  0DBE  E6 6E             INC     TDATA+1
 1185  0DC0  E6 66             INC     BYTECNTR
 1186  0DC2  D0 02             BNE     *+4
 1187  0DC4  E6 67             INC     BYTECNTR+1
 1188  0DC6  D0 D5             BNE     RCHKDATALP
 1189                  
 1190  0DC8            PRTERRCNT
 1191  0DC8  A5 5B             LDA     ERRCNT  ; Done compare, did we get any errors?
 1192  0DCA  D0 04             BNE     PERRCNT
 1193  0DCC  A5 5C             LDA     ERRCNT+1
 1194  0DCE  F0 0C             BEQ     PNOERR  ; no
 1195  0DD0            PERRCNT
 1196  0DD0  A9 20             LDA     #' '
 1197  0DD2  20 65 12          JSR     OUTPUT
 1198  0DD5  A6 5B             LDX     ERRCNT
 1199  0DD7  A5 5C             LDA     ERRCNT+1
 1200  0DD9  20 54 08          JSR     PrDec4Dig
 1201  0DDC            PNOERR
 1202  0DDC  A5 5D             LDA     PRTERR
 1203  0DDE  F0 09             BEQ     PCRONLY
 1204  0DE0            PCRLF
 1205  0DE0  20 CC 0F          JSR     PRINT
 1206  0DE3  0D 0A 00          .BYTE   CR,LF,0
 1207  0DE6  4C EE 0D          JMP     NEXTTRK
 1208  0DE9            PCRONLY
 1209  0DE9  A9 0D             LDA     #CR
 1210  0DEB  20 65 12          JSR     OUTPUT
 1211  0DEE            NEXTTRK
 1212  0DEE  A5 79             LDA     SINGLETRK       ; Done if single track or at max
 1213  0DF0  D0 0D             BNE     TRDONE
 1214  0DF2  A6 2E             LDX     TRK
 1215  0DF4  E8                INX
 1216  0DF5  E4 2A             CPX     MAXTRK
 1217  0DF7  F0 06             BEQ     TRDONE
 1218  0DF9  20 8A 0F          JSR     TNEXT   ; seek to next track
 1219  0DFC            JTREAD2
 1220  0DFC  4C 77 0B          JMP     TREAD2
 1221  0DFF            TRDONE
 1222  0DFF  A9 80             LDA     #$80
 1223  0E01  0D 02 C0          ORA     DDPIA+2 ; Unload head
 1224  0E04  8D 02 C0          STA     DDPIA+2
 1225  0E07  C6 37             DEC     PASSCNTR
 1226  0E09  F0 03             BEQ     JMPTOP
 1227  0E0B  4C 7A 0A          JMP     WRITEOK
 1228  0E0E            JMPTOP
 1229  0E0E  20 27 10          JSR     ANYKEY
 1230  0E11  4C A1 03          JMP     TOP
 1231                  
 1232                          ; Print offset of error and good and bad data
 1233  0E14            RERROR
 1234  0E14  E6 5B             INC     ERRCNT
 1235  0E16  D0 02             BNE     *+4
 1236  0E18  E6 5C             INC     ERRCNT+1
 1237  0E1A  A5 5B             LDA     ERRCNT
 1238  0E1C  C5 78             CMP     MAXERR          ; Only print first MAXERR errors
 1239  0E1E  B0 41             BCS     NOPRT
 1240  0E20  A5 5C             LDA     ERRCNT+1
 1241  0E22  D0 3D             BNE     NOPRT
 1242  0E24  A9 20             LDA     #' '
 1243  0E26  85 5D             STA     PRTERR
 1244  0E28  20 65 12          JSR     OUTPUT
 1245  0E2B  38                SEC
 1246  0E2C  A5 6D             LDA     TDATA
 1247  0E2E  E9 3F             SBC     #<BUFFER
 1248  0E30  AA                TAX
 1249  0E31  A5 6E             LDA     TDATA+1
 1250  0E33  E9 15             SBC     #>BUFFER        
 1251  0E35  20 54 08          JSR     PrDec4Dig
 1252  0E38  A9 20             LDA     #' '
 1253  0E3A  20 65 12          JSR     OUTPUT
 1254  0E3D  A0 00             LDY     #0
 1255  0E3F  B1 6D             LDA     (TDATA),Y       ; Good value
 1256  0E41  20 F6 0F          JSR     PHEXA
 1257  0E44  A9 20             LDA     #' '
 1258  0E46  20 65 12          JSR     OUTPUT
 1259  0E49  C8                INY
 1260  0E4A  B1 6F             LDA     (TDATA2),Y      ; Bad value
 1261  0E4C  88                DEY
 1262  0E4D  20 F6 0F          JSR     PHEXA
 1263  0E50  A2 20             LDX     #' '
 1264  0E52  A9 40             LDA     #$40
 1265  0E54  31 6F             AND     (TDATA2),Y
 1266  0E56  F0 02             BEQ     *+4
 1267  0E58  A2 50             LDX     #'P'            ; Parity error
 1268  0E5A  8A                TXA
 1269  0E5B  20 65 12          JSR     OUTPUT
 1270  0E5E  4C AF 0D          JMP     RCONT
 1271  0E61            NOPRT
 1272  0E61  4C AF 0D          JMP     RCONT
 1273                          
 1274  0E64            INDEXERR
 1275                          ; Found index before we wrote all our data
 1276  0E64  A9 83             LDA     #$83
 1277  0E66  0D 02 C0          ORA     DDPIA+2 ; Unload head, turn off write and erase
 1278  0E69  8D 02 C0          STA     DDPIA+2
 1279  0E6C  20 CC 0F          JSR     PRINT
 1280  0E6F  0D 0A             .BYTE   CR,LF
 1281  0E71  49 4E 44          .BYTE   'INDEX ACTIVE DURING WRITE, BYTES LEFT: ',0
       0E74  45 58 20  
       0E77  41 43 54  
       0E7A  49 56 45  
       0E7D  20 44 55  
       0E80  52 49 4E  
       0E83  47 20 57  
       0E86  52 49 54  
       0E89  45 2C 20  
       0E8C  42 59 54  
       0E8F  45 53 20  
       0E92  4C 45 46  
       0E95  54 3A 20  
       0E98  00        
 1282  0E99  38                SEC
 1283  0E9A  A9 00             LDA     #0
 1284  0E9C  E5 66             SBC     BYTECNTR
 1285  0E9E  AA                TAX
 1286  0E9F  A9 00             LDA     #0
 1287  0EA1  E5 67             SBC     BYTECNTR+1      
 1288  0EA3  20 10 10          JSR     PDEC
 1289  0EA6  20 CC 0F          JSR     PRINT
 1290  0EA9  0D 0A 00          .BYTE   CR,LF,0
 1291  0EAC  20 27 10          JSR     ANYKEY
 1292  0EAF  4C A1 03          JMP     TOP
 1293                          
 1294  0EB2            NOTRK
 1295  0EB2  20 E9 0E          JSR     INITPIA
 1296  0EB5  20 CC 0F          JSR     PRINT
 1297  0EB8  0D 0A 0D          .BYTE CR,LF,CR,LF, 'ERROR Seeking Track 0',0
       0EBB  0A 45 52  
       0EBE  52 4F 52  
       0EC1  20 53 65  
       0EC4  65 6B 69  
       0EC7  6E 67 20  
       0ECA  54 72 61  
       0ECD  63 6B 20  
       0ED0  30 00     
 1298  0ED2  20 27 10          JSR     ANYKEY
 1299  0ED5  4C A1 03          JMP     TOP     
 1300                  
 1301                  ; RESET BUFFER POINTERS
 1302  0ED8            RESPTR  
 1303  0ED8  A9 3F             LDA     #<BUFFER
 1304  0EDA  85 6D             STA     TDATA
 1305  0EDC  A9 15             LDA     #>BUFFER
 1306  0EDE  85 6E             STA     TDATA+1
 1307  0EE0  A9 4F             LDA     #<BUFFER2
 1308  0EE2  85 6F             STA     TDATA2
 1309  0EE4  A9 23             LDA     #>BUFFER2
 1310  0EE6  85 70             STA     TDATA2+1
 1311                  
 1312  0EE8  60                RTS
 1313                  
 1314                  ; INIT DISK CONTROLLER PIA
 1315  0EE9            INITPIA 
 1316  0EE9  A0 00             LDY     #0
 1317  0EEB  A9 40             LDA     #$40
 1318  0EED  8C 01 C0          STY     DDPIA+1 ; SELECT DDRA
 1319  0EF0  8D 00 C0          STA     DDPIA   ; SET PORTA TO ALL INPUTS except PA6
 1320  0EF3  A2 04             LDX     #4              ; 0000 0100
 1321  0EF5  8E 01 C0          STX     DDPIA+1 ; SELECT PORTA
 1322  0EF8  8D 00 C0          STA     DDPIA    ; SET PB6 HIGH
 1323  0EFB  8C 03 C0          STY     DDPIA+3 ; SELECT DDRB
 1324  0EFE  88                DEY
 1325  0EFF  8C 02 C0          STY     DDPIA+2 ; SET PORTB TO ALL OUTPUTS
 1326  0F02  8E 03 C0          STX     DDPIA+3 ; SELECT PORTB
 1327  0F05  8C 02 C0          STY     DDPIA+2 ; SET PORTB OUTPUTS HIGH
 1328  0F08  60                RTS
 1329                  
 1330                  
 1331                  ;SELECT DRIVE PB5 PA6  DRIVE (1-4)
 1332                  ;              0   0    #4
 1333                  ;              0   1    #3
 1334                  ;              1   0    #2
 1335                  ;              1   1    #1
 1336                  
 1337  0F09            SELDRV
 1338  0F09  A5 2D             LDA     DRVNUM
 1339  0F0B  4A                LSR     A
 1340  0F0C  A8                TAY
 1341  0F0D  90 03             BCC     *+5
 1342  0F0F  A9 00             LDA     #$00
 1343  0F11  2C A9 40          BIT     $40A9   ; This is LDA #$40 if BCC branches
 1344  0F14  8D 00 C0          STA     DDPIA   ; This is A/B select in port A
 1345  0F17  AD 02 C0          LDA     DDPIA+2
 1346  0F1A  09 20             ORA     #$20
 1347  0F1C  C0 01             CPY     #$01
 1348  0F1E  90 02             BCC     *+4
 1349  0F20  29 DF             AND     #$DF
 1350  0F22  8D 02 C0          STA     DDPIA+2 ; This is master select in port B
 1351  0F25  60                RTS
 1352                  
 1353                  
 1354                  ; STEP TO TRACK 0. Carry clear if no error. A modified. TRK set to 0
 1355                  ; if no error.
 1356                  
 1357  0F26            TZERO
 1358  0F26  A5 2A             LDA     MAXTRK  ;max num tracks
 1359  0F28  69 08             ADC     #$08    ;plus a few more
 1360  0F2A  85 2F             STA     TMP             ;MAX times to step before abort
 1361  0F2C  AD 02 C0          LDA     DDPIA+2
 1362  0F2F  29 FB             AND     #$FB    ; 1111 1011
 1363  0F31  D0 1B             BNE     TZERO3  ; DIR=INWARDS, start with one step away from track 0
 1364                  
 1365  0F33            TZERO1
 1366  0F33  C6 2F             DEC     TMP
 1367  0F35  D0 02             BNE     TZERO5
 1368  0F37  38                SEC
 1369  0F38  60                RTS
 1370  0F39            TZERO5  
 1371  0F39  A9 02             LDA     #2              ; 0000 0010
 1372  0F3B  2C 00 C0          BIT     DDPIA   ; TEST 'TRK0' PIN
 1373  0F3E  D0 09             BNE     TZERO2  ; AT TRACK 0
 1374  0F40  A9 00             LDA     #0
 1375  0F42  85 2E             STA     TRK
 1376  0F44  20 AC 0F          JSR     REDWR
 1377  0F47  18                CLC
 1378  0F48  60                RTS
 1379                  
 1380  0F49            TZERO2  
 1381  0F49  AD 02 C0          LDA     DDPIA+2 ; DIR=OUTWARDS (TO TRK0)
 1382  0F4C  09 04             ORA     #$04
 1383  0F4E            TZERO3  
 1384  0F4E  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1385  0F51  20 C8 0F          JSR     DELAY2
 1386  0F54  29 F7             AND     #$F7    ; 1111 0111
 1387  0F56  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN LOW
 1388  0F59  20 C8 0F          JSR     DELAY2
 1389  0F5C  09 08             ORA     #8              ; 0000 1000
 1390  0F5E  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN HIGH
 1391  0F61  A2 20             LDX     #32     ; 40 MS
 1392  0F63  20 BD 0F          JSR     DELAY
 1393  0F66  F0 CB             BEQ     TZERO1  ; ALWAYS
 1394                  
 1395                  ; STEP TO PREVIOUS TRACK
 1396  0F68            TPREV
 1397  0F68  AD 02 C0          LDA     DDPIA+2 ; DIR=(TO TRK0)
 1398  0F6B  09 04             ORA     #$04
 1399  0F6D  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1400  0F70  20 C8 0F          JSR     DELAY2
 1401  0F73  29 F7             AND     #$F7    ; 1111 0111
 1402  0F75  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN LOW
 1403  0F78  20 C8 0F          JSR     DELAY2
 1404  0F7B  09 08             ORA     #8              ; 0000 1000
 1405  0F7D  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN HIGH
 1406  0F80  C6 2E             DEC     TRK
 1407  0F82  20 AC 0F          JSR     REDWR   ; Set reduced write current
 1408  0F85  A2 20             LDX     #32     ; 40 MS
 1409  0F87  4C BD 0F          JMP     DELAY
 1410                  
 1411                  ; STEP TO NEXT TRACK
 1412                  
 1413  0F8A            TNEXT   
 1414  0F8A  AD 02 C0          LDA     DDPIA+2
 1415  0F8D  29 FB             AND     #$FB    ; 1111 1011
 1416                                                  ; DIR=INWARDS
 1417  0F8F  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1418  0F92  20 C8 0F          JSR     DELAY2
 1419  0F95  29 F7             AND     #$F7    ; 1111 0111
 1420  0F97  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' LOW
 1421  0F9A  20 C8 0F          JSR     DELAY2
 1422  0F9D  09 08             ORA     #8              ; 0000 1000
 1423  0F9F  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' HIGH
 1424  0FA2  E6 2E             INC     TRK
 1425  0FA4  20 AC 0F          JSR     REDWR   ; Set reduced write current
 1426  0FA7  A2 20             LDX     #32         ; 40MS
 1427  0FA9  4C BD 0F          JMP     DELAY
 1428                  
 1429                          ; Set reduced write current
 1430  0FAC            REDWR
 1431  0FAC  A5 2E             LDA     TRK
 1432  0FAE  C9 2B             CMP     #43     ; Is track >= 43
 1433  0FB0  AD 02 C0          LDA     DDPIA+2
 1434  0FB3  29 BF             AND     #$BF    ; Set low current active
 1435  0FB5  B0 02             BCS     SETLO   ; Yes
 1436  0FB7  09 40             ORA     #$40    ; Set low current inactive
 1437  0FB9            SETLO
 1438  0FB9  8D 02 C0          STA     DDPIA+2
 1439  0FBC  60                RTS
 1440                  
 1441                  ; DELAY 1.25MS PER LOOP at 1 MHz clock. X,Y modified
 1442                  
 1443  0FBD            DELAY   
 1444  0FBD  A0 F8             LDY     #$F8
 1445  0FBF            DELAY1  
 1446  0FBF  88                DEY
 1447  0FC0  D0 FD             BNE     DELAY1
 1448  0FC2  55 FF             EOR     $FF,X
 1449  0FC4  CA                DEX
 1450  0FC5  D0 F6             BNE     DELAY
 1451  0FC7  60                RTS
 1452                  
 1453  0FC8            DELAY2  
 1454  0FC8  20 CB 0F          JSR     DELAY21
 1455  0FCB            DELAY21 
 1456  0FCB  60                RTS
 1457                  
 1458                  
 1459                  ; PRINT IN-LINE STRING. Y and A modified
 1460                  
 1461  0FCC            PRINT   
 1462  0FCC  68                PLA
 1463  0FCD  85 6B             STA     PTRSTOR
 1464  0FCF  68                PLA
 1465  0FD0  85 6C             STA     PTRSTOR+1
 1466  0FD2  A0 01             LDY     #1
 1467  0FD4            PRINT1  
 1468  0FD4  B1 6B             LDA     (PTRSTOR),Y
 1469  0FD6  F0 0A             BEQ     PRINT2
 1470  0FD8  20 65 12          JSR     OUTPUT
 1471  0FDB  C8                INY
 1472  0FDC  D0 F6             BNE     PRINT1
 1473  0FDE  E6 6C             INC     PTRSTOR+1
 1474  0FE0  D0 F2             BNE     PRINT1
 1475  0FE2            PRINT2  
 1476  0FE2  98                TYA
 1477  0FE3  38                SEC
 1478  0FE4  65 6B             ADC     PTRSTOR
 1479  0FE6  A4 6B             LDY     PTRSTOR
 1480  0FE8  85 6B             STA     PTRSTOR
 1481  0FEA  90 02             BCC     PRINT3
 1482  0FEC  E6 6C             INC     PTRSTOR+1
 1483  0FEE            PRINT3
 1484  0FEE  18                CLC
 1485  0FEF  6C 6B 00          JMP     (PTRSTOR)
 1486                  
 1487                  ; PRINT HEX WORD (A,X). ONLY CHANGES A
 1488                  
 1489  0FF2            PHEX    
 1490  0FF2  20 F6 0F          JSR     PHEXA
 1491  0FF5  8A                TXA
 1492                  
 1493                  ; PRINT HEX BYTE (A)
 1494  0FF6            PHEXA   
 1495  0FF6  48                PHA
 1496  0FF7  4A                LSR     A
 1497  0FF8  4A                LSR     A
 1498  0FF9  4A                LSR     A
 1499  0FFA  4A                LSR     A
 1500  0FFB  20 FF 0F          JSR     PHEXA1
 1501  0FFE  68                PLA
 1502  0FFF            PHEXA1  
 1503  0FFF  29 0F             AND     #$F
 1504  1001  09 30             ORA     #'0'
 1505  1003  C9 3A             CMP     #'9'+1
 1506  1005  30 03             BMI     PHEXA2
 1507  1007  18                CLC
 1508  1008  69 07             ADC     #7
 1509  100A            PHEXA2  
 1510  100A  4C 65 12          JMP     OUTPUT
 1511                  
 1512                  ; PRINT DECIMAL (A)
 1513  100D            PDECA   
 1514  100D  AA                TAX
 1515  100E  A9 00             LDA     #0
 1516                  
 1517                  ; PRINT DECIMAL (A,X). CHANGES A,X,Y. Prints with no leading space
 1518                  
 1519  1010            PDEC    
 1520  1010  86 44             STX num
 1521  1012  85 45             STA num+1
 1522  1014  A9 00             LDA #0
 1523  1016  85 5A             STA pad
 1524  1018  A0 06             LDY #6  ; 4 digits max
 1525  101A  4C 63 08          JMP PrDec16Lp1
 1526                  
 1527  101D            CRLF    
 1528  101D  A9 0D             LDA     #CR
 1529  101F  20 65 12          JSR     OUTPUT
 1530  1022  A9 0A             LDA     #LF
 1531  1024  4C 65 12          JMP     OUTPUT
 1532                  
 1533  1027            ANYKEY  
 1534  1027  20 1C 12          JSR     Get_Chr
 1535  102A  20 CC 0F          JSR     PRINT
 1536  102D  0D 0A             .BYTE   CR,LF
 1537  102F  50 52 45          .BYTE   'PRESS ANY KEY WHEN READY >',0
       1032  53 53 20  
       1035  41 4E 59  
       1038  20 4B 45  
       103B  59 20 57  
       103E  48 45 4E  
       1041  20 52 45  
       1044  41 44 59  
       1047  20 3E 00  
 1538  104A  20 34 12          JSR     INKEY
 1539  104D  48                PHA
 1540  104E  20 CC 0F          JSR     PRINT
 1541  1051  0D 0A 00          .BYTE   CR,LF,0
 1542  1054  68                PLA
 1543  1055  60                RTS
 1544                  
 1545  1056            DRWMENU
 1546  1056  20 CC 0F           JSR PRINT
 1547  1059  0D 0A 0D          .BYTE $D,$A,$D,$A
       105C  0A        
 1548  105D  20 4F 53          .BYTE ' OSI DESTRUCTIVE Disk Test',$D,$A          
       1060  49 20 44  
       1063  45 53 54  
       1066  52 55 43  
       1069  54 49 56  
       106C  45 20 44  
       106F  69 73 6B  
       1072  20 54 65  
       1075  73 74 0D  
       1078  0A        
 1549  1079  2D 2D 2D          .BYTE '--------------------------',$D,$A          
       107C  2D 2D 2D  
       107F  2D 2D 2D  
       1082  2D 2D 2D  
       1085  2D 2D 2D  
       1088  2D 2D 2D  
       108B  2D 2D 2D  
       108E  2D 2D 2D  
       1091  2D 2D 0D  
       1094  0A        
 1550  1095  31 2E 20          .BYTE '1. Test Disk',$D,$A
       1098  54 65 73  
       109B  74 20 44  
       109E  69 73 6B  
       10A1  0D 0A     
 1551  10A3  32 2E 20          .BYTE '2. Test Track',$D,$A
       10A6  54 65 73  
       10A9  74 20 54  
       10AC  72 61 63  
       10AF  6B 0D 0A  
 1552  10B2  33 2E 20          .BYTE '3. Select Drive',$D,$A      
       10B5  53 65 6C  
       10B8  65 63 74  
       10BB  20 44 72  
       10BE  69 76 65  
       10C1  0D 0A     
 1553  10C3  34 2E 20          .BYTE '4. Set Drive Type',$D,$A      
       10C6  53 65 74  
       10C9  20 44 72  
       10CC  69 76 65  
       10CF  20 54 79  
       10D2  70 65 0D  
       10D5  0A        
 1554  10D6  35 2E 20          .BYTE '5. Set Pattern and passes',$D,$A
       10D9  53 65 74  
       10DC  20 50 61  
       10DF  74 74 65  
       10E2  72 6E 20  
       10E5  61 6E 64  
       10E8  20 70 61  
       10EB  73 73 65  
       10EE  73 0D 0A  
 1555  10F1  36 2E 20          .BYTE '6. Toggle read only',$D,$A
       10F4  54 6F 67  
       10F7  67 6C 65  
       10FA  20 72 65  
       10FD  61 64 20  
       1100  6F 6E 6C  
       1103  79 0D 0A  
 1556  1106  37 2E 20          .BYTE '7. RPM Test',$D,$A 
       1109  52 50 4D  
       110C  20 54 65  
       110F  73 74 0D  
       1112  0A        
 1557  1113  38 2E 20          .BYTE '8. Status screen',$D,$A 
       1116  53 74 61  
       1119  74 75 73  
       111C  20 73 63  
       111F  72 65 65  
       1122  6E 0D 0A  
 1558  1125  39 2E 20          .BYTE '9. Exit',$D,$A          
       1128  45 78 69  
       112B  74 0D 0A  
 1559  112E  0D 0A             .BYTE $D,$A
 1560  1130  44 72 76          .BYTE 'Drv=',$0
       1133  3D 00     
 1561  1135  A5 2D             LDA DRVNUM
 1562  1137  18                CLC
 1563  1138  69 41             ADC #$41
 1564  113A  20 65 12          JSR OUTPUT
 1565  113D  A5 2B             LDA MAXPAG
 1566  113F  C9 0F             CMP #MAXPAG8
 1567  1141  F0 0C             BEQ DRWMN1
 1568  1143  20 CC 0F          JSR PRINT
 1569  1146  2F 35 2E          .BYTE '/5.25 ',0
       1149  32 35 20  
       114C  00        
 1570  114D  90 07             BCC DRWMN2
 1571  114F            DRWMN1
 1572  114F  20 CC 0F          JSR PRINT
 1573  1152  2F 38 20          .BYTE '/8 ',0
       1155  00        
 1574  1156            DRWMN2
 1575  1156  A5 33             LDA PATSEL
 1576  1158  D0 15             BNE DRWMN3
 1577  115A  20 CC 0F          JSR PRINT
 1578  115D  50 61 74          .BYTE 'Pattern $',0
       1160  74 65 72  
       1163  6E 20 24  
       1166  00        
 1579  1167  A5 34             LDA PATVAL
 1580  1169  20 F6 0F          JSR PHEXA
 1581  116C  4C 81 11          JMP DRWMN4
 1582  116F            DRWMN3
 1583  116F  20 CC 0F          JSR PRINT
 1584  1172  50 61 74          .BYTE 'Pattern random',0
       1175  74 65 72  
       1178  6E 20 72  
       117B  61 6E 64  
       117E  6F 6D 00  
 1585  1181            DRWMN4
 1586  1181  20 CC 0F          JSR PRINT
 1587  1184  20 20 50          .BYTE '  Passes ',0
       1187  61 73 73  
       118A  65 73 20  
       118D  00        
 1588  118E  A5 35             LDA PASSES
 1589  1190  20 0D 10          JSR PDECA
 1590  1193  A5 69             LDA TESTTYPE
 1591  1195  F0 12             BEQ NORMTEST
 1592  1197  20 CC 0F          JSR PRINT
 1593  119A  20 53 63          .BYTE ' Scope test',0
       119D  6F 70 65  
       11A0  20 74 65  
       11A3  73 74 00  
 1594  11A6  4C B9 11          JMP RWRO
 1595  11A9            NORMTEST
 1596  11A9  20 CC 0F          JSR PRINT
 1597  11AC  20 4E 6F          .BYTE ' Normal test',0
       11AF  72 6D 61  
       11B2  6C 20 74  
       11B5  65 73 74  
       11B8  00        
 1598  11B9            RWRO
 1599  11B9  A5 36             LDA READONLY
 1600  11BB  F0 11             BEQ RW
 1601  11BD  20 CC 0F          JSR PRINT
 1602  11C0  20 52 65          .BYTE ' Read only',0
       11C3  61 64 20  
       11C6  6F 6E 6C  
       11C9  79 00     
 1603  11CB  4C D6 11          JMP PPROMPT
 1604  11CE            RW
 1605  11CE  20 CC 0F          JSR PRINT
 1606  11D1  20 52 2F          .BYTE ' R/W',0
       11D4  57 00     
 1607  11D6            PPROMPT
 1608  11D6  20 CC 0F          JSR PRINT
 1609  11D9  20 3E 20          .BYTE ' > ',0
       11DC  00        
 1610  11DD  60                RTS
 1611                  
 1612                          ; Get key from polled key without waiting. Carry clear if no key
 1613                          ; Key returned in A. X,Y modified
 1614  11DE            Get_Chr_Polled
 1615  11DE  20 EF 11          JSR Check_Keypress      ;any pressed keys?
 1616  11E1  90 37             BCC NOKEY               ;no, dont get stuxk in keypoller
 1617  11E3  20 ED FE          JSR $FEED               ;yes - check keypoller
 1618  11E6  48                PHA
 1619  11E7            UNKEY
 1620  11E7  20 EF 11          JSR Check_Keypress  ;wait till key unpressed to prevent getting stuck in poller
 1621  11EA  B0 FB             BCS UNKEY
 1622  11EC  68                PLA
 1623  11ED            HAVEKEY
 1624  11ED  38                SEC
 1625  11EE  60                RTS
 1626                  
 1627  11EF            Check_Keypress
 1628  11EF  A9 3E             LDA #$3E    ;want rows 5,4,3,2,1 tested (most alpha keys)
 1629  11F1  45 31             EOR INVKEYB
 1630  11F3  8D 00 DF          STA $DF00       ; Select row
 1631  11F6  8D 00 DF          STA $DF00       ; In case some time needed for signals to propagate
 1632  11F9  AD 00 DF          LDA $DF00
 1633  11FC  45 31             EOR INVKEYB ;C1 keyboard inverted
 1634  11FE  48                PHA
 1635  11FF  A9 00             LDA #$00        ;selected all rows
 1636  1201  45 31             EOR INVKEYB
 1637  1203  8D 00 DF          STA $DF00
 1638  1206  68                PLA
 1639  1207  F0 11             BEQ NOKEY       ; bail if no key pressed
 1640  1209  A0 07             LDY #$07        ; count bits 7 to 1
 1641  120B  A2 00             LDX #$00
 1642  120D            DEKEY
 1643  120D  0A                ASL A
 1644  120E  90 01             BCC *+3
 1645  1210  E8                INX
 1646  1211  88                DEY
 1647  1212  D0 F9             BNE DEKEY
 1648  1214  E0 01             CPX #$01        ;x has # cols pressed
 1649  1216  D0 02             BNE NOKEY       ;more than one or none = nokey
 1650  1218  38                SEC 
 1651  1219  60                RTS
 1652  121A            NOKEY
 1653  121A  18                CLC
 1654  121B  60                RTS     
 1655                  
 1656  121C            Get_Chr
 1657  121C            FRACIANW  ; read from ACIA no wait      carry clear when no data
 1658  121C  24 30             BIT MACHINE
 1659  121E  30 0A             BMI FRAC1NW
 1660  1220  AD 00 FC          LDA C2ACIA
 1661  1223  4A                LSR A
 1662  1224  90 03             BCC FRAC1NW-1
 1663  1226  AD 01 FC          LDA C2ACIA+1
 1664  1229  60                RTS
 1665  122A            FRAC1NW
 1666  122A  AD 00 F0          LDA C1ACIA
 1667  122D  4A                LSR A    
 1668  122E  90 F9             BCC FRAC1NW-1 
 1669  1230  AD 01 F0          LDA C1ACIA+1
 1670  1233  60                RTS
 1671                  
 1672                          ; Get key from serial or polled keyboard waiting for key.
 1673  1234            INKEY
 1674  1234  24 32             BIT VIDEO
 1675  1236  10 03             BPL *+5         ; No
 1676  1238  4C ED FE          JMP $FEED       ; Polled keyboard
 1677  123B            FRACIA           ;read from ACIA carry set on abort return value in A
 1678  123B  24 30             BIT MACHINE
 1679  123D  30 0B             BMI FRAC1
 1680  123F            FRSER                   ; read from C3
 1681  123F  AD 00 FC          LDA C2ACIA
 1682  1242  4A                LSR A    
 1683  1243  90 FA             BCC FRSER 
 1684  1245  AD 01 FC          LDA C2ACIA+1
 1685  1248  18                CLC      
 1686  1249            ACIARET
 1687  1249  60                RTS
 1688  124A            FRAC1                   ;read from C1
 1689  124A  AD 00 F0          LDA C1ACIA
 1690  124D  4A                LSR A    
 1691  124E  90 FA             BCC FRAC1 
 1692  1250  AD 01 F0          LDA C1ACIA+1
 1693  1253  18                CLC       
 1694  1254  60                RTS
 1695                  
 1696                          ; Check if TX ready bit is set for serial. Carry set if ready
 1697  1255            CheckTXReady
 1698  1255  24 30             BIT MACHINE
 1699  1257  30 06             BMI TOAC1B
 1700  1259  AD 00 FC          LDA C2ACIA   ;wait for TxEmpty
 1701  125C  4A                LSR A     
 1702  125D  4A                LSR A     
 1703  125E  60                RTS     ; Carry set if TX ready
 1704  125F            TOAC1B
 1705  125F  AD 00 F0          LDA C1ACIA 
 1706  1262  4A                LSR A     
 1707  1263  4A                LSR A     
 1708  1264  60                RTS     ; Carry set if TX ready
 1709                  
 1710                          ; Write a character to serial or video. A modified
 1711  1265            OUTPUT
 1712  1265  24 32             BIT VIDEO
 1713  1267  10 03             BPL TOACIA      ; No, not video system
 1714  1269  4C E0 12          JMP VIDOUT
 1715  126C            TOACIA
 1716  126C  48                PHA
 1717  126D  24 30             BIT MACHINE
 1718  126F  30 0C             BMI TOAC1
 1719  1271            TOACIA1        
 1720  1271  AD 00 FC          LDA C2ACIA   ;wait for TxEmpty
 1721  1274  4A                LSR A     
 1722  1275  4A                LSR A     
 1723  1276  90 F9             BCC TOACIA1   
 1724  1278  68                PLA       
 1725  1279  8D 01 FC          STA C2ACIA+1 
 1726  127C  60                RTS       
 1727  127D            TOAC1
 1728  127D  AD 00 F0          LDA C1ACIA 
 1729  1280  4A                LSR A     
 1730  1281  4A                LSR A     
 1731  1282  90 F9             BCC TOAC1   
 1732  1284  68                PLA       
 1733  1285  8D 01 F0          STA C1ACIA+1 
 1734  1288  60                RTS 
 1735                  
 1736                          ; Video output routine
 1737                          ; video init for SYN600, SYNMON, CEGMON
 1738                          ; $FFE0 - cursor start
 1739                          ; $FFE1 - line len-1   (wrap position)
 1740                          ; $FFE2 - 00 = 1K vid, 01=2K vid otherwise serial or other ROM
 1741                          ; FFE0 65, 17, 00 (c1 ROM, cegmon)
 1742                          ; FFE0 40, 3F, 01 (c2 ROM)
 1743                          ; FFE0 4D, 2F, 01 (C1E cegmon 64x32)
 1744  1289            VIDINIT
 1745  1289  A9 00             LDA #$00
 1746  128B  85 75             STA VIDOFFSET
 1747  128D  85 73             STA VIDDST
 1748  128F  AE E2 FF          LDX $FFE2
 1749  1292  F0 1A             BEQ C1VID ;1k screen
 1750  1294  CA                DEX
 1751  1295  F0 11             BEQ C2VID
 1752                          
 1753                  
 1754  1297            WHATVID ;assume C2-like video
 1755  1297  A9 00             LDA #$00
 1756  1299  8D 00 13          STA VIDCR+1 ;cursor start
 1757  129C  85 75             STA VIDOFFSET
 1758  129E  A9 40             LDA #$40        ;linelen
 1759  12A0  85 77             STA VIDXMAX
 1760  12A2  A2 D7             LDX #$D7    ;bottom line hi
 1761  12A4  A0 80             LDY #$80    ;bottom line low
 1762  12A6  D0 21             BNE VIDINI2
 1763                          
 1764  12A8            C2VID                   ;C2VID  2k screen
 1765  12A8  A9 40             LDA #$40        ;linelen
 1766  12AA  A2 D7             LDX #$D7    ;bottom line hi
 1767  12AC  D0 04             BNE VIDINI1
 1768                          
 1769                          
 1770  12AE            C1VID   ;C1VID  1K screen
 1771  12AE  A9 20             LDA #$20
 1772  12B0  A2 D3             LDX #$D3
 1773                  
 1774  12B2            VIDINI1 ;read video settings from ROM
 1775  12B2  48                PHA     
 1776  12B3  AD E0 FF          LDA $FFE0
 1777  12B6  A8                TAY
 1778  12B7  29 0F             AND #$0F
 1779  12B9  8D 00 13          STA VIDCR+1 ;cursor start
 1780  12BC  38                SEC
 1781  12BD  6D E1 FF          ADC $FFE1
 1782  12C0  85 77             STA VIDXMAX
 1783  12C2  98                TYA
 1784  12C3  29 F0             AND #$F0
 1785  12C5  A8                TAY         ;bottom line low
 1786  12C6  85 75             STA VIDOFFSET
 1787  12C8  68                PLA
 1788                  
 1789  12C9            VIDINI2 
 1790                  
 1791  12C9  85 76             STA VIDXLEN
 1792  12CB  85 71             STA VIDSRC
 1793                  
 1794  12CD  8E 43 13          STX VIDCLR+2  ;D3E0 or D780
 1795  12D0  8C 42 13          STY VIDCLR+1  
 1796  12D3  8E EE 12          STX VIDFIX1+1 ;D3E0 or D780
 1797  12D6  8C ED 12          STY VIDFIX1
 1798  12D9  A9 D0             LDA #$D0
 1799  12DB  85 72             STA VIDSRC+1  ;init to D040 or D020
 1800  12DD  85 74             STA VIDDST+1  ;init to D000
 1801  12DF  60                RTS
 1802                          
 1803  12E0            VIDOUT
 1804  12E0  84 68             STY YHOLD 
 1805  12E2  C9 0D             CMP #CR
 1806  12E4  F0 19             BEQ VIDCR
 1807  12E6  C9 0A             CMP #LF
 1808  12E8  F0 1A             BEQ VIDLF
 1809  12EA  A4 75             LDY VIDOFFSET
 1810  12ED            VIDFIX1=*+1
 1811  12EC  99 C0 D6          STA $D6C0,Y
 1812  12EF  C8                INY
 1813  12F0  84 75             STY VIDOFFSET
 1814  12F2  C4 77             CPY VIDXMAX
 1815  12F4  D0 06             BNE VIDRETY
 1816  12F6  20 FF 12          JSR VIDCR
 1817  12F9  4C 04 13          JMP VIDLF
 1818  12FC            VIDRETY
 1819  12FC  A4 68             LDY YHOLD
 1820  12FE  60                RTS
 1821  12FF            VIDCR
 1822  12FF  A9 00             LDA #0
 1823  1301  85 75             STA VIDOFFSET
 1824  1303  60                RTS
 1825                  
 1826  1304            VIDLF
 1827  1304  A0 00             LDY #$00
 1828  1306            VIDLF1
 1829  1306  B1 71             LDA (VIDSRC),Y  ;copy row by row
 1830  1308  91 73             STA (VIDDST),Y
 1831  130A  C8                INY
 1832  130B  C4 76             CPY VIDXLEN
 1833  130D  D0 F7             BNE VIDLF1
 1834  130F  98                TYA
 1835  1310  18                CLC
 1836  1311  65 71             ADC VIDSRC
 1837  1313  85 71             STA VIDSRC
 1838  1315  90 02             BCC VIDLF2
 1839  1317  E6 72             INC VIDSRC+1
 1840  1319            VIDLF2
 1841  1319  98                TYA
 1842  131A  18                CLC
 1843  131B  65 73             ADC VIDDST
 1844  131D  85 73             STA VIDDST
 1845  131F  90 02             BCC VIDLF3
 1846  1321  E6 74             INC VIDDST+1
 1847  1323            VIDLF3  
 1848                  
 1849  1323  A5 74             LDA VIDDST+1
 1850  1325  CD 43 13          CMP VIDCLR+2
 1851  1328  D0 DA             BNE VIDLF1-2
 1852  132A  A5 73             LDA VIDDST
 1853  132C  CD 42 13          CMP VIDCLR+1
 1854  132F  D0 D3             BNE VIDLF1-2
 1855                  
 1856  1331  A9 D0             LDA #$D0
 1857  1333  85 72             STA VIDSRC+1
 1858  1335  85 74             STA VIDDST+1
 1859  1337  A9 00             LDA #$00
 1860  1339  85 73             STA VIDDST
 1861  133B  A5 76             LDA VIDXLEN
 1862  133D  85 71             STA VIDSRC
 1863                  
 1864  133F  A9 20             LDA #' '
 1865  1341            VIDCLR
 1866  1341  99 C0 D6          STA $D6C0,Y     ; Clear last line
 1867  1344  C8                INY
 1868  1345  C4 76             CPY VIDXLEN
 1869  1347  D0 F8             BNE VIDCLR
 1870  1349  C8                INY
 1871  134A  4C FC 12          JMP VIDRETY
 1872                          
 1873                          
 1874                  
 1875                  ; Return an 8 bit "random" number in A
 1876                  ; X modified on return
 1877                  ; From http://forum.6502.org/viewtopic.php?f=2&t=5247 modified for better
 1878                  ; randomness
 1879  134D            RAND
 1880  134D  A5 3C             LDA RND+4       ; ADD B shifted, 
 1881  134F  38                SEC             ; carry adds value 0x80
 1882  1350  6A                ROR
 1883  1351  65 39             ADC RND+1       ; add last value (E)
 1884  1353  65 3D             ADC RND+5       ; add C
 1885  1355  85 38             STA RND         ; new number
 1886  1357  A2 04             LDX #4          ; move 5 numbers
 1887  1359            RPL
 1888  1359  B5 38             LDA RND,X
 1889  135B  95 39             STA RND+1,X     ; ..move over 1
 1890  135D  CA                DEX
 1891  135E  10 F9             BPL RPL         ; all moved?
 1892  1360  A5 38             LDA RND
 1893  1362  60                RTS
 1894                  
 1895                  ; From https://codebase64.org/doku.php?id=base:24bit_division_24-bit_result
 1896                  ; EXECUTES AN UNSIGNED INTEGER DIVISION OF A 24-BIT DIVIDEND BY A 24-BIT DIVISOR
 1897                  ; THE RESULT GOES TO DIVIDEND AND REMAINDER VARIABLES
 1898                  ;
 1899                  ; VERZ!!! 18-MAR-2017
 1900                  ; A, X, Y modified.
 1901                  
 1902  1363  A9 00     DIV24   LDA #0          ;PRESET REMAINDER TO 0
 1903  1365  85 4A             STA REMAINDER
 1904  1367  85 4B             STA REMAINDER+1
 1905  1369  85 4C             STA REMAINDER+2
 1906  136B  A2 18             LDX #24         ;REPEAT FOR EACH BIT: ...
 1907                  
 1908  136D  06 44     DIVLOOP ASL DIVIDEND    ;DIVIDEND LB & HB*2, MSB -> CARRY
 1909  136F  26 45             ROL DIVIDEND+1  
 1910  1371  26 46             ROL DIVIDEND+2
 1911  1373  26 4A             ROL REMAINDER   ;REMAINDER LB & HB * 2 + MSB FROM CARRY
 1912  1375  26 4B             ROL REMAINDER+1
 1913  1377  26 4C             ROL REMAINDER+2
 1914  1379  A5 4A             LDA REMAINDER
 1915  137B  38                SEC
 1916  137C  E5 47             SBC DIVISOR     ;SUBSTRACT DIVISOR TO SEE IF IT FITS IN
 1917  137E  A8                TAY             ;LB RESULT -> Y, FOR WE MAY NEED IT LATER
 1918  137F  A5 4B             LDA REMAINDER+1
 1919  1381  E5 48             SBC DIVISOR+1
 1920  1383  85 50             STA PZTEMP
 1921  1385  A5 4C             LDA REMAINDER+2
 1922  1387  E5 49             SBC DIVISOR+2
 1923  1389  90 0A             BCC SKIP        ;IF CARRY=0 THEN DIVISOR DIDN'T FIT IN YET
 1924                  
 1925  138B  85 4C             STA REMAINDER+2 ;ELSE SAVE SUBSTRACTION RESULT AS NEW REMAINDER,
 1926  138D  A5 50             LDA PZTEMP
 1927  138F  85 4B             STA REMAINDER+1
 1928  1391  84 4A             STY REMAINDER   
 1929  1393  E6 44             INC DIVIDEND    ;AND INCREMENT RESULT CAUSE DIVISOR FIT IN 1 TIMES
 1930                  
 1931  1395  CA        SKIP    DEX
 1932  1396  D0 D5             BNE DIVLOOP     
 1933  1398  60                RTS
 1934                  
 1935                  
 1936                  ; From https://codebase64.org/doku.php?id=base:24bit_multiplication_24bit_product
 1937                  ; Multiply REMAINDER by DIVIDEND with result in DIVIDEND
 1938  004A            factor1 = REMAINDER
 1939  0044            product = DIVIDEND
 1940  1399            MULT24
 1941  1399  A9 00             lda #$00                        ; set product to zero
 1942  139B  85 44             sta product
 1943  139D  85 45             sta product+1
 1944  139F  85 46             sta product+2
 1945                  
 1946  13A1            mloop
 1947  13A1  A5 4D             lda factor2                     ; while factor2 != 0
 1948  13A3  D0 09             bne nz
 1949  13A5  A5 4E             lda factor2+1
 1950  13A7  D0 05             bne nz
 1951  13A9  A5 4F             lda factor2+2
 1952  13AB  D0 01             bne nz
 1953  13AD  60                rts
 1954  13AE            nz
 1955  13AE  A5 4D             lda factor2                     ; if factor2 is odd
 1956  13B0  29 01             and #$01
 1957  13B2  F0 13             beq mskip
 1958                          
 1959  13B4  A5 4A             lda factor1                     ; product += factor1
 1960  13B6  18                clc
 1961  13B7  65 44             adc product
 1962  13B9  85 44             sta product
 1963                          
 1964  13BB  A5 4B             lda factor1+1
 1965  13BD  65 45             adc product+1
 1966  13BF  85 45             sta product+1
 1967                          
 1968  13C1  A5 4C             lda factor1+2
 1969  13C3  65 46             adc product+2
 1970  13C5  85 46             sta product+2                   ; end if
 1971                  
 1972  13C7            mskip
 1973  13C7  06 4A             asl factor1                     ; << factor1 
 1974  13C9  26 4B             rol factor1+1
 1975  13CB  26 4C             rol factor1+2
 1976  13CD  46 4F             lsr factor2+2                   ; >> factor2
 1977  13CF  66 4E             ror factor2+1
 1978  13D1  66 4D             ror factor2
 1979                  
 1980  13D3  4C A1 13          jmp mloop                       ; end while     
 1981                  
 1982                  ; Status screen for displaying drive inputs
 1983                  ;  Commands:
 1984                  ;  Z- Zero Head   U - Step Up  D - Step Down   E Exit
 1985                  ;  R - Read Trk(not implemented) H - load/unload head 
 1986                  ;  S - Select disk, W - Write
 1987                  ;
 1988  002F            LASTPIA = TMP ; need a storage location
 1989  13D6            STATSCRN
 1990  13D6  A9 AA             LDA #$AA
 1991  13D8  85 2F             STA LASTPIA
 1992  13DA  20 E9 0E          JSR INITPIA     ; Select disk
 1993  13DD  20 09 0F          JSR SELDRV
 1994  13E0  A9 20             LDA #$20        ; Turn master select back off
 1995  13E2  4D 02 C0          EOR DDPIA+2
 1996  13E5  8D 02 C0          STA DDPIA+2
 1997                          ; JSR PRINT
 1998                          ;.BYTE $1B,$48,$D,$A,0 ;escape codes to Home cursor no big deal if terminal doesn't respond correctl
 1999                  
 2000  13E8  20 CC 0F          JSR PRINT
 2001  13EB  0D 0A 0D          .BYTE $D,$A,$D,$A,'CMDS:(S)el (H)ead (W)rite Step:(U)p (D)own (Z)ero (E)xit',$D, $A
       13EE  0A 43 4D  
       13F1  44 53 3A  
       13F4  28 53 29  
       13F7  65 6C 20  
       13FA  28 48 29  
       13FD  65 61 64  
       1400  20 28 57  
       1403  29 72 69  
       1406  74 65 20  
       1409  53 74 65  
       140C  70 3A 28  
       140F  55 29 70  
       1412  20 28 44  
       1415  29 6F 77  
       1418  6E 20 28  
       141B  5A 29 65  
       141E  72 6F 20  
       1421  28 45 29  
       1424  78 69 74  
       1427  0D 0A     
 2002  1429  20 0D 0A          .BYTE ' ',$D, $A
 2003  142C  52 20 54          .BYTE 'R T F S R W S I',$D, $A
       142F  20 46 20  
       1432  53 20 52  
       1435  20 57 20  
       1438  53 20 49  
       143B  0D 0A     
 2004  143D  44 20 52          .BYTE 'D R A E D R e N',$D, $A
       1440  20 41 20  
       1443  45 20 44  
       1446  20 52 20  
       1449  65 20 4E  
       144C  0D 0A     
 2005  144E  59 20 4B          .BYTE 'Y K U C Y I l D',$D, $A
       1451  20 55 20  
       1454  43 20 59  
       1457  20 49 20  
       145A  6C 20 44  
       145D  0D 0A     
 2006  145F  31 20 30          .BYTE '1 0 L T 2 T 1 E',$D, $A
       1462  20 4C 20  
       1465  54 20 32  
       1468  20 54 20  
       146B  31 20 45  
       146E  0D 0A     
 2007  1470  20 20 20          .BYTE '    T     P   X',$D, $A
       1473  20 54 20  
       1476  20 20 20  
       1479  20 50 20  
       147C  20 20 58  
       147F  0D 0A     
 2008  1481  00                .BYTE 0
 2009                  
 2010  1482            STATSCR2
 2011  1482  AD 00 C0          LDA DDPIA
 2012  1485            STATSCR5
 2013  1485  85 2F             STA LASTPIA
 2014  1487  A2 08             LDX #$08
 2015  1489            STATSCR1
 2016  1489  4A                LSR A
 2017  148A  48                PHA
 2018  148B  90 01             BCC *+3
 2019  148D  A9 30             LDA #$30
 2020  148F  2C A9 31          BIT $31A9
 2021  1492  20 65 12          JSR OUTPUT
 2022  1495  A9 20             LDA #$20
 2023  1497  20 65 12          JSR OUTPUT
 2024  149A  68                PLA
 2025  149B  CA                DEX
 2026  149C  D0 EB             BNE STATSCR1
 2027  149E  20 CC 0F          JSR PRINT
 2028  14A1  20 54 52          .BYTE ' TRK ',0
       14A4  4B 20 00  
 2029  14A7  A5 2E             LDA TRK
 2030  14A9  20 45 08          JSR PrDec2Dig
 2031  14AC  A9 0D             LDA #$0D
 2032  14AE  20 65 12          JSR OUTPUT  ;keep redrawing current line- no LF
 2033  14B1            STATSCR4
 2034  14B1  24 32             BIT VIDEO
 2035  14B3  10 06             BPL STATSER     ; No
 2036  14B5  20 DE 11          JSR Get_Chr_Polled
 2037  14B8  4C BE 14          JMP *+6
 2038  14BB            STATSER
 2039  14BB  20 1C 12          JSR Get_Chr
 2040  14BE  B0 0A             BCS STATSCR3
 2041  14C0  AD 00 C0          LDA DDPIA
 2042  14C3  C5 2F             CMP LASTPIA
 2043  14C5  F0 EA             BEQ STATSCR4  ;no change, no update
 2044  14C7  4C 85 14          JMP STATSCR5
 2045  14CA            STATSCR3
 2046  14CA  29 5F             AND #$5F
 2047  14CC  AA                TAX
 2048                          ;CMP #'R     ; READ TRACK/Show Part
 2049                          ;BNE *+8
 2050                          ;JSR VIEWTRK
 2051                          ;JMP STATSCR2
 2052  14CD  E0 53             CPX #'S
 2053  14CF  D0 0B             BNE CHECKLOAD
 2054  14D1  A9 20             LDA #$20
 2055  14D3  4D 02 C0          EOR DDPIA+2
 2056  14D6  8D 02 C0          STA DDPIA+2
 2057  14D9  4C 82 14          JMP STATSCR2
 2058  14DC            CHECKLOAD
 2059  14DC  E0 48             CPX #'H
 2060  14DE  D0 0B             BNE CHKWRITE
 2061  14E0  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2062  14E3  49 80             EOR #$80        ; TOGGLE HEAD LOAD
 2063  14E5  8D 02 C0          STA DDPIA+2     
 2064  14E8  4C 82 14          JMP STATSCR2
 2065  14EB            CHKWRITE
 2066  14EB  E0 57             CPX #'W
 2067  14ED  D0 1C             BNE CHKEXIT
 2068  14EF  A9 20             LDA #$20
 2069  14F1  2C 02 C0          BIT DDPIA+2 ;TEST DRIVE SEL
 2070  14F4  F0 0A             BEQ WRITNOIDX
 2071  14F6  2C 00 C0          BIT DDPIA       ; WAIT 
 2072  14F9  30 FB             BMI *-3 ; INDEX PULSE
 2073  14FB  2C 00 C0          BIT DDPIA       ; WAIT END OF
 2074  14FE  10 FB             BPL *-3 ; INDEX PULSE
 2075  1500            WRITNOIDX
 2076  1500  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2077  1503  49 03             EOR #$03        ; TOGGLE WRITE AND ERASE ENABLE
 2078  1505  8D 02 C0          STA DDPIA+2     
 2079  1508  4C 82 14          JMP STATSCR2
 2080  150B            CHKEXIT
 2081  150B  E0 45             CPX #'E
 2082  150D  D0 0B             BNE CHKUP
 2083  150F  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2084  1512  09 A3             ORA #$A3        ; TURN OFF HEAD LOAD, SELECT, AND WRITE
 2085  1514  8D 02 C0          STA DDPIA+2     
 2086  1517  4C A1 03          JMP TOP
 2087                  
 2088  151A            CHKUP
 2089  151A  A9 20             LDA #$20
 2090  151C  2C 02 C0          BIT DDPIA+2
 2091  151F  F0 11             BEQ JSTATSCR2   ; Can't move head if drive not selected
 2092                  
 2093  1521  E0 55             CPX #'U
 2094  1523  D0 06             BNE *+8
 2095  1525  20 8A 0F          JSR TNEXT       ; STEP TO NEXT TRACK
 2096  1528  4C 82 14          JMP STATSCR2
 2097  152B  E0 44             CPX #'D
 2098  152D  D0 06             BNE *+8
 2099  152F  20 68 0F          JSR TPREV   ; STEP TO PREV TRACK
 2100  1532            JSTATSCR2
 2101  1532  4C 82 14          JMP STATSCR2
 2102  1535  E0 5A             CPX #'Z
 2103  1537  D0 03             BNE *+5
 2104  1539  20 26 0F          JSR TZERO    ; STEP TO TRACK 0
 2105  153C  4C 82 14          JMP STATSCR2
 2106                           
 2107                  
 2108                  ;VIEWTRK ;placeholder for View Track function   
 2109                  ;       RTS     
 2110  153F            BUFFER  =       *
 2111  153F            *=*+BYTES8 ;space for track buffer
 2112  234F            BUFFER2 =       *
 2113                  ;space for track buffer. We may write more data than this but will not
 2114                  ;use the extra data written. Don't put anything that can't be overwritten
 2115                  ;after this
 2116  234F            *=*+[BYTES8+BYTES8+2] 
 2117                  
 2118                  ;*=*+[MAXPAG8*2*256] ;space for track buffer
 2119                  
 2120  3F71            .END

Errors   = 0
Warnings = 0
