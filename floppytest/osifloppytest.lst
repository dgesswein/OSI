    1                  ;
    2                  ; DISK TEST UTILITY FOR C1P/UK101/C2PDF/C4PMF/C8P/C3-OEM
    3                  ; Supposed to work with serial or video and 8", 5.25", or 3.5" floppies. Tested
    4                  ; with C2 with 8" floppies, serial, and 540B video. Tested with OSI emulator
    5                  ; with 5.25" floppies.
    6                  ; Needs 16k memory.
    7                  ; Start at $300
    8                  ; Does write/read or read only test. Disk format is not compatible with
    9                  ; OSI operating systems. Can either print error information or generate
   10                  ; a pulse on fault reset to trigger scope on error. Can also show
   11                  ; drive status lines and allow manual control of drive control lines.
   12                  ; Will also measure drive RPM
   13                  ;
   14                  ; DESTRUCTIVE DISK READ/WRITE TEST
   15                  ; By David Gesswein djg@pdp8online.com
   16                  ; Initial release V1.00 05/04/2020
   17                  ; V1.04 12/28/2020. Fix from Mark Spankus to not check for polled keyboard
   18                  ;    on C3. Also some comment changes by DJG.
   19                  ; V1.03 07/18/2020. Experimental support for 3.5" drives from Jeff Tranter.
   20                  ; V1.02 05/28/2020. Fixes from Mark Spankus. Fixed W in status test hanging if
   21                  ;    drive not selected. Fixed C1 serial I/O code. Simplified code. Fixed
   22                  ;    polled keyboard code to work reliably on C1 and other machines. Fixed
   23                  ;    video to work with C1P though messages may not fit in 30 columns. Fixed
   24                  ;    video for SYNMON, SYN600, and CEGMON.
   25                  ; V1.01 05/16/2020. Fixed ANYKEY not aborting. Prevent specifying illegal
   26                  ;    track to test. Fixed printing false errors when no data read.
   27                  ;    Fixed issues with serial console getting selected on video system.
   28                  
   29                  ; All my changes are released as public domain. The original code did not have
   30                  ; any license specified.
   31                  ; For usage see http://www.pdp8online.com/osi/osi-floppy-test.shtml
   32                  
   33                  ;BASED ON https://osi.marks-lab.com/software/tools.html Universal OSIDump 
   34                  ;BASED ON ED'S OSIDUMP UTILITY
   35                  ;
   36                  ;
   37                  
   38                  ; OSI 505, 470 board I/O reference
   39                  ; C000-C003 = 6821 PIA (decoded to C000-C00F) (C000/C040/C080/C0C0)
   40                  ; C010-C011 = 6850 ACIA (Decode to C010-C01F) (C010/C050/C090/C0D0)
   41                  ; C020-C03F = NULLREAD (C020/C060/C0A0/C0E0)
   42                  ;   6821 PIA registers 
   43                  ; C000 = PORT A or DDR A
   44                  ; C001 = Control Reg A
   45                  ; C002 = PORT B or DDR B
   46                  ; C003 = Control Reg B
   47                  ;   6850 ACIA registers
   48                  ; C010 = Serial data
   49                  ; C011 = Serial Control
   50                  
   51                  ; "->" = output, "<-" = input
   52                  ; PIA 6821 @ $C000+
   53                  ; port A
   54                  ; PA0 <- !Drive 1 Ready     (0 = drive 1 ready)
   55                  ; PA1 <- !TRACK 00          (0 = head on trk 0)
   56                  ; PA2 <- !FAULT (nc)
   57                  ; PA3 <- !SECTOR (nc)
   58                  ; PA4 <- !Drive 2 Ready     (0 = drive 2 ready)
   59                  ; PA5 <- !Write Protect     (0 = write protect)
   60                  ; PA6 -> Drive Select       (0 = drv 2, 1 = drv 1)
   61                  ; PA7 <- !INDEX             (0 = @index)
   62                  ;
   63                  ; $C002
   64                  ; port B
   65                  ; PB0 -> !WRITE ENABLE      (0 = write)
   66                  ; PB1 -> !ERASE ENABLE (nc) (leave 1)
   67                  ; PB2 -> !STEP DIRECTION    (0 = to trk 39/76)
   68                  ; PB3 -> !STEP              (step on 1->0 transition)
   69                  ; PB4 -> !FAULT RESET (nc)  (leave 1) (motor on?)
   70                  ; PB5 -> Drive Enable       (1 = drive ON) (Or Drive/Side sel. 4 drive system 1=drive 0&1,0=drive 2&3 )
   71                  ; PB6 -> !LOW CURRENT (nc)  (leave 1 on 5.25; On 8" disk 0 when writing trk 44+)
   72                  ; PB7 -> !HEAD LOAD         (0 = head on disk)
   73                  ;
   74                  ; CA1 <- 20ms clk on 8"
   75                  ; CA2 -> output ?
   76                  ; CB1 <- 400 mSec clk for RTC operations (2.5x/sec) 5.25",  1000ms for 8"
   77                  ; CB2 <- ?
   78                  ;
   79                  ; Disk routines set port A to all input except PA6, port B to all output
   80                  
   81                  
   82  0300            ORG =   $0300
   83                  
   84  0028            MAXTRK5 =   40     ; # TRACKS TO READ 5 1/4 disk
   85  000A            MAXPAG5 =   10     ; # PAGES TO READ  5 1/4 disk
   86  004D            MAXTRK8 =   77     ; # Tracks to read 8 disk
   87  000F            MAXPAG8 =   15     ; # Pages to read 8 disk
   88  0050            MAXTRK3 =   80     ; # Tracks to read 3 1/2 disk
   89  0010            MAXPAG3 =   16     ; # Pages to read 3 1/2 disk
   90  0877            BYTES5  = 2167
   91  0E10            BYTES8  = 3600
   92  10CC            BYTES3  = 4300
   93                  
   94  C000            DDPIA   =   $C000   ; Disk controller PIA
   95  C010            DDACIA  =   $C010   ; Disk Controller Serial Port
   96  FC00            C2ACIA  =   $FC00   ; ACIA on C2/C4/C8/C3
   97  F000            C1ACIA  =   $F000   ; ACIA on C1
   98                  
   99                  ;Control Character Constants XMODEM etc.
  100  000D            CR      =   $0D
  101  000A            LF      =   $0A
  102  001B            ESC     =   $1B     ; ESC to exit
  103  0015            ACIA8N1 =   $15     ;6850 ACIA control reg setting for 8N1
  104  0011            ACIA8N2 =   $11     ;6850 ACIA control reg setting for 8N2 no irq (OSI default C1)
  105  00B1            ACIA8N2i =  $B1     ;6850 ACIA control reg setting for 8N2 +irq (OSI default C3)
  106                  
  107                  ;storage space (anywhere, so why not page zero?)
  108  0029            STORE       = $29   ;storage C4P starts stack at 28
  109  002A            MAXTRK      = STORE+01 ;1 - 40 for 5.25, 77 for 8, 255 for HD
  110  002B            MAXPAG      = STORE+02 ;1 - 9 for 5.25, 15 for 8, 16 for HD
  111  002C            ACIACTL     = STORE+03 ;1 controls cassette/rs-232 ACIA divisor, format
  112  002D            DRVNUM      = STORE+04 ;1 drive# 0-3
  113  002E            TRK         = STORE+05 ;1 current track #
  114  002F            TMP         = STORE+06 ;1
  115  0030            MACHINE     = STORE+07 ;1 C1/C2/C3 flag 00=C2/4/8, $40=C3Ser, $80=C1
  116  0031            INVKEYB     = STORE+08 ;C1 polled = FF C2 polled = 00
  117                  
  118  0032            VIDEO       = STORE+09 ;1 0 = Serial $FF = video
  119  0033            PATSEL      = STORE+10 ;1  0 = Fixed byte (PATVAL), $FF = random
  120  0034            PATVAL      = STORE+11 ;1  Byte to write to disk
  121  0035            PASSES      = STORE+12 ;1
  122  0036            READONLY    = STORE+13 ;1 .BYTE 0 ; zero read write
  123  0037            PASSCNTR    = STORE+14 ;1 .BYTE 0
  124  0038            RND         = STORE+15 ;6 .BYTE 92, 159, 137, 36, 210, 89
  125  003E            RNDHLD      = STORE+21 ;6 .BYTE 0,0,0,0,0,0
  126  0044            DIVIDEND    = STORE+27 ;3 .BYTE 0,0,0
  127  0047            DIVISOR     = STORE+30 ;3 .BYTE 0,0,0
  128  004A            REMAINDER   = STORE+33 ;3 .BYTE 0,0,0
  129  004D            factor2     = STORE+36 ;3 .BYTE 0,0,0
  130  0050            PZTEMP      = STORE+39 ;1 .BYTE 0
  131  0051            MAX         = STORE+40 ;3 .BYTE 0,0,0
  132  0054            MIN         = STORE+43 ;3 .BYTE 0,0,0
  133  0057            SUM         = STORE+46 ;3 .BYTE 0,0,0
  134  005A            pad         = STORE+49 ;1 .BYTE 0
  135  005B            ERRCNT      = STORE+50 ;2 .WORD 0
  136  005D            PRTERR      = STORE+52 ;1 .BYTE 0
  137                  
  138                  ; Allow 3% fast rotation and 1.25 delay after index high and 2.2 ms index
  139                  ; pulse;
  140  005E            MTRKBYTES   = STORE+53 ;2 .WORD 0   ; negative number of bytes in track
  141  0060            BYTECNTR    = STORE+55 ;2 .WORD 0
  142  0062            YHOLD       = STORE+57 ;1 .BYTE 0
  143  0063            TESTTYPE    = STORE+58 ;1 .BYTE 0   ; 0 normal 1 scope
  144                  
  145                  ;zero page storage
  146  0065            DRVACIA     =STORE+60 ;1 .BYTE 0 ; Current serial word format for DISK ACIA 8E1/8N1
  147  0066            PTRSTOR     =STORE+61 ;2 .WORD 0 
  148  0068            TDATA       =STORE+63 ;2 .WORD 0
  149  006A            TDATA2      =STORE+65 ;2 .WORD 0
  150  006C            VIDSRC      =STORE+67 ;2 .WORD $D040
  151  006E            VIDDST      =STORE+69 ;2 .WORD $D000
  152  0070            VIDOFFSET   =STORE+71 ;1 .BYTE 0
  153  0071            VIDXLEN     =STORE+72 ;1 .BYTE 0
  154  0072            VIDXMAX     =STORE+73 ;1 .BYTE 0
  155  0073            MAXERR      =STORE+74 ;1 .BYTE 0 ; number of errors + 1 to print
  156  0074            SINGLETRK   =STORE+75 ;1 .BYTE 0; non zero if testing single track
  157                  
  158                          ; Serial monitor start values
  159                          ; (now emitted by A65 65A output format
  160                          ;*= $129
  161                          ;.BYTE 0,0,0,0,$fd,ORG/256,ORG%256
  162                  
  163  0300                    *=  ORG
  164  0300                    .EXE *          ;A65 emit OSI .lod start address operation
  165  0300  78                SEI
  166  0301  20 11 13          JSR VIDINIT
  167  0304  AD 01 FE          LDA $FE01       ;determine machine type
  168  0307  F0 10             BEQ SERTYP      ;Is this serial system?                                                    
  169  0309  A9 00             LDA #$00
  170  030B  AA                TAX
  171  030C  8D 00 DF          STA $DF00   
  172  030F  2C 00 DF          BIT $DF00       ;okay check C1/C2-C4
  173  0312  30 02             BMI C1TYPE
  174  0314  E8                INX
  175  0316            C1TYPE=*+1
  176  0315  2C A9 80          BIT $80A9
  177  0319            SERTYP=*+1
  178  0318  2C A9 40          BIT $40A9
  179  031B  CA                DEX
  180  031C  85 30             STA MACHINE     ;bit 7 = C1, bit 6 = C3, none =C2/C4
  181  031E  86 31             STX INVKEYB
  182  0320  A9 15             LDA #$15        ;B1 = 8N2 /16 RTStxIRQ  rxIRQ ;$15 = 8N1 /16 RTSNOtxIRQ NOrxIRQ; $B5 = irqs on 8N1
  183  0322  85 2C             STA ACIACTL
  184                          ; Not sure how to figure out if we should use serial or video.
  185                          ; First try to determine if a serial port exists. If it does we
  186                          ; print a message to both serial and video and see which the user
  187                          ; hits a key on to select between video and serial
  188  0324  A2 0A             LDX #10 ; 10*1.25MS wait for last character to be output
  189  0326  20 0B 10          JSR DELAY
  190  0329  A2 00             LDX #0
  191  032B  20 DD 12          JSR CheckTXReady  ; If serial not ready likely no serial port
  192  032E  B0 01             BCS SELLP       
  193  0330  CA                DEX             ; so don't write to serial.
  194  0331            SELLP
  195  0331  20 A4 12          JSR Get_Chr     ; Flush serial data if any
  196  0334  86 32             STX VIDEO       ; Select serial first then video
  197  0336  20 1A 10          JSR PRINT
  198  0339  0D 0A 48          .BYTE   CR,LF,'HIT ANY KEY TO SELECT CONSOLE DEVICE',CR,LF,0
       033C  49 54 20  
       033F  41 4E 59  
       0342  20 4B 45  
       0345  59 20 54  
       0348  4F 20 53  
       034B  45 4C 45  
       034E  43 54 20  
       0351  43 4F 4E  
       0354  53 4F 4C  
       0357  45 20 44  
       035A  45 56 49  
       035D  43 45 0D  
       0360  0A 00     
  199  0362  20 A4 12          JSR Get_Chr     ; Flush serial data if any
  200  0365  CA                DEX
  201  0366  E0 FE             CPX #$FE        ; If we did both then we are done
  202  0368  D0 C7             BNE SELLP
  203  036A            SELLP2
  204  036A  20 A4 12          JSR Get_Chr     ; Get serial character if one ready
  205  036D  B0 0C             BCS SERCON      ; Got one, select serial
  206  036F  20 73 12          JSR Check_Keypress  ; Check polled keyboard for key down
  207  0372  90 F6             BCC SELLP2      ; Didn't find it
  208  0374  A2 FF             LDX #$FF
  209  0376  A0 04             LDY #4          ; Set video console and # of errors to print
  210  0378  4C 7F 03          JMP STORECON
  211  037B            SERCON
  212  037B  A2 00             LDX #0
  213  037D  A0 06             LDY #6          ; Set serial console and # of errors to print
  214  037F            STORECON
  215  037F  86 32             STX VIDEO
  216  0381  84 73             STY MAXERR
  217                  
  218  0383  A9 00             LDA #$00        ; Reset various variables
  219  0385  85 2D             STA DRVNUM
  220  0387  85 33             STA PATSEL
  221  0389  85 63             STA TESTTYPE
  222  038B  85 36             STA READONLY
  223  038D  85 2E             STA TRK         ; We don't know the track so set to zero
  224                  
  225  038F  A9 01             LDA #$01
  226  0391  85 35             STA PASSES
  227  0393  A9 18             LDA #$18
  228  0395  85 34             STA PATVAL
  229  0397  24 30             BIT MACHINE
  230  0399  50 03             BVC *+5
  231  039B  4C 6C 04          JMP SETDRV8     ;serial systems use 8" by default
  232  039E  4C 59 04          JMP SETDRV5
  233                  
  234  03A1            TOP
  235  03A1  20 A4 10          JSR DRWMENU     ; Print menu
  236  03A4  20 A4 12          JSR Get_Chr     ; Flush serial data if any
  237  03A7  A2 00             LDX #$00
  238  03A9  20 BC 12          JSR INKEY       ; Key user input
  239  03AC  20 ED 12          JSR OUTPUT
  240  03AF  C9 31             CMP #$31        ; See if its a menu choice and do it
  241  03B1  D0 03             BNE *+5
  242  03B3  4C F4 08          JMP TEST
  243  03B6  C9 32             CMP #$32
  244  03B8  D0 03             BNE *+5
  245  03BA  4C 92 04          JMP TESTTRK
  246  03BD  C9 33             CMP #$33
  247  03BF  D0 03             BNE *+5
  248  03C1  4C F5 05          JMP SETDRV
  249  03C4  C9 34             CMP #$34
  250  03C6  D0 03             BNE *+5
  251  03C8  4C F7 03          JMP DRVTYPE
  252  03CB  C9 35             CMP #$35
  253  03CD  D0 03             BNE *+5
  254  03CF  4C E9 04          JMP SETPAT
  255  03D2  C9 36             CMP #$36
  256  03D4  D0 09             BNE CHECKNEXT
  257  03D6  A9 FF             LDA #$FF
  258  03D8  45 36             EOR READONLY
  259  03DA  85 36             STA READONLY
  260  03DC  4C A1 03          JMP TOP
  261  03DF            CHECKNEXT
  262  03DF  C9 37             CMP #$37
  263  03E1  D0 03             BNE *+5
  264  03E3  4C 3B 06          JMP RPMTEST
  265  03E6  C9 38             CMP #$38
  266  03E8  D0 03             BNE *+5
  267  03EA  4C 82 14          JMP STATSCRN
  268  03ED  C9 39             CMP #$39
  269  03EF  D0 03             BNE *+5
  270  03F1  6C FC FF          JMP ($FFFC)     ;Exit
  271  03F4  4C 51 04          JMP INPERR
  272                  
  273  03F7            DRVTYPE
  274  03F7  20 1A 10          JSR PRINT
  275  03FA  0D 0A 45          .BYTE $D,$A,'Enter your disk drive type (8) inch, (5).25 inch, or (3).5 inch? >',0
       03FD  6E 74 65  
       0400  72 20 79  
       0403  6F 75 72  
       0406  20 64 69  
       0409  73 6B 20  
       040C  64 72 69  
       040F  76 65 20  
       0412  74 79 70  
       0415  65 20 28  
       0418  38 29 20  
       041B  69 6E 63  
       041E  68 2C 20  
       0421  28 35 29  
       0424  2E 32 35  
       0427  20 69 6E  
       042A  63 68 2C  
       042D  20 6F 72  
       0430  20 28 33  
       0433  29 2E 35  
       0436  20 69 6E  
       0439  63 68 3F  
       043C  20 3E 00  
  276  043F  20 BC 12          JSR INKEY
  277  0442  20 ED 12          JSR OUTPUT
  278  0445  C9 38             CMP #$38
  279  0447  F0 23             BEQ SETDRV8
  280  0449  C9 35             CMP #$35
  281  044B  F0 0C             BEQ SETDRV5
  282  044D  C9 33             CMP #$33
  283  044F  F0 2E             BEQ SETDRV3
  284  0451            INPERR
  285  0451  A9 3F             LDA #'?         ; Print bad choice and menu again
  286  0453  20 ED 12          JSR OUTPUT
  287  0456  4C A1 03          JMP TOP
  288                  
  289  0459            SETDRV5
  290  0459  A9 28             LDA #MAXTRK5
  291  045B  85 2A             STA MAXTRK
  292  045D  A9 0A             LDA #MAXPAG5
  293  045F  85 2B             STA MAXPAG
  294  0461  A9 89             LDA #-BYTES5%256
  295  0463  85 5E             STA MTRKBYTES
  296  0465  A9 F7             LDA #-BYTES5/256
  297  0467  85 5F             STA MTRKBYTES+1
  298  0469  4C A1 03          JMP TOP
  299                  
  300  046C            SETDRV8
  301  046C  A9 4D             LDA #MAXTRK8
  302  046E  85 2A             STA MAXTRK
  303  0470  A9 0F             LDA #MAXPAG8
  304  0472  85 2B             STA MAXPAG
  305  0474  A9 F0             LDA #-BYTES8%256
  306  0476  85 5E             STA MTRKBYTES
  307  0478  A9 F1             LDA #-BYTES8/256
  308  047A  85 5F             STA MTRKBYTES+1
  309  047C  4C A1 03          JMP TOP
  310                  
  311  047F            SETDRV3
  312  047F  A9 50             LDA #MAXTRK3
  313  0481  85 2A             STA MAXTRK
  314  0483  A9 10             LDA #MAXPAG3
  315  0485  85 2B             STA MAXPAG
  316  0487  A9 34             LDA #-BYTES3%256
  317  0489  85 5E             STA MTRKBYTES
  318  048B  A9 EF             LDA #-BYTES3/256
  319  048D  85 5F             STA MTRKBYTES+1
  320  048F  4C A1 03          JMP TOP
  321                  
  322                  
  323  0492            TESTTRK
  324  0492  20 1A 10          JSR PRINT
  325  0495  0D 0A 45          .BYTE $D,$A,'Enter 2 digit decimal track to test > ',0
       0498  6E 74 65  
       049B  72 20 32  
       049E  20 64 69  
       04A1  67 69 74  
       04A4  20 64 65  
       04A7  63 69 6D  
       04AA  61 6C 20  
       04AD  74 72 61  
       04B0  63 6B 20  
       04B3  74 6F 20  
       04B6  74 65 73  
       04B9  74 20 3E  
       04BC  20 00     
  326  04BE  20 CF 05          JSR GETDEC2
  327  04C1  90 CF             BCC TESTTRK
  328  04C3  85 62             STA YHOLD
  329  04C5  C5 2A             CMP MAXTRK      ; Don't allow more than MAXTRK
  330  04C7  10 C9             BPL TESTTRK
  331  04C9  20 32 0F          JSR INITPIA
  332  04CC  20 57 0F          JSR SELDRV
  333  04CF  20 74 0F          JSR TZERO       ; STEP TO TRACK 0
  334  04D2  90 03             BCC *+5
  335  04D4  4C FB 0E          JMP NOTRK
  336  04D7  A5 62             LDA YHOLD
  337  04D9  F0 07             BEQ TESTSTART
  338  04DB            TESTTN
  339  04DB  20 D8 0F          JSR TNEXT       ; Step to desired track
  340  04DE  C6 62             DEC YHOLD
  341  04E0  D0 F9             BNE TESTTN
  342  04E2            TESTSTART
  343  04E2  A9 01             LDA #1          ; And set flag to only test the one track
  344  04E4  85 74             STA SINGLETRK
  345  04E6  4C F8 08          JMP TEST2
  346                  
  347  04E9            SETPAT
  348  04E9  A9 00             LDA #0
  349  04EB  85 33             STA PATSEL
  350  04ED  20 1A 10          JSR PRINT
  351  04F0  0D 0A 45          .BYTE $D,$A,'Enter hex fill pattern or space for random > ',0
       04F3  6E 74 65  
       04F6  72 20 68  
       04F9  65 78 20  
       04FC  66 69 6C  
       04FF  6C 20 70  
       0502  61 74 74  
       0505  65 72 6E  
       0508  20 6F 72  
       050B  20 73 70  
       050E  61 63 65  
       0511  20 66 6F  
       0514  72 20 72  
       0517  61 6E 64  
       051A  6F 6D 20  
       051D  3E 20 00  
  352  0520  20 BC 12          JSR INKEY
  353  0523  20 ED 12          JSR OUTPUT
  354  0526  29 7F             AND #$7F
  355  0528  C9 20             CMP #' '
  356  052A  F0 7D             BEQ PATRND
  357  052C  20 AE 05          JSR CONVHDIG
  358  052F  90 B8             BCC SETPAT
  359  0531  0A                ASL             ; Shift to high nibble
  360  0532  0A                ASL
  361  0533  0A                ASL
  362  0534  0A                ASL
  363  0535  AA                TAX
  364  0536  20 BC 12          JSR INKEY       ; Get and combine with low nibble
  365  0539  20 ED 12          JSR OUTPUT
  366  053C  20 AE 05          JSR CONVHDIG
  367  053F  90 A8             BCC SETPAT
  368  0541  85 2F             STA TMP
  369  0543  8A                TXA
  370  0544  05 2F             ORA TMP
  371  0546  85 34             STA PATVAL
  372  0548            GETPASSES
  373  0548  20 1A 10          JSR PRINT
  374  054B  0D 0A 45          .BYTE $D,$A,'Enter two digit passes > ',0
       054E  6E 74 65  
       0551  72 20 74  
       0554  77 6F 20  
       0557  64 69 67  
       055A  69 74 20  
       055D  70 61 73  
       0560  73 65 73  
       0563  20 3E 20  
       0566  00        
  375  0567  20 CF 05          JSR GETDEC2
  376  056A  90 DC             BCC GETPASSES
  377  056C  85 35             STA PASSES
  378                  
  379  056E            GETTYPE
  380  056E  20 1A 10          JSR PRINT
  381  0571  0D 0A 28          .BYTE $D,$A,'(S)cope test or (N)ormal > ',0
       0574  53 29 63  
       0577  6F 70 65  
       057A  20 74 65  
       057D  73 74 20  
       0580  6F 72 20  
       0583  28 4E 29  
       0586  6F 72 6D  
       0589  61 6C 20  
       058C  3E 20 00  
  382  058F  20 BC 12          JSR INKEY
  383  0592  20 ED 12          JSR OUTPUT
  384  0595  29 7F             AND #$7F
  385  0597  09 20             ORA #$20
  386  0599  A2 00             LDX #0
  387  059B  C9 6E             CMP #'n'
  388  059D  F0 05             BEQ SETTYPE
  389  059F  E8                INX
  390  05A0  C9 73             CMP #'s'
  391  05A2  D0 CA             BNE GETTYPE
  392  05A4            SETTYPE
  393  05A4  86 63             STX TESTTYPE
  394  05A6  4C A1 03          JMP TOP
  395  05A9            PATRND
  396  05A9  C6 33             DEC PATSEL
  397  05AB  4C 48 05          JMP GETPASSES
  398                  
  399  05AE            CONVHDIG
  400  05AE  20 BE 05          JSR CONVDIG
  401  05B1  B0 0A             BCS CONVHRET
  402  05B3  C9 61             CMP #'a'
  403  05B5  30 16             BMI CONVERR
  404  05B7  C9 67             CMP #'f'+1
  405  05B9  10 12             BPL CONVERR
  406  05BB  E9 56             SBC #'a'-1-10
  407  05BD            CONVHRET
  408  05BD  60                RTS
  409  05BE            CONVDIG
  410  05BE  29 7F             AND #$7F
  411  05C0  09 20             ORA #$20
  412  05C2  C9 30             CMP #'0'
  413  05C4  30 07             BMI CONVERR
  414  05C6  C9 3A             CMP #'9'+1
  415  05C8  10 03             BPL CONVERR
  416  05CA  E9 2F             SBC #'0'-1
  417  05CC  60                RTS
  418  05CD            CONVERR
  419  05CD  18                CLC
  420  05CE  60                RTS
  421                  
  422                  ; Return 2 digit decimal number in A. Carry clear if number valid
  423  05CF            GETDEC2
  424  05CF  20 BC 12          JSR INKEY
  425  05D2  20 ED 12          JSR OUTPUT
  426  05D5  20 BE 05          JSR CONVDIG
  427  05D8  90 1A             BCC GETDEC2RET
  428  05DA  85 2F             STA TMP
  429  05DC  0A                ASL             ; Multiply by 8
  430  05DD  0A                ASL
  431  05DE  0A                ASL
  432  05DF  65 2F             ADC TMP         ; And add twice to make multiply by 10
  433  05E1  65 2F             ADC TMP
  434  05E3  85 2F             STA TMP
  435  05E5  20 BC 12          JSR INKEY       ; Get and add low digit
  436  05E8  20 ED 12          JSR OUTPUT
  437  05EB  20 BE 05          JSR CONVDIG
  438  05EE  90 04             BCC GETDEC2RET
  439  05F0  18                CLC
  440  05F1  65 2F             ADC TMP
  441  05F3  38                SEC
  442  05F4            GETDEC2RET          ; Not valid number, return carry clear
  443  05F4  60                RTS
  444                  
  445  05F5            SETDRV
  446  05F5  20 1A 10          JSR PRINT
  447  05F8  0D 0A 53          .BYTE $D,$A,'Select drive (A), (B), (C), (D) ? >',0
       05FB  65 6C 65  
       05FE  63 74 20  
       0601  64 72 69  
       0604  76 65 20  
       0607  28 41 29  
       060A  2C 20 28  
       060D  42 29 2C  
       0610  20 28 43  
       0613  29 2C 20  
       0616  28 44 29  
       0619  20 3F 20  
       061C  3E 00     
  448  061E  20 BC 12          JSR INKEY
  449  0621  20 ED 12          JSR OUTPUT
  450  0624  29 5F             AND #$5F
  451  0626  C9 41             CMP #'A
  452  0628  90 0B             BCC SETERR
  453  062A  C9 45             CMP #'E
  454  062C  B0 07             BCS SETERR
  455  062E  E9 40             SBC #'@         ;carry is clear so val -1
  456  0630  85 2D             STA DRVNUM
  457  0632  4C A1 03          JMP TOP
  458  0635            SETERR
  459  0635  4C 51 04          JMP INPERR
  460                  
  461  0638            NOTRK2
  462  0638  4C FB 0E          JMP NOTRK
  463                          ; Test drive RPM with head unloaded and loaded
  464                          ; We count number of bytes sent through disk serial port between
  465                          ; index pulses to measure RPM. That is independent of CPU speed.
  466                          ; We use 8N1 for 10 total bits.
  467                          ; 8" = 25,000 characters per second, 5.25" 12,500, 3.5" 720k 25,000 
  468                          ; 3.5" 1.44M (not yet supported) 50,000.
  469                          ; 16 measurements are done with minimum, maximum, and avarage
  470                          ; printed
  471  063B            RPMTEST
  472  063B  20 32 0F          JSR INITPIA
  473  063E  20 57 0F          JSR SELDRV
  474  0641  20 74 0F          JSR TZERO       ; STEP TO TRACK 0
  475  0644  B0 F2             BCS NOTRK2
  476  0646  A9 03             LDA #3
  477  0648  8D 10 C0          STA DDACIA      ; RESET ACIA
  478  064B  A9 54             LDA #$54        ;0 10 101 00 ;$54-  recv irq, RTS HIGH no xmit irq,  8N1,  DIVIDE BY 1,
  479  064D  85 65             STA DRVACIA 
  480  064F  8D 10 C0          STA DDACIA      ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  481  0652  20 1A 10          JSR PRINT
  482  0655  0D 0A 48          .BYTE $D,$A,'Head unloaded ',0
       0658  65 61 64  
       065B  20 75 6E  
       065E  6C 6F 61  
       0661  64 65 64  
       0664  20 00     
  483  0666  20 D6 06          JSR RPMTST2
  484  0669  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
  485  066C  29 7F             AND #$7F        ; 0111 1111
  486  066E  8D 02 C0          STA DDPIA+2     ; LOAD DISK HEAD
  487  0671  A2 FF             LDX #$FF        ; 320MS
  488  0673  20 0B 10          JSR DELAY
  489  0676  20 1A 10          JSR PRINT
  490  0679  0D 0A 48          .BYTE $D,$A,'Head loaded   ',0
       067C  65 61 64  
       067F  20 6C 6F  
       0682  61 64 65  
       0685  64 20 20  
       0688  20 00     
  491  068A  20 D6 06          JSR RPMTST2
  492  068D            RPMUNLOAD
  493  068D  AD 02 C0          LDA DDPIA+2
  494  0690  09 80             ORA #$80    
  495  0692  8D 02 C0          STA DDPIA+2     ; UNLOAD DISK HEAD
  496  0695  4C A1 03          JMP TOP
  497  0698            INDEXACT
  498  0698  20 1A 10          JSR PRINT
  499  069B  49 6E 64          .BYTE 'Index stuck active',CR,LF,0
       069E  65 78 20  
       06A1  73 74 75  
       06A4  63 6B 20  
       06A7  61 63 74  
       06AA  69 76 65  
       06AD  0D 0A 00  
  500  06B0  20 75 10          JSR ANYKEY
  501  06B3  4C 8D 06          JMP RPMUNLOAD
  502  06B6            INDEXINACT
  503  06B6  20 1A 10          JSR PRINT
  504  06B9  49 6E 64          .BYTE 'Index stuck inactive',CR,LF,0
       06BC  65 78 20  
       06BF  73 74 75  
       06C2  63 6B 20  
       06C5  69 6E 61  
       06C8  63 74 69  
       06CB  76 65 0D  
       06CE  0A 00     
  505  06D0  20 75 10          JSR ANYKEY
  506  06D3  4C 8D 06          JMP RPMUNLOAD
  507  06D6            RPMTST2
  508  06D6  A2 00             LDX #0
  509  06D8  A0 00             LDY #0
  510  06DA            RPMTSTLP
  511  06DA  E8                INX
  512  06DB  D0 01             BNE *+3
  513  06DD  C8                INY
  514  06DE  F0 B8             BEQ INDEXACT
  515  06E0  2C 00 C0          BIT DDPIA       ; WAIT END OF
  516  06E3  10 F5             BPL RPMTSTLP    ; INDEX PULSE
  517  06E5  A9 00             LDA #0
  518  06E7  85 47             STA DIVISOR     ; Clear variables
  519  06E9  85 48             STA DIVISOR+1
  520  06EB  85 49             STA DIVISOR+2
  521  06ED  85 51             STA MAX
  522  06EF  85 52             STA MAX+1
  523  06F1  85 53             STA MAX+2
  524  06F3  85 57             STA SUM
  525  06F5  85 58             STA SUM+1
  526  06F7  85 59             STA SUM+2
  527  06F9  A9 FF             LDA #255
  528  06FB  85 54             STA MIN
  529  06FD  85 55             STA MIN+1
  530  06FF  85 56             STA MIN+2
  531  0701  A2 10             LDX #16         ; Measure RPM 16 times
  532  0703  A0 00             LDY #0
  533  0705  A9 00             LDA #0
  534  0707  18                CLC
  535  0708            RPMLP1
  536                          ; Wait for index then write first byte to UART since it
  537                          ; should be ready. Then write a second byte since it should either
  538                          ; be ready immediatly or very shortly after first byte is transferred
  539                          ; to TX shift register. Then start counting with the writes that
  540                          ; will happen at the UART data rate.
  541  0708  C8                INY
  542  0709  D0 02             BNE *+4
  543  070B  69 01             ADC #1
  544  070D  F0 A7             BEQ INDEXINACT  ; If we wait to long for index inactive print error
  545  070F  2C 00 C0          BIT DDPIA       ; WAIT for INDEX PULSE
  546  0712  30 F4             BMI RPMLP1
  547  0714  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  548  0717            RPMNDX0
  549  0717  A9 02             LDA #2
  550  0719  2D 10 C0          AND DDACIA      ;test tx ready? 
  551  071C  F0 F9             BEQ RPMNDX0     ;not ready?
  552  071E  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  553  0721            RPMNDX1
  554  0721  A9 02             LDA #2
  555  0723  2D 10 C0          AND DDACIA      ;test tx ready? 
  556  0726  F0 F9             BEQ RPMNDX1     ;not ready?
  557  0728  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  558  072B  E6 47             INC DIVISOR
  559  072D  D0 02             BNE *+4
  560  072F  E6 48             INC DIVISOR+1
  561  0731  D0 02             BNE *+4
  562  0733  E6 49             INC DIVISOR+2
  563  0735  2C 00 C0          BIT DDPIA       ; WAIT END OF
  564  0738  10 E7             BPL RPMNDX1     ; INDEX PULSE
  565  073A            RPMNDX2
  566  073A  2C 00 C0          BIT DDPIA       ; DONE IF 
  567  073D  10 17             BPL RPMNDX3     ; INDEX PULSE
  568  073F  A9 02             LDA #2
  569  0741  2D 10 C0          AND DDACIA      ;test tx ready? 
  570  0744  F0 F4             BEQ RPMNDX2     ;not ready?
  571  0746  8D 11 C0          STA DDACIA+1    ; WRITE BYTE, VALUE DON'T CARE
  572  0749  E6 47             INC DIVISOR     ; Count character sent
  573  074B  D0 02             BNE *+4
  574  074D  E6 48             INC DIVISOR+1
  575  074F  D0 02             BNE *+4
  576  0751  E6 49             INC DIVISOR+2
  577  0753  4C 3A 07          JMP RPMNDX2
  578  0756            RPMNDX3
  579  0756  2C 00 C0          BIT DDPIA       ; WAIT END OF
  580  0759  10 FB             BPL RPMNDX3     ; INDEX PULSE
  581  075B  18                CLC
  582  075C  A5 57             LDA SUM         ; Sum of all rotation time
  583  075E  65 47             ADC DIVISOR
  584  0760  85 57             STA SUM
  585  0762  A5 58             LDA SUM+1
  586  0764  65 48             ADC DIVISOR+1
  587  0766  85 58             STA SUM+1
  588  0768  A5 59             LDA SUM+2
  589  076A  65 49             ADC DIVISOR+2
  590  076C  85 59             STA SUM+2
  591                  
  592  076E  A5 49             LDA DIVISOR+2
  593  0770  C5 56             CMP MIN+2
  594  0772  90 35             BCC LESS1
  595  0774  D0 0E             BNE GE1
  596  0776  A5 48             LDA DIVISOR+1
  597  0778  C5 55             CMP MIN+1
  598  077A  90 2D             BCC LESS1
  599  077C  D0 06             BNE GE1
  600  077E  A5 47             LDA DIVISOR
  601  0780  C5 54             CMP MIN
  602  0782  90 25             BCC LESS1
  603  0784            GE1 ; DIVISOR >= MIN
  604  0784  A5 49             LDA DIVISOR+2
  605  0786  C5 53             CMP MAX+2
  606  0788  90 2E             BCC LESS2
  607  078A  D0 0E             BNE GE2
  608  078C  A5 48             LDA DIVISOR+1
  609  078E  C5 52             CMP MAX+1
  610  0790  90 26             BCC LESS2
  611  0792  D0 06             BNE GE2
  612  0794  A5 47             LDA DIVISOR
  613  0796  C5 51             CMP MAX
  614  0798  90 1E             BCC LESS2
  615  079A            GE2 ; DIVISOR >= MAX
  616  079A  A5 47             LDA DIVISOR
  617  079C  85 51             STA MAX
  618  079E  A5 48             LDA DIVISOR+1
  619  07A0  85 52             STA MAX+1
  620  07A2  A5 49             LDA DIVISOR+2
  621  07A4  85 53             STA MAX+2
  622  07A6  4C B8 07          JMP LESS2
  623                  
  624  07A9            LESS1   ; DIVISOR < MIN
  625  07A9  A5 47             LDA DIVISOR
  626  07AB  85 54             STA MIN
  627  07AD  A5 48             LDA DIVISOR+1
  628  07AF  85 55             STA MIN+1
  629  07B1  A5 49             LDA DIVISOR+2
  630  07B3  85 56             STA MIN+2
  631  07B5  4C 84 07          JMP GE1
  632                          
  633  07B8            LESS2   ; DIVISOR < MAX
  634  07B8  CA                DEX
  635  07B9  F0 0B             BEQ RPMDONE
  636  07BB  A9 00             LDA #0
  637  07BD  85 47             STA DIVISOR
  638  07BF  85 48             STA DIVISOR+1
  639  07C1  85 49             STA DIVISOR+2
  640  07C3  4C 08 07          JMP RPMLP1
  641                  
  642  07C6            RPMDONE
  643  07C6  20 1A 10          JSR PRINT
  644  07C9  52 50 4D          .BYTE 'RPM: AVG ',0
       07CC  3A 20 41  
       07CF  56 47 20  
       07D2  00        
  645  07D3  A2 04             LDX #4          ; Divide by 16 to convert sum to average
  646  07D5            RPMDIVL
  647  07D5  18                CLC
  648  07D6  66 59             ROR SUM+2
  649  07D8  66 58             ROR SUM+1
  650  07DA  66 57             ROR SUM
  651  07DC  CA                DEX
  652  07DD  D0 F6             BNE RPMDIVL
  653  07DF  A5 57             LDA SUM
  654  07E1  85 47             STA DIVISOR
  655  07E3  A5 58             LDA SUM+1
  656  07E5  85 48             STA DIVISOR+1
  657  07E7  A5 59             LDA SUM+2
  658  07E9  85 49             STA DIVISOR+2
  659  07EB  20 28 08          JSR RPMPRT
  660                  
  661  07EE  20 1A 10          JSR PRINT
  662  07F1  20 20 4D          .BYTE '  MIN',0
       07F4  49 4E 00  
  663                  
  664  07F7  A5 51             LDA MAX
  665  07F9  85 47             STA DIVISOR
  666  07FB  A5 52             LDA MAX+1
  667  07FD  85 48             STA DIVISOR+1
  668  07FF  A5 53             LDA MAX+2
  669  0801  85 49             STA DIVISOR+2
  670  0803  20 28 08          JSR RPMPRT
  671                  
  672  0806  20 1A 10          JSR PRINT
  673  0809  20 20 4D          .BYTE '  MAX',0
       080C  41 58 00  
  674                  
  675  080F  A5 54             LDA MIN
  676  0811  85 47             STA DIVISOR
  677  0813  A5 55             LDA MIN+1
  678  0815  85 48             STA DIVISOR+1
  679  0817  A5 56             LDA MIN+2
  680  0819  85 49             STA DIVISOR+2
  681  081B  20 28 08          JSR RPMPRT
  682  081E  60                RTS
  683                  
  684                  ; 8" RPM scale 360 RPM * (250000 bps/10 bits/byte/6 RPS) = 1500000
  685  081F  60 E3 16  RPMSCALE8   .BYTE $60, $e3, $16 
  686                  ; 5.25" RPM scale 300 * (125000/10/5) = 750000
  687  0822  B0 71 0B  RPMSCALE5   .BYTE $b0, $71, $0b 
  688                  ; 3.5" 720KB RPM scale 300 RPM * (250000 bps/10 bits/byte/5 RPS) = 1500000
  689  0825  60 E3 16  RPMSCALE3   .BYTE $60, $e3, $16
  690                  ; 3.5" 1.44MB RPM scale 300 RPM * (500000 bps/10 bits/byte/5 RPS) = 3000000
  691                  ;RPMSCALE3       .BYTE $c0, $c6, $2d
  692                  ; Allow 3% fast rotation and 1.25 delay after index high and 2.2 ms index
  693                  ; pulse;
  694                  
  695                  ; Convert count to RPM with two decimal places
  696  0828            RPMPRT
  697  0828  A5 2B             LDA MAXPAG
  698  082A  C9 0F             CMP #MAXPAG8
  699  082C  F0 28             BEQ RPM8
  700  082E  C9 0A             CMP #MAXPAG5
  701  0830  F0 12             BEQ RPM5
  702                  
  703  0832  AD 25 08          LDA RPMSCALE3
  704  0835  85 44             STA DIVIDEND
  705  0837  AD 26 08          LDA RPMSCALE3+1
  706  083A  85 45             STA DIVIDEND+1
  707  083C  AD 27 08          LDA RPMSCALE3+2
  708  083F  85 46             STA DIVIDEND+2
  709  0841  4C 65 08          JMP DODIV
  710                  
  711  0844  AD 22 08  RPM5    LDA RPMSCALE5
  712  0847  85 44             STA DIVIDEND
  713  0849  AD 23 08          LDA RPMSCALE5+1
  714  084C  85 45             STA DIVIDEND+1
  715  084E  AD 24 08          LDA RPMSCALE5+2
  716  0851  85 46             STA DIVIDEND+2
  717  0853  4C 65 08          JMP DODIV
  718  0856            RPM8
  719  0856  AD 1F 08          LDA RPMSCALE8
  720  0859  85 44             STA DIVIDEND
  721  085B  AD 20 08          LDA RPMSCALE8+1
  722  085E  85 45             STA DIVIDEND+1
  723  0860  AD 21 08          LDA RPMSCALE8+2
  724  0863  85 46             STA DIVIDEND+2
  725  0865            DODIV
  726  0865  20 0F 14          JSR DIV24       ; Get integer part of RPM
  727  0868  A9 20             LDA #' '
  728  086A  85 5A             STA pad
  729  086C  20 AA 08          JSR PrDec16
  730  086F  A9 64             LDA #100        ; Multiply remainder by 100 and divide again to get
  731  0871  85 4D             STA factor2     ; fractional part
  732  0873  A9 00             LDA #0
  733  0875  85 4E             STA factor2+1
  734  0877  85 4F             STA factor2+2
  735  0879  20 45 14          JSR MULT24
  736  087C  20 0F 14          JSR DIV24
  737  087F  A9 2E             LDA #'.'
  738  0881  20 ED 12          JSR OUTPUT
  739  0884  A9 30             LDA #'0'
  740  0886  85 5A             STA pad
  741  0888  A0 02             LDY #2          ; Print 2 digits
  742  088A  20 AC 08          JSR PrDec16Lp1
  743  088D  60                RTS
  744                          
  745                     ; From http://beebwiki.mdfs.net/Number_output_in_6502_machine_code
  746                     ; ---------------------------
  747                     ; Print 16-bit decimal number
  748                     ; ---------------------------
  749                     ; On entry, num=number to print
  750                     ;           pad=0 or pad character (eg '0' or ' ')
  751                     ; On entry at PrDec16Lp1,
  752                     ;           Y=(number of digits)*2-2, eg 8 for 5 digits
  753                     ; On exit,  A,X,Y,num,pad corrupted
  754                     ; Size      69 bytes
  755                     ; -----------------------------------------------------------------
  756  0044            num = DIVIDEND
  757                  
  758  088E            PrDec2Dig
  759  088E  85 44             STA num
  760  0890  A9 00             LDA #0
  761  0892  85 45             STA num+1
  762  0894  A9 20             LDA #' '
  763  0896  85 5A             STA pad
  764  0898  A0 02             LDY #2
  765  089A  4C AC 08          JMP PrDec16Lp1
  766  089D            PrDec4Dig
  767  089D  86 44             STX num
  768  089F  85 45             STA num+1
  769  08A1  A9 20             LDA #' '
  770  08A3  85 5A             STA pad
  771  08A5  A0 06             LDY #6
  772  08A7  4C AC 08          JMP PrDec16Lp1
  773                  
  774  08AA            PrDec16
  775  08AA  A0 08             LDY #8           ; Offset to powers of ten
  776  08AC            PrDec16Lp1
  777  08AC  A2 FF             LDX #$FF
  778  08AE  38                SEC              ; Start with digit=-1
  779  08AF            PrDec16Lp2
  780  08AF  A5 44             LDA num+0
  781  08B1  F9 EA 08          SBC PrDec16Tens+0,Y
  782  08B4  85 44             STA num+0        ; Subtract current tens
  783  08B6  A5 45             LDA num+1
  784  08B8  F9 EB 08          SBC PrDec16Tens+1,Y
  785  08BB  85 45             STA num+1
  786  08BD  E8                INX
  787  08BE  B0 EF             BCS PrDec16Lp2   ; Loop until <0
  788  08C0  A5 44             LDA num+0
  789  08C2  79 EA 08          ADC PrDec16Tens+0,Y
  790  08C5  85 44             STA num+0        ; Add current tens back in
  791  08C7  A5 45             LDA num+1
  792  08C9  79 EB 08          ADC PrDec16Tens+1,Y
  793  08CC  85 45             STA num+1
  794  08CE  8A                TXA
  795  08CF  C0 00             CPY #0
  796  08D1  F0 09             BEQ PrDec16Digit  ; Last digit, always print
  797  08D3  8A                TXA
  798  08D4  D0 06             BNE PrDec16Digit  ; Not zero, print it
  799  08D6  A5 5A             LDA pad
  800  08D8  D0 08             BNE PrDec16Print
  801  08DA  F0 09             BEQ PrDec16Next   ; pad<>0, use it
  802  08DC            PrDec16Digit
  803  08DC  A2 30             LDX #'0
  804  08DE  86 5A             STX pad         ; No more zero padding
  805  08E0  09 30             ORA #'0         ; Print this digit
  806  08E2            PrDec16Print
  807  08E2  20 ED 12          JSR OUTPUT
  808  08E5            PrDec16Next
  809  08E5  88                DEY
  810  08E6  88                DEY
  811  08E7  10 C3             BPL PrDec16Lp1  ; Loop for next digit
  812  08E9  60                RTS
  813  08EA            PrDec16Tens
  814  08EA  01 00             .WORD 1
  815  08EC  0A 00             .WORD 10
  816  08EE  64 00             .WORD 100
  817  08F0  E8 03             .WORD 1000
  818  08F2  10 27             .WORD 10000
  819                  ;-----------------------------------------------------------
  820                  ; Either write test pattern then check or just check pattern.
  821                  ; Read test only works for data written by this program.
  822  08F4            TEST
  823  08F4  A9 00             LDA #0
  824  08F6  85 74             STA SINGLETRK
  825  08F8            TEST2
  826  08F8  20 1A 10          JSR PRINT
  827  08FB  0D 0A             .BYTE CR,LF
  828  08FD  57 52 49          .BYTE 'WRITE PROTECT ALL DISKS EXCEPT TEST DISK!',CR,LF
       0900  54 45 20  
       0903  50 52 4F  
       0906  54 45 43  
       0909  54 20 41  
       090C  4C 4C 20  
       090F  44 49 53  
       0912  4B 53 20  
       0915  45 58 43  
       0918  45 50 54  
       091B  20 54 45  
       091E  53 54 20  
       0921  44 49 53  
       0924  4B 21 0D  
       0927  0A        
  829  0928  0D 0A             .BYTE CR,LF
  830  092A  49 4E 53          .BYTE 'INSERT DISK TO BE TESTED',CR,LF
       092D  45 52 54  
       0930  20 44 49  
       0933  53 4B 20  
       0936  54 4F 20  
       0939  42 45 20  
       093C  54 45 53  
       093F  54 45 44  
       0942  0D 0A     
  831  0944  49 66 20          .BYTE 'If errors found the output is DDDD (#### GG BBP)* EEEE',CR,LF
       0947  65 72 72  
       094A  6F 72 73  
       094D  20 66 6F  
       0950  75 6E 64  
       0953  20 74 68  
       0956  65 20 6F  
       0959  75 74 70  
       095C  75 74 20  
       095F  69 73 20  
       0962  44 44 44  
       0965  44 20 28  
       0968  23 23 23  
       096B  23 20 47  
       096E  47 20 42  
       0971  42 50 29  
       0974  2A 20 45  
       0977  45 45 45  
       097A  0D 0A     
  832  097C  77 68 65          .BYTE 'where DDDD is difference between number of bytes written',CR,LF
       097F  72 65 20  
       0982  44 44 44  
       0985  44 20 69  
       0988  73 20 64  
       098B  69 66 66  
       098E  65 72 65  
       0991  6E 63 65  
       0994  20 62 65  
       0997  74 77 65  
       099A  65 6E 20  
       099D  6E 75 6D  
       09A0  62 65 72  
       09A3  20 6F 66  
       09A6  20 62 79  
       09A9  74 65 73  
       09AC  20 77 72  
       09AF  69 74 74  
       09B2  65 6E 0D  
       09B5  0A        
  833  09B6  61 6E 64          .BYTE 'and read. EEEE is total errors, #### is byte count from', CR,LF
       09B9  20 72 65  
       09BC  61 64 2E  
       09BF  20 45 45  
       09C2  45 45 20  
       09C5  69 73 20  
       09C8  74 6F 74  
       09CB  61 6C 20  
       09CE  65 72 72  
       09D1  6F 72 73  
       09D4  2C 20 23  
       09D7  23 23 23  
       09DA  20 69 73  
       09DD  20 62 79  
       09E0  74 65 20  
       09E3  63 6F 75  
       09E6  6E 74 20  
       09E9  66 72 6F  
       09EC  6D 0D 0A  
  834  09EF  73 74 61          .BYTE 'start of track, GG is good byte, BB is bad byte,',CR,LF
       09F2  72 74 20  
       09F5  6F 66 20  
       09F8  74 72 61  
       09FB  63 6B 2C  
       09FE  20 47 47  
       0A01  20 69 73  
       0A04  20 67 6F  
       0A07  6F 64 20  
       0A0A  62 79 74  
       0A0D  65 2C 20  
       0A10  42 42 20  
       0A13  69 73 20  
       0A16  62 61 64  
       0A19  20 62 79  
       0A1C  74 65 2C  
       0A1F  0D 0A     
  835  0A21  50 20 69          .BYTE 'P is byte had parity error.',CR,LF
       0A24  73 20 62  
       0A27  79 74 65  
       0A2A  20 68 61  
       0A2D  64 20 70  
       0A30  61 72 69  
       0A33  74 79 20  
       0A36  65 72 72  
       0A39  6F 72 2E  
       0A3C  0D 0A     
  836  0A3E  45 72 72          .BYTE 'Errors that fit on line are printed.',CR,LF
       0A41  6F 72 73  
       0A44  20 74 68  
       0A47  61 74 20  
       0A4A  66 69 74  
       0A4D  20 6F 6E  
       0A50  20 6C 69  
       0A53  6E 65 20  
       0A56  61 72 65  
       0A59  20 70 72  
       0A5C  69 6E 74  
       0A5F  65 64 2E  
       0A62  0D 0A     
  837  0A64  45 53 43          .BYTE 'ESC KEY OR ^X ABORTS...',CR,LF,0
       0A67  20 4B 45  
       0A6A  59 20 4F  
       0A6D  52 20 5E  
       0A70  58 20 41  
       0A73  42 4F 52  
       0A76  54 53 2E  
       0A79  2E 2E 0D  
       0A7C  0A 00     
  838                  
  839  0A7E  20 75 10          JSR ANYKEY
  840  0A81  C9 1B             CMP #ESC    ;ESC key?
  841  0A83  F0 3B             BEQ JMP2TOP
  842  0A85  C9 18             CMP #$18    ;^X
  843  0A87  F0 37             BEQ JMP2TOP
  844                  
  845                  
  846  0A89  A5 35             LDA PASSES
  847  0A8B  85 37             STA PASSCNTR
  848  0A8D  20 32 0F          JSR INITPIA
  849  0A90  20 57 0F          JSR SELDRV
  850  0A93  20 21 0F          JSR RESPTR
  851  0A96  A9 20             LDA #$20
  852  0A98  2C 00 C0          BIT DDPIA
  853  0A9B  D0 26             BNE WRITEOK
  854  0A9D  20 1A 10          JSR PRINT
  855  0AA0  0D 0A             .BYTE CR,LF
  856  0AA2  44 49 53          .BYTE 'DISK IS WRITE PROTECTED!',CR,LF,0
       0AA5  4B 20 49  
       0AA8  53 20 57  
       0AAB  52 49 54  
       0AAE  45 20 50  
       0AB1  52 4F 54  
       0AB4  45 43 54  
       0AB7  45 44 21  
       0ABA  0D 0A 00  
  857  0ABD  20 75 10          JSR ANYKEY
  858  0AC0            JMP2TOP
  859  0AC0  4C A1 03          JMP TOP
  860  0AC3            WRITEOK
  861  0AC3  A5 74             LDA SINGLETRK
  862  0AC5  D0 08             BNE TESTFILL    ; Head already at desired track
  863  0AC7  20 74 0F          JSR TZERO       ; STEP TO TRACK 0
  864  0ACA  90 03             BCC TESTFILL
  865  0ACC  4C FB 0E          JMP NOTRK
  866                  
  867  0ACF            TESTFILL
  868  0ACF  20 21 0F          JSR RESPTR
  869  0AD2  A0 00             LDY #0
  870  0AD4            TFILL   
  871  0AD4  A5 34             LDA PATVAL
  872  0AD6  24 33             BIT PATSEL      ; Fill with test pattern. 
  873  0AD8  10 03             BPL TSTORE      ; Always fills larger 8" number of bytes
  874  0ADA  20 F9 13          JSR RAND
  875  0ADD            TSTORE
  876  0ADD  91 68             STA (TDATA),Y
  877  0ADF  C8                INY
  878  0AE0  D0 02             BNE TCHKFILLED
  879  0AE2  E6 69             INC TDATA+1
  880  0AE4            TCHKFILLED
  881  0AE4  C0 10             CPY #BYTES8%256
  882  0AE6  D0 EC             BNE TFILL
  883  0AE8  A5 69             LDA TDATA+1
  884  0AEA  38                SEC
  885  0AEB  E9 15             SBC #BUFFER/256
  886  0AED  C9 0E             CMP #BYTES8/256
  887  0AEF  D0 E3             BNE TFILL
  888                  
  889  0AF1  A9 5A             LDA #$5A        ; Start of track marker
  890  0AF3  8D EB 15          STA BUFFER
  891                          
  892  0AF6  A9 58             LDA #$58        ;0 10 110 00 ;$58-  recv irq, RTS HIGH no xmit irq,  8E1,  DIVIDE BY 1,
  893  0AF8  85 65             STA DRVACIA 
  894                  
  895  0AFA  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
  896  0AFD  29 7F             AND #$7F        ; 0111 1111
  897  0AFF  8D 02 C0          STA DDPIA+2     ; LOAD DISK HEAD
  898  0B02  A2 FF             LDX #$FF        ; 320MS
  899  0B04  20 0B 10          JSR DELAY
  900                  
  901  0B07  A5 36             LDA READONLY    ; If read only skip write
  902  0B09  F0 03             BEQ WRNEXT
  903  0B0B  4C A7 0B          JMP TREAD
  904  0B0E            WRNEXT
  905  0B0E  20 1A 10          JSR PRINT
  906  0B11  57 54 52          .BYTE 'WTRK ',0
       0B14  4B 20 00  
  907  0B17  A5 2E             LDA TRK
  908  0B19  20 8E 08          JSR PrDec2Dig
  909  0B1C  A5 5E             LDA MTRKBYTES
  910  0B1E  85 60             STA BYTECNTR
  911  0B20  A5 5F             LDA MTRKBYTES+1
  912  0B22  85 61             STA BYTECNTR+1
  913  0B24  20 21 0F          JSR RESPTR
  914  0B27  A5 2E             LDA TRK         ; Write track to second byte to check for seek errors
  915  0B29  8D EC 15          STA BUFFER+1
  916                  
  917  0B2C  2C 00 C0          BIT DDPIA       ; WAIT 
  918  0B2F  30 FB             BMI *-3         ; INDEX PULSE
  919  0B31  2C 00 C0          BIT DDPIA       ; WAIT END OF
  920  0B34  10 FB             BPL *-3         ; INDEX PULSE
  921  0B36  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
  922  0B39  29 FC             AND #$FC        ; TURN ON WRITE AND ERASE ENABLE
  923  0B3B  8D 02 C0          STA DDPIA+2
  924                  
  925  0B3E  A9 03             LDA #3
  926  0B40  8D 10 C0          STA DDACIA      ; RESET ACIA
  927  0B43  A5 65             LDA DRVACIA     ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
  928  0B45  8D 10 C0          STA DDACIA      ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
  929  0B48  A2 01             LDX #1          ; 0.8MS
  930  0B4A  A0 9E             LDY #$9E
  931  0B4C  20 0D 10          JSR DELAY1
  932  0B4F  A0 00             LDY #0
  933  0B51            WRDATALP
  934  0B51  2C 00 C0          BIT DDPIA       ; WAIT 
  935  0B54  30 03             BMI WNOINDEXERR ; Didn't find INDEX PULSE
  936  0B56  4C AD 0E          JMP INDEXERR    
  937  0B59            WNOINDEXERR
  938  0B59  A9 02             LDA #2
  939  0B5B  2D 10 C0          AND DDACIA      ;test tx ready? 
  940  0B5E  F0 F1             BEQ WRDATALP    ;not ready?
  941  0B60  B1 68             LDA (TDATA),Y
  942  0B62  8D 11 C0          STA DDACIA+1    ; Write data to floppy
  943  0B65  C8                INY
  944  0B66  D0 02             BNE *+4
  945  0B68  E6 69             INC TDATA+1
  946  0B6A  E6 60             INC BYTECNTR
  947  0B6C  D0 E3             BNE WRDATALP
  948  0B6E  E6 61             INC BYTECNTR+1
  949  0B70  D0 E7             BNE WNOINDEXERR ; Not done, write more. Don't check for index
  950                                          ; to prevent being late writing next char.
  951                  
  952  0B72  2C 00 C0          BIT DDPIA       ; WAIT FOR
  953  0B75  30 FB             BMI *-3         ; INDEX PULSE
  954  0B77  2C 00 C0          BIT DDPIA       ; WAIT FOR
  955  0B7A  10 FB             BPL *-3         ; END INDEX PULSE
  956  0B7C  A2 20             LDX #32         ; Erase a little past index
  957  0B7E  CA                DEX
  958  0B7F  D0 FD             BNE *-1
  959                          
  960  0B81  A9 03             LDA #$03
  961  0B83  0D 02 C0          ORA DDPIA+2     ; turn off write and erase
  962  0B86  8D 02 C0          STA DDPIA+2
  963                  
  964  0B89  A9 0D             LDA #CR
  965  0B8B  20 ED 12          JSR OUTPUT
  966  0B8E  A5 74             LDA SINGLETRK
  967  0B90  D0 15             BNE TREAD       ; Single track, we are done writing
  968  0B92  A6 2E             LDX TRK
  969  0B94  E8                INX
  970  0B95  E4 2A             CPX MAXTRK
  971  0B97  F0 06             BEQ TWDONE
  972  0B99  20 D8 0F          JSR TNEXT       ; Go to next track
  973  0B9C  4C 0E 0B          JMP WRNEXT
  974  0B9F            TWDONE
  975  0B9F  A9 80             LDA #$80
  976  0BA1  0D 02 C0          ORA DDPIA+2     ; Unload head
  977  0BA4  8D 02 C0          STA DDPIA+2
  978                  
  979                  
  980                          ; Read portion of disk test. Enter at TREAD2 if testing
  981                          ; single track. For normal read we save off the data read and the
  982                          ; error flags from the serial chip. We don't have enough time
  983                          ; to handle errors between bytes.
  984                          ; For scope read we check the word in real time and generate
  985                          ; fault reset pulse to trigger a scope. Checking for the track stops
  986                          ; after the first error.
  987  0BA7            TREAD
  988  0BA7  A5 74             LDA SINGLETRK
  989  0BA9  D0 15             BNE TREAD2      ; Single track, skip seek to zero
  990  0BAB  20 74 0F          JSR TZERO       ; STEP TO TRACK 0
  991  0BAE  90 03             BCC *+5
  992  0BB0  4C FB 0E          JMP NOTRK
  993  0BB3  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
  994  0BB6  29 7F             AND #$7F        ; 0111 1111
  995  0BB8  8D 02 C0          STA DDPIA+2     ; LOAD DISK HEAD
  996  0BBB  A2 FF             LDX #$FF        ; 320MS
  997  0BBD  20 0B 10          JSR DELAY
  998                  
  999  0BC0            TREAD2
 1000  0BC0  20 21 0F          JSR RESPTR
 1001  0BC3  A9 00             LDA #0
 1002  0BC5  85 5B             STA ERRCNT
 1003  0BC7  85 5C             STA ERRCNT+1
 1004  0BC9  85 5D             STA PRTERR  
 1005                  
 1006  0BCB  20 1A 10          JSR PRINT
 1007  0BCE  52 54 52          .BYTE   'RTRK ',0
       0BD1  4B 20 00  
 1008  0BD4  A5 2E             LDA TRK
 1009  0BD6  20 8E 08          JSR PrDec2Dig
 1010  0BD9  A9 20             LDA #' '
 1011  0BDB  20 ED 12          JSR OUTPUT
 1012  0BDE  A5 2E             LDA TRK         ; Update compare data with track testing
 1013  0BE0  8D EC 15          STA BUFFER+1
 1014                  
 1015  0BE3  2C 00 C0          BIT DDPIA       ; WAIT 
 1016  0BE6  30 FB             BMI *-3         ; INDEX PULSE
 1017  0BE8  2C 00 C0          BIT DDPIA       ; WAIT END OF
 1018  0BEB  10 FB             BPL *-3         ; INDEX PULSE
 1019  0BED  A9 03             LDA #3          
 1020  0BEF  8D 10 C0          STA DDACIA      ; RESET ACIA
 1021  0BF2  A5 65             LDA DRVACIA     ; usually $58-DIVIDE BY 1, 8E1, RTS HIGH no IRQs
 1022  0BF4  8D 10 C0          STA DDACIA      ; SET DISK SERIAL WORD FORMAT/CLEAR FLAGS
 1023  0BF7  A5 63             LDA TESTTYPE
 1024  0BF9  D0 03             BNE *+5
 1025  0BFB  4C 27 0D          JMP NORMREAD    ; User selected normal read test
 1026                  
 1027                          ; This is scope read check code
 1028  0BFE  A0 00             LDY #0
 1029  0C00  A9 01             LDA #1
 1030  0C02            RDATALP2
 1031  0C02  2C 00 C0          BIT DDPIA
 1032  0C05  10 35             BPL NODATA      ; INDEX PULSE
 1033  0C07  2C 10 C0          BIT DDACIA      ; test tx ready?    
 1034  0C0A  F0 F6             BEQ RDATALP2
 1035  0C0C  08                PHP
 1036  0C0D  AD 11 C0          LDA DDACIA+1    ; read data from floppy
 1037  0C10  C9 5A             CMP #$5A        ; Got start byte
 1038  0C12  D0 07             BNE IGNBYTE     ; No, try one more time. We get one junk
 1039                                          ; byte where write turned on/off
 1040  0C14  28                PLP
 1041  0C15  70 33             BVS SERROR      ; Did it get a parity error
 1042  0C17  C8                INY             ; Skip this byte in checking since we checked
 1043  0C18  4C 1C 0C          JMP RDATALP3
 1044  0C1B            IGNBYTE
 1045  0C1B  28                PLP
 1046  0C1C            RDATALP3
 1047  0C1C  2C 00 C0          BIT DDPIA
 1048  0C1F  30 03             BMI NOTINDEX2   ; INDEX PULSE
 1049  0C21  4C 32 0E          JMP PCRONLY
 1050  0C24            NOTINDEX2
 1051  0C24  A9 01             LDA #1
 1052  0C26  2C 10 C0          BIT DDACIA      ; test tx ready?    
 1053  0C29  F0 F1             BEQ RDATALP3
 1054  0C2B  AD 11 C0          LDA DDACIA+1    ; read data from floppy
 1055  0C2E  70 1A             BVS SERROR      ; Branch if parity error
 1056  0C30  D1 68             CMP (TDATA),Y   ; Check data
 1057  0C32  D0 16             BNE SERROR
 1058  0C34  C8                INY
 1059  0C35  D0 ED             BNE NOTINDEX2
 1060  0C37  E6 69             INC TDATA+1
 1061  0C39  4C 24 0C          JMP NOTINDEX2
 1062  0C3C            NODATA
 1063  0C3C  20 1A 10          JSR PRINT
 1064  0C3F  4E 6F 20          .BYTE 'No data',0
       0C42  64 61 74  
       0C45  61 00     
 1065  0C47            JPCRLF
 1066  0C47  4C 29 0E          JMP PCRLF
 1067  0C4A            SERROR  ; Print error info and generate scope trigger
 1068  0C4A  48                PHA
 1069  0C4B  A9 EF             LDA #$EF
 1070  0C4D  2D 02 C0          AND DDPIA+2     ; Clear fault reset
 1071  0C50  8D 02 C0          STA DDPIA+2
 1072  0C53  20 16 10          JSR DELAY2
 1073  0C56  A9 10             LDA #$10
 1074  0C58  0D 02 C0          ORA DDPIA+2     ; Set fault reset
 1075  0C5B  8D 02 C0          STA DDPIA+2
 1076                  
 1077  0C5E  38                SEC
 1078  0C5F  A5 69             LDA TDATA+1     ; Calculate offset of byte with error
 1079  0C61  E9 15             SBC #>BUFFER
 1080  0C63  85 45             STA num+1
 1081  0C65  84 62             STY YHOLD
 1082  0C67  84 44             STY num
 1083  0C69  98                TYA
 1084  0C6A  18                CLC
 1085  0C6B  65 5E             ADC MTRKBYTES
 1086  0C6D  A5 45             LDA num+1
 1087  0C6F  65 5F             ADC MTRKBYTES+1
 1088  0C71  30 16             BMI SPERR       ; Error was in bytes being tested
 1089  0C73  20 1A 10          JSR PRINT
 1090  0C76  45 78 74          .BYTE   'Extra data read',0
       0C79  72 61 20  
       0C7C  64 61 74  
       0C7F  61 20 72  
       0C82  65 61 64  
       0C85  00        
 1091  0C86  4C B0 0C          JMP SERRWAIT
 1092                          
 1093  0C89            SPERR
 1094  0C89  A9 30             LDA #'0'
 1095  0C8B  85 5A             STA pad
 1096  0C8D  A0 06             LDY #6          ; 4 digits max
 1097  0C8F  20 AC 08          JSR     PrDec16Lp1
 1098  0C92  20 1A 10          JSR PRINT
 1099  0C95  20 47 4F          .BYTE ' GOOD ',0
       0C98  4F 44 20  
       0C9B  00        
 1100  0C9C  A4 62             LDY YHOLD
 1101  0C9E  B1 68             LDA (TDATA),Y
 1102  0CA0  20 44 10          JSR PHEXA
 1103  0CA3  20 1A 10          JSR PRINT
 1104  0CA6  20 42 41          .BYTE ' BAD ',0
       0CA9  44 20 00  
 1105  0CAC  68                PLA
 1106  0CAD  20 44 10          JSR PHEXA
 1107  0CB0            SERRWAIT
 1108  0CB0  AD 02 C0          LDA DDPIA+2
 1109  0CB3  09 80             ORA #$80    
 1110  0CB5  8D 02 C0          STA DDPIA+2     ; UNLOAD DISK HEAD
 1111  0CB8  20 A4 12          JSR Get_Chr
 1112  0CBB  20 1A 10          JSR PRINT
 1113  0CBE  0D 0A 48          .BYTE CR,LF,'Hit space to reread E to exit or other key to continue > ',0
       0CC1  69 74 20  
       0CC4  73 70 61  
       0CC7  63 65 20  
       0CCA  74 6F 20  
       0CCD  72 65 72  
       0CD0  65 61 64  
       0CD3  20 45 20  
       0CD6  74 6F 20  
       0CD9  65 78 69  
       0CDC  74 20 6F  
       0CDF  72 20 6F  
       0CE2  74 68 65  
       0CE5  72 20 6B  
       0CE8  65 79 20  
       0CEB  74 6F 20  
       0CEE  63 6F 6E  
       0CF1  74 69 6E  
       0CF4  75 65 20  
       0CF7  3E 20 00  
 1114  0CFA  20 BC 12          JSR INKEY
 1115  0CFD  48                PHA
 1116  0CFE  20 1A 10          JSR PRINT
 1117  0D01  0D 0A 00          .BYTE CR,LF,0
 1118  0D04  68                PLA
 1119  0D05  09 20             ORA #$20        ; Lower case
 1120  0D07  C9 65             CMP #'e'
 1121  0D09  D0 03             BNE *+5
 1122  0D0B  4C A1 03          JMP TOP
 1123  0D0E  48                PHA
 1124  0D0F  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 1125  0D12  29 7F             AND #$7F        ; 0111 1111
 1126  0D14  8D 02 C0          STA DDPIA+2     ; LOAD DISK HEAD
 1127  0D17  A2 FF             LDX #$FF        ; 320MS
 1128  0D19  20 0B 10          JSR DELAY
 1129  0D1C  68                PLA
 1130  0D1D  C9 20             CMP #' '
 1131  0D1F  F0 03             BEQ *+5
 1132  0D21  4C 37 0E          JMP NEXTTRK
 1133  0D24  4C C0 0B          JMP TREAD2
 1134                          
 1135                          
 1136                  
 1137                          ; This is normal read check code
 1138  0D27            NORMREAD
 1139  0D27  A0 00             LDY #0
 1140  0D29            RDATALP
 1141  0D29  2C 00 C0          BIT DDPIA
 1142  0D2C  10 16             BPL RINDEX      ; INDEX PULSE
 1143  0D2E            NOTINDEX
 1144  0D2E  AD 10 C0          LDA DDACIA      ; test tx ready?    
 1145  0D31  91 6A             STA (TDATA2),Y  ; store error data
 1146  0D33  4A                LSR
 1147  0D34  90 F3             BCC RDATALP     ; not ready?
 1148  0D36  AD 11 C0          LDA DDACIA+1    ; read data from floppy
 1149  0D39  C8                INY
 1150  0D3A  91 6A             STA (TDATA2),Y  ; store disk data
 1151  0D3C  C8                INY
 1152  0D3D  D0 EF             BNE NOTINDEX
 1153  0D3F  E6 6B             INC TDATA2+1
 1154  0D41  4C 2E 0D          JMP NOTINDEX
 1155                  
 1156  0D44            RINDEX
 1157  0D44  18                CLC ; Found index, determine how many bytes read
 1158  0D45  98                TYA
 1159  0D46  65 6A             ADC TDATA2
 1160  0D48  85 6A             STA TDATA2
 1161  0D4A  90 02             BCC *+4
 1162  0D4C  E6 6B             INC TDATA2+1
 1163  0D4E  38                SEC
 1164  0D4F  A5 6A             LDA TDATA2
 1165  0D51  E9 FB             SBC #<BUFFER2
 1166  0D53  85 60             STA BYTECNTR
 1167  0D55  A5 6B             LDA TDATA2+1
 1168  0D57  E9 23             SBC #>BUFFER2
 1169  0D59  18                CLC
 1170  0D5A  6A                ROR
 1171  0D5B  85 61             STA BYTECNTR+1
 1172  0D5D  A5 60             LDA BYTECNTR    ; divide by 2 to get bytes data stored
 1173  0D5F  6A                ROR
 1174  0D60  85 60             STA BYTECNTR
 1175  0D62  A5 60             LDA BYTECNTR
 1176  0D64  D0 04             BNE CHKSTART
 1177  0D66  A5 61             LDA BYTECNTR+1
 1178  0D68  F0 26             BEQ NOSKIP      ; If no data don't try to find start of track
 1179  0D6A            CHKSTART
 1180                          ; This will skip up to 1 byte looking for $5A start of track flag
 1181                          ; The write turn on/off generates one byte of junk sometimes
 1182  0D6A  20 21 0F          JSR RESPTR
 1183  0D6D  AD FC 23          LDA BUFFER2+1
 1184  0D70  C9 5A             CMP #$5A        ; Start of track flag
 1185  0D72  F0 1C             BEQ NOSKIP
 1186  0D74  AD FE 23          LDA BUFFER2+3
 1187  0D77  C9 5A             CMP #$5A        ; Start of track flag
 1188  0D79  D0 15             BNE NOSKIP      ; No, assume read error
 1189  0D7B  18                CLC
 1190  0D7C  A9 02             LDA #2
 1191  0D7E  65 6A             ADC TDATA2
 1192  0D80  85 6A             STA TDATA2
 1193  0D82  A9 00             LDA #0
 1194  0D84  65 6B             ADC TDATA2+1    ; Ignore one junk character
 1195  0D86  85 6B             STA TDATA2+1    ; and parity byte
 1196  0D88  A5 60             LDA BYTECNTR
 1197  0D8A  D0 02             BNE *+4
 1198  0D8C  C6 61             DEC BYTECNTR+1
 1199  0D8E  C6 60             DEC BYTECNTR
 1200  0D90            NOSKIP
 1201  0D90  18                CLC ; Print bytes read - bytes written. Skipped byte not
 1202                                  ; included in bytes read 
 1203  0D91  A5 60             LDA BYTECNTR
 1204  0D93  65 5E             ADC MTRKBYTES
 1205  0D95  AA                TAX
 1206  0D96  A5 61             LDA BYTECNTR+1
 1207  0D98  65 5F             ADC MTRKBYTES+1
 1208  0D9A  30 0D             BMI PNEG
 1209  0D9C  48                PHA
 1210  0D9D  A9 20             LDA #' '
 1211  0D9F  20 ED 12          JSR OUTPUT
 1212  0DA2  68                PLA
 1213  0DA3  20 9D 08          JSR PrDec4Dig
 1214  0DA6  4C DE 0D          JMP RCHKDATA
 1215  0DA9            PNEG
 1216  0DA9  85 62             STA YHOLD
 1217  0DAB  86 2F             STX TMP
 1218  0DAD  A9 2D             LDA #'-'
 1219  0DAF  20 ED 12          JSR OUTPUT
 1220  0DB2  A9 00             LDA #0
 1221  0DB4  38                SEC
 1222  0DB5  E5 2F             SBC TMP
 1223  0DB7  85 44             STA num
 1224  0DB9  A9 00             LDA #0
 1225  0DBB  E5 62             SBC YHOLD
 1226  0DBD  85 45             STA num+1
 1227  0DBF  A9 2D             LDA #'-'
 1228  0DC1  85 5A             STA pad
 1229  0DC3  A0 06             LDY #6
 1230  0DC5  20 AC 08          JSR PrDec16Lp1
 1231                  
 1232  0DC8  38                SEC
 1233  0DC9  A9 00             LDA #0
 1234                          ; Bytes read shorter than expected so only check bytes read.
 1235  0DCB  E5 60             SBC BYTECNTR    
 1236  0DCD  85 60             STA BYTECNTR    ; Convert to negative count
 1237  0DCF  A9 00             LDA #0
 1238  0DD1  E5 61             SBC BYTECNTR+1
 1239  0DD3  85 61             STA BYTECNTR+1
 1240  0DD5  D0 0F             BNE RCHKDATALP
 1241  0DD7  A5 60             LDA BYTECNTR
 1242  0DD9  D0 0B             BNE RCHKDATALP
 1243  0DDB  4C 29 0E          JMP PCRLF   ; No bytes read, don't compare. Just print CRLF
 1244  0DDE            RCHKDATA
 1245  0DDE  A5 5E             LDA MTRKBYTES
 1246  0DE0  85 60             STA BYTECNTR
 1247  0DE2  A5 5F             LDA MTRKBYTES+1
 1248  0DE4  85 61             STA BYTECNTR+1
 1249  0DE6            RCHKDATALP
 1250  0DE6  A0 00             LDY #0
 1251  0DE8  A9 40             LDA #$40
 1252  0DEA  31 6A             AND     (TDATA2),Y
 1253  0DEC  D0 6F             BNE RERROR  ; Data had parity error
 1254  0DEE  A5 6B             LDA TDATA2+1
 1255  0DF0  C8                INY
 1256  0DF1  B1 6A             LDA     (TDATA2),Y
 1257  0DF3  88                DEY
 1258  0DF4  D1 68             CMP (TDATA),Y
 1259  0DF6  D0 65             BNE RERROR  ; Miscompare
 1260  0DF8            RCONT
 1261  0DF8  18                CLC
 1262  0DF9  A9 02             LDA #2
 1263  0DFB  65 6A             ADC TDATA2  ; Inc data pointers
 1264  0DFD  85 6A             STA TDATA2
 1265  0DFF  90 02             BCC *+4
 1266  0E01  E6 6B             INC TDATA2+1
 1267  0E03  E6 68             INC TDATA
 1268  0E05  D0 02             BNE *+4
 1269  0E07  E6 69             INC TDATA+1
 1270  0E09  E6 60             INC BYTECNTR
 1271  0E0B  D0 02             BNE *+4
 1272  0E0D  E6 61             INC BYTECNTR+1
 1273  0E0F  D0 D5             BNE RCHKDATALP
 1274                  
 1275  0E11            PRTERRCNT
 1276  0E11  A5 5B             LDA ERRCNT  ; Done compare, did we get any errors?
 1277  0E13  D0 04             BNE PERRCNT
 1278  0E15  A5 5C             LDA ERRCNT+1
 1279  0E17  F0 0C             BEQ PNOERR  ; no
 1280  0E19            PERRCNT
 1281  0E19  A9 20             LDA #' '
 1282  0E1B  20 ED 12          JSR OUTPUT
 1283  0E1E  A6 5B             LDX ERRCNT
 1284  0E20  A5 5C             LDA ERRCNT+1
 1285  0E22  20 9D 08          JSR PrDec4Dig
 1286  0E25            PNOERR
 1287  0E25  A5 5D             LDA PRTERR
 1288  0E27  F0 09             BEQ PCRONLY
 1289  0E29            PCRLF
 1290  0E29  20 1A 10          JSR PRINT
 1291  0E2C  0D 0A 00          .BYTE   CR,LF,0
 1292  0E2F  4C 37 0E          JMP NEXTTRK
 1293  0E32            PCRONLY
 1294  0E32  A9 0D             LDA #CR
 1295  0E34  20 ED 12          JSR OUTPUT
 1296  0E37            NEXTTRK
 1297  0E37  A5 74             LDA SINGLETRK   ; Done if single track or at max
 1298  0E39  D0 0D             BNE TRDONE
 1299  0E3B  A6 2E             LDX TRK
 1300  0E3D  E8                INX
 1301  0E3E  E4 2A             CPX MAXTRK
 1302  0E40  F0 06             BEQ TRDONE
 1303  0E42  20 D8 0F          JSR TNEXT   ; seek to next track
 1304  0E45            JTREAD2
 1305  0E45  4C C0 0B          JMP TREAD2
 1306  0E48            TRDONE
 1307  0E48  A9 80             LDA #$80
 1308  0E4A  0D 02 C0          ORA DDPIA+2 ; Unload head
 1309  0E4D  8D 02 C0          STA DDPIA+2
 1310  0E50  C6 37             DEC PASSCNTR
 1311  0E52  F0 03             BEQ JMPTOP
 1312  0E54  4C C3 0A          JMP WRITEOK
 1313  0E57            JMPTOP
 1314  0E57  20 75 10          JSR ANYKEY
 1315  0E5A  4C A1 03          JMP TOP
 1316                  
 1317                          ; Print offset of error and good and bad data
 1318  0E5D            RERROR
 1319  0E5D  E6 5B             INC ERRCNT
 1320  0E5F  D0 02             BNE *+4
 1321  0E61  E6 5C             INC ERRCNT+1
 1322  0E63  A5 5B             LDA ERRCNT
 1323  0E65  C5 73             CMP MAXERR      ; Only print first MAXERR errors
 1324  0E67  B0 41             BCS NOPRT
 1325  0E69  A5 5C             LDA ERRCNT+1
 1326  0E6B  D0 3D             BNE NOPRT
 1327  0E6D  A9 20             LDA #' '
 1328  0E6F  85 5D             STA PRTERR
 1329  0E71  20 ED 12          JSR OUTPUT
 1330  0E74  38                SEC
 1331  0E75  A5 68             LDA TDATA
 1332  0E77  E9 EB             SBC #<BUFFER
 1333  0E79  AA                TAX
 1334  0E7A  A5 69             LDA TDATA+1
 1335  0E7C  E9 15             SBC #>BUFFER    
 1336  0E7E  20 9D 08          JSR PrDec4Dig
 1337  0E81  A9 20             LDA #' '
 1338  0E83  20 ED 12          JSR OUTPUT
 1339  0E86  A0 00             LDY #0
 1340  0E88  B1 68             LDA (TDATA),Y   ; Good value
 1341  0E8A  20 44 10          JSR PHEXA
 1342  0E8D  A9 20             LDA #' '
 1343  0E8F  20 ED 12          JSR OUTPUT
 1344  0E92  C8                INY
 1345  0E93  B1 6A             LDA (TDATA2),Y  ; Bad value
 1346  0E95  88                DEY
 1347  0E96  20 44 10          JSR PHEXA
 1348  0E99  A2 20             LDX #' '
 1349  0E9B  A9 40             LDA #$40
 1350  0E9D  31 6A             AND (TDATA2),Y
 1351  0E9F  F0 02             BEQ *+4
 1352  0EA1  A2 50             LDX #'P'        ; Parity error
 1353  0EA3  8A                TXA
 1354  0EA4  20 ED 12          JSR OUTPUT
 1355  0EA7  4C F8 0D          JMP RCONT
 1356  0EAA            NOPRT
 1357  0EAA  4C F8 0D          JMP RCONT
 1358                          
 1359  0EAD            INDEXERR
 1360                          ; Found index before we wrote all our data
 1361  0EAD  A9 83             LDA #$83
 1362  0EAF  0D 02 C0          ORA DDPIA+2 ; Unload head, turn off write and erase
 1363  0EB2  8D 02 C0          STA DDPIA+2
 1364  0EB5  20 1A 10          JSR PRINT
 1365  0EB8  0D 0A             .BYTE   CR,LF
 1366  0EBA  49 4E 44          .BYTE   'INDEX ACTIVE DURING WRITE, BYTES LEFT: ',0
       0EBD  45 58 20  
       0EC0  41 43 54  
       0EC3  49 56 45  
       0EC6  20 44 55  
       0EC9  52 49 4E  
       0ECC  47 20 57  
       0ECF  52 49 54  
       0ED2  45 2C 20  
       0ED5  42 59 54  
       0ED8  45 53 20  
       0EDB  4C 45 46  
       0EDE  54 3A 20  
       0EE1  00        
 1367  0EE2  38                SEC
 1368  0EE3  A9 00             LDA #0
 1369  0EE5  E5 60             SBC BYTECNTR
 1370  0EE7  AA                TAX
 1371  0EE8  A9 00             LDA #0
 1372  0EEA  E5 61             SBC BYTECNTR+1  
 1373  0EEC  20 5E 10          JSR PDEC
 1374  0EEF  20 1A 10          JSR PRINT
 1375  0EF2  0D 0A 00          .BYTE   CR,LF,0
 1376  0EF5  20 75 10          JSR ANYKEY
 1377  0EF8  4C A1 03          JMP TOP
 1378                          
 1379  0EFB            NOTRK
 1380  0EFB  20 32 0F          JSR INITPIA
 1381  0EFE  20 1A 10          JSR PRINT
 1382  0F01  0D 0A 0D          .BYTE CR,LF,CR,LF, 'ERROR Seeking Track 0',0
       0F04  0A 45 52  
       0F07  52 4F 52  
       0F0A  20 53 65  
       0F0D  65 6B 69  
       0F10  6E 67 20  
       0F13  54 72 61  
       0F16  63 6B 20  
       0F19  30 00     
 1383  0F1B  20 75 10          JSR ANYKEY
 1384  0F1E  4C A1 03          JMP TOP 
 1385                  
 1386                  ; RESET BUFFER POINTERS
 1387  0F21            RESPTR  
 1388  0F21  A9 EB             LDA #<BUFFER
 1389  0F23  85 68             STA TDATA
 1390  0F25  A9 15             LDA #>BUFFER
 1391  0F27  85 69             STA TDATA+1
 1392  0F29  A9 FB             LDA #<BUFFER2
 1393  0F2B  85 6A             STA TDATA2
 1394  0F2D  A9 23             LDA #>BUFFER2
 1395  0F2F  85 6B             STA TDATA2+1
 1396                  
 1397  0F31  60                RTS
 1398                  
 1399                  ; INIT DISK CONTROLLER PIA returns ZERO if no controller found
 1400  0F32            INITPIA 
 1401  0F32  A0 00             LDY #0
 1402  0F34  A9 40             LDA #$40
 1403  0F36  8C 01 C0          STY DDPIA+1 ; SELECT DDRA
 1404  0F39  8D 00 C0          STA DDPIA   ; SET PORTA TO ALL INPUTS except PA6
 1405  0F3C  A2 04             LDX #4      ; 0000 0100
 1406  0F3E  8E 01 C0          STX DDPIA+1 ; SELECT PORTA
 1407  0F41  8D 00 C0          STA DDPIA    ; SET PB6 HIGH
 1408  0F44  8C 03 C0          STY DDPIA+3 ; SELECT DDRB
 1409  0F47  88                DEY
 1410  0F48  8C 02 C0          STY DDPIA+2 ; SET PORTB TO ALL OUTPUTS
 1411  0F4B  8E 03 C0          STX DDPIA+3 ; SELECT PORTB
 1412  0F4E  8C 02 C0          STY DDPIA+2 ; SET PORTB OUTPUTS HIGH
 1413  0F51  AD 00 C0          LDA DDPIA
 1414  0F54  C9 C0             CMP #>DDPIA
 1415  0F56  60                RTS
 1416                  
 1417                  
 1418                  ;SELECT DRIVE PB5 PA6  DRIVE (1-4)
 1419                  ;              0   0    #4
 1420                  ;              0   1    #3
 1421                  ;              1   0    #2
 1422                  ;              1   1    #1
 1423                  
 1424  0F57            SELDRV
 1425  0F57  A5 2D             LDA DRVNUM
 1426  0F59  4A                LSR A
 1427  0F5A  A8                TAY
 1428  0F5B  90 03             BCC *+5
 1429  0F5D  A9 00             LDA #$00
 1430  0F5F  2C A9 40          BIT $40A9   ; This is LDA #$40 if BCC branches
 1431  0F62  8D 00 C0          STA DDPIA   ; This is A/B select in port A
 1432  0F65  AD 02 C0          LDA DDPIA+2
 1433  0F68  09 20             ORA #$20
 1434  0F6A  C0 01             CPY #$01
 1435  0F6C  90 02             BCC *+4
 1436  0F6E  29 DF             AND #$DF
 1437  0F70  8D 02 C0          STA DDPIA+2 ; This is master select in port B
 1438  0F73  60                RTS
 1439                  
 1440                  
 1441                  ; STEP TO TRACK 0. Carry clear if no error. A modified. TRK set to 0
 1442                  ; if no error.
 1443                  
 1444  0F74            TZERO
 1445  0F74  A5 2A             LDA MAXTRK  ;max num tracks
 1446  0F76  69 08             ADC #$08    ;plus a few more
 1447  0F78  85 2F             STA TMP     ;MAX times to step before abort
 1448  0F7A  AD 02 C0          LDA DDPIA+2
 1449  0F7D  29 FB             AND #$FB    ; 1111 1011
 1450  0F7F  D0 1B             BNE TZERO3  ; DIR=INWARDS, start with one step away from track 0
 1451                  
 1452  0F81            TZERO1
 1453  0F81  C6 2F             DEC TMP
 1454  0F83  D0 02             BNE TZERO5
 1455  0F85  38                SEC
 1456  0F86  60                RTS
 1457  0F87            TZERO5  
 1458  0F87  A9 02             LDA #2      ; 0000 0010
 1459  0F89  2C 00 C0          BIT DDPIA   ; TEST 'TRK0' PIN
 1460  0F8C  D0 09             BNE TZERO2  ; AT TRACK 0
 1461  0F8E  A9 00             LDA #0
 1462  0F90  85 2E             STA TRK
 1463  0F92  20 FA 0F          JSR REDWR
 1464  0F95  18                CLC
 1465  0F96  60                RTS
 1466                  
 1467  0F97            TZERO2  
 1468  0F97  AD 02 C0          LDA DDPIA+2 ; DIR=OUTWARDS (TO TRK0)
 1469  0F9A  09 04             ORA #$04
 1470  0F9C            TZERO3  
 1471  0F9C  8D 02 C0          STA DDPIA+2 ; SET 'DIR' PIN
 1472  0F9F  20 16 10          JSR DELAY2
 1473  0FA2  29 F7             AND #$F7    ; 1111 0111
 1474  0FA4  8D 02 C0          STA DDPIA+2 ; SET 'STEP' PIN LOW
 1475  0FA7  20 16 10          JSR DELAY2
 1476  0FAA  09 08             ORA #8      ; 0000 1000
 1477  0FAC  8D 02 C0          STA DDPIA+2 ; SET 'STEP' PIN HIGH
 1478  0FAF  A2 20             LDX #32 ; 40 MS
 1479  0FB1  20 0B 10          JSR DELAY
 1480  0FB4  F0 CB             BEQ TZERO1  ; ALWAYS
 1481                  
 1482                  ; STEP TO PREVIOUS TRACK
 1483  0FB6            TPREV
 1484  0FB6  AD 02 C0          LDA     DDPIA+2 ; DIR=(TO TRK0)
 1485  0FB9  09 04             ORA     #$04
 1486  0FBB  8D 02 C0          STA     DDPIA+2 ; SET 'DIR' PIN
 1487  0FBE  20 16 10          JSR     DELAY2
 1488  0FC1  29 F7             AND     #$F7    ; 1111 0111
 1489  0FC3  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN LOW
 1490  0FC6  20 16 10          JSR     DELAY2
 1491  0FC9  09 08             ORA     #8              ; 0000 1000
 1492  0FCB  8D 02 C0          STA     DDPIA+2 ; SET 'STEP' PIN HIGH
 1493  0FCE  C6 2E             DEC TRK
 1494  0FD0  20 FA 0F          JSR REDWR   ; Set reduced write current
 1495  0FD3  A2 20             LDX     #32     ; 40 MS
 1496  0FD5  4C 0B 10          JMP     DELAY
 1497                  
 1498                  ; STEP TO NEXT TRACK
 1499                  
 1500  0FD8            TNEXT   
 1501  0FD8  AD 02 C0          LDA DDPIA+2
 1502  0FDB  29 FB             AND #$FB    ; 1111 1011
 1503                                                  ; DIR=INWARDS
 1504  0FDD  8D 02 C0          STA DDPIA+2 ; SET 'DIR' PIN
 1505  0FE0  20 16 10          JSR DELAY2
 1506  0FE3  29 F7             AND #$F7    ; 1111 0111
 1507  0FE5  8D 02 C0          STA DDPIA+2 ; SET 'STEP' LOW
 1508  0FE8  20 16 10          JSR DELAY2
 1509  0FEB  09 08             ORA #8      ; 0000 1000
 1510  0FED  8D 02 C0          STA DDPIA+2 ; SET 'STEP' HIGH
 1511  0FF0  E6 2E             INC TRK
 1512  0FF2  20 FA 0F          JSR REDWR   ; Set reduced write current
 1513  0FF5  A2 20             LDX #32     ; 40MS
 1514  0FF7  4C 0B 10          JMP DELAY
 1515                  
 1516                          ; Set reduced write current
 1517  0FFA            REDWR
 1518  0FFA  A5 2E             LDA TRK
 1519  0FFC  C9 2B             CMP #43 ; Is track >= 43
 1520  0FFE  AD 02 C0          LDA DDPIA+2
 1521  1001  29 BF             AND #$BF    ; Set low current active
 1522  1003  B0 02             BCS SETLO   ; Yes
 1523  1005  09 40             ORA #$40    ; Set low current inactive
 1524  1007            SETLO
 1525  1007  8D 02 C0          STA DDPIA+2
 1526  100A  60                RTS
 1527                  
 1528                  ; DELAY 1.25MS PER LOOP at 1 MHz clock. X,Y modified
 1529                  
 1530  100B            DELAY   
 1531  100B  A0 F8             LDY #$F8
 1532  100D            DELAY1  
 1533  100D  88                DEY
 1534  100E  D0 FD             BNE DELAY1
 1535  1010  55 FF             EOR $FF,X
 1536  1012  CA                DEX
 1537  1013  D0 F6             BNE DELAY
 1538  1015  60                RTS
 1539                  
 1540  1016            DELAY2  
 1541  1016  20 19 10          JSR DELAY21
 1542  1019            DELAY21 
 1543  1019  60                RTS
 1544                  
 1545                  
 1546                  ; PRINT IN-LINE STRING. Y and A modified
 1547                  
 1548  101A            PRINT   
 1549  101A  68                PLA
 1550  101B  85 66             STA PTRSTOR
 1551  101D  68                PLA
 1552  101E  85 67             STA PTRSTOR+1
 1553  1020  A0 01             LDY #1
 1554  1022            PRINT1  
 1555  1022  B1 66             LDA (PTRSTOR),Y
 1556  1024  F0 0A             BEQ PRINT2
 1557  1026  20 ED 12          JSR OUTPUT
 1558  1029  C8                INY
 1559  102A  D0 F6             BNE PRINT1
 1560  102C  E6 67             INC PTRSTOR+1
 1561  102E  D0 F2             BNE PRINT1
 1562  1030            PRINT2  
 1563  1030  98                TYA
 1564  1031  38                SEC
 1565  1032  65 66             ADC PTRSTOR
 1566  1034  A4 66             LDY PTRSTOR
 1567  1036  85 66             STA PTRSTOR
 1568  1038  90 02             BCC PRINT3
 1569  103A  E6 67             INC PTRSTOR+1
 1570  103C            PRINT3
 1571  103C  18                CLC
 1572  103D  6C 66 00          JMP (PTRSTOR)
 1573                  
 1574                  ; PRINT HEX WORD (A,X). ONLY CHANGES A
 1575                  
 1576  1040            PHEX    
 1577  1040  20 44 10          JSR PHEXA
 1578  1043  8A                TXA
 1579                  
 1580                  ; PRINT HEX BYTE (A)
 1581  1044            PHEXA   
 1582  1044  48                PHA
 1583  1045  4A                LSR A
 1584  1046  4A                LSR A
 1585  1047  4A                LSR A
 1586  1048  4A                LSR A
 1587  1049  20 4D 10          JSR PHEXA1
 1588  104C  68                PLA
 1589  104D            PHEXA1  
 1590  104D  29 0F             AND #$F
 1591  104F  09 30             ORA #'0'
 1592  1051  C9 3A             CMP #'9'+1
 1593  1053  30 03             BMI PHEXA2
 1594  1055  18                CLC
 1595  1056  69 07             ADC #7
 1596  1058            PHEXA2  
 1597  1058  4C ED 12          JMP OUTPUT
 1598                  
 1599                  ; PRINT DECIMAL (A)
 1600  105B            PDECA   
 1601  105B  AA                TAX
 1602  105C  A9 00             LDA #0
 1603                  
 1604                  ; PRINT DECIMAL (A,X). CHANGES A,X,Y. Prints with no leading space
 1605                  
 1606  105E            PDEC    
 1607  105E  86 44             STX num
 1608  1060  85 45             STA num+1
 1609  1062  A9 00             LDA #0
 1610  1064  85 5A             STA pad
 1611  1066  A0 06             LDY #6  ; 4 digits max
 1612  1068  4C AC 08          JMP PrDec16Lp1
 1613                  
 1614  106B            CRLF    
 1615  106B  A9 0D             LDA #CR
 1616  106D  20 ED 12          JSR OUTPUT
 1617  1070  A9 0A             LDA #LF
 1618  1072  4C ED 12          JMP OUTPUT
 1619                  
 1620  1075            ANYKEY  
 1621  1075  20 A4 12          JSR Get_Chr
 1622  1078  20 1A 10          JSR PRINT
 1623  107B  0D 0A             .BYTE   CR,LF
 1624  107D  50 52 45          .BYTE   'PRESS ANY KEY WHEN READY >',0
       1080  53 53 20  
       1083  41 4E 59  
       1086  20 4B 45  
       1089  59 20 57  
       108C  48 45 4E  
       108F  20 52 45  
       1092  41 44 59  
       1095  20 3E 00  
 1625  1098  20 BC 12          JSR INKEY
 1626  109B  48                PHA
 1627  109C  20 1A 10          JSR PRINT
 1628  109F  0D 0A 00          .BYTE   CR,LF,0
 1629  10A2  68                PLA
 1630  10A3  60                RTS
 1631                  
 1632  10A4            DRWMENU
 1633  10A4  20 32 0F          JSR INITPIA
 1634  10A7  D0 23             BNE DRWMNK
 1635  10A9  20 1A 10          JSR PRINT
 1636  10AC  0D 0A 0D          .BYTE $D,$A,$D,$A,'** NO DISK CTRL DETECTED **',0
       10AF  0A 2A 2A  
       10B2  20 4E 4F  
       10B5  20 44 49  
       10B8  53 4B 20  
       10BB  43 54 52  
       10BE  4C 20 44  
       10C1  45 54 45  
       10C4  43 54 45  
       10C7  44 20 2A  
       10CA  2A 00     
 1637  10CC            DRWMNK
 1638  10CC  20 1A 10           JSR PRINT
 1639  10CF  0D 0A 0D          .BYTE $D,$A,$D,$A
       10D2  0A        
 1640  10D3  4F 53 49          .BYTE 'OSI DESTRUCTIVE DiskTest',$D,$A          
       10D6  20 44 45  
       10D9  53 54 52  
       10DC  55 43 54  
       10DF  49 56 45  
       10E2  20 44 69  
       10E5  73 6B 54  
       10E8  65 73 74  
       10EB  0D 0A     
 1641  10ED  2D 2D 2D          .BYTE '------------------------',$D,$A          
       10F0  2D 2D 2D  
       10F3  2D 2D 2D  
       10F6  2D 2D 2D  
       10F9  2D 2D 2D  
       10FC  2D 2D 2D  
       10FF  2D 2D 2D  
       1102  2D 2D 2D  
       1105  0D 0A     
 1642  1107  31 2E 20          .BYTE '1. Test Disk',$D,$A
       110A  54 65 73  
       110D  74 20 44  
       1110  69 73 6B  
       1113  0D 0A     
 1643  1115  32 2E 20          .BYTE '2. Test Track',$D,$A
       1118  54 65 73  
       111B  74 20 54  
       111E  72 61 63  
       1121  6B 0D 0A  
 1644  1124  33 2E 20          .BYTE '3. Select Drive',$D,$A      
       1127  53 65 6C  
       112A  65 63 74  
       112D  20 44 72  
       1130  69 76 65  
       1133  0D 0A     
 1645  1135  34 2E 20          .BYTE '4. Set Drive Type',$D,$A      
       1138  53 65 74  
       113B  20 44 72  
       113E  69 76 65  
       1141  20 54 79  
       1144  70 65 0D  
       1147  0A        
 1646  1148  35 2E 20          .BYTE '5. Set Pattern & passes',$D,$A
       114B  53 65 74  
       114E  20 50 61  
       1151  74 74 65  
       1154  72 6E 20  
       1157  26 20 70  
       115A  61 73 73  
       115D  65 73 0D  
       1160  0A        
 1647  1161  36 2E 20          .BYTE '6. Toggle read only',$D,$A
       1164  54 6F 67  
       1167  67 6C 65  
       116A  20 72 65  
       116D  61 64 20  
       1170  6F 6E 6C  
       1173  79 0D 0A  
 1648  1176  37 2E 20          .BYTE '7. RPM Test',$D,$A 
       1179  52 50 4D  
       117C  20 54 65  
       117F  73 74 0D  
       1182  0A        
 1649  1183  38 2E 20          .BYTE '8. Status screen',$D,$A 
       1186  53 74 61  
       1189  74 75 73  
       118C  20 73 63  
       118F  72 65 65  
       1192  6E 0D 0A  
 1650  1195  39 2E 20          .BYTE '9. Exit',$D,$A          
       1198  45 78 69  
       119B  74 0D 0A  
 1651  119E  0D 0A             .BYTE $D,$A
 1652  11A0  44 72 76          .BYTE 'Drv=',$0
       11A3  3D 00     
 1653  11A5  A5 2D             LDA DRVNUM
 1654  11A7  18                CLC
 1655  11A8  69 41             ADC #$41
 1656  11AA  20 ED 12          JSR OUTPUT
 1657  11AD  A5 2B             LDA MAXPAG
 1658  11AF  C9 0F             CMP #MAXPAG8
 1659  11B1  F0 1B             BEQ DRWMN1
 1660  11B3  C9 0A             CMP #MAXPAG5
 1661  11B5  F0 0B             BEQ DRWMN0
 1662  11B7  20 1A 10          JSR PRINT
 1663  11BA  2F 33 2E          .BYTE '/3.5 ',0
       11BD  35 20 00  
 1664  11C0  90 13             BCC DRWMN2
 1665                  
 1666  11C2  20 1A 10  DRWMN0  JSR PRINT
 1667  11C5  2F 35 2E          .BYTE '/5.25 ',0
       11C8  32 35 20  
       11CB  00        
 1668  11CC  90 07             BCC DRWMN2
 1669  11CE            DRWMN1
 1670  11CE  20 1A 10          JSR PRINT
 1671  11D1  2F 38 20          .BYTE '/8 ',0
       11D4  00        
 1672  11D5            DRWMN2
 1673  11D5  A5 33             LDA PATSEL
 1674  11D7  D0 15             BNE DRWMN3
 1675  11D9  20 1A 10          JSR PRINT
 1676  11DC  50 61 74          .BYTE 'Pattern $',0
       11DF  74 65 72  
       11E2  6E 20 24  
       11E5  00        
 1677  11E6  A5 34             LDA PATVAL
 1678  11E8  20 44 10          JSR PHEXA
 1679  11EB  4C 00 12          JMP DRWMN4
 1680  11EE            DRWMN3
 1681  11EE  20 1A 10          JSR PRINT
 1682  11F1  50 61 74          .BYTE 'Pattern random',0
       11F4  74 65 72  
       11F7  6E 20 72  
       11FA  61 6E 64  
       11FD  6F 6D 00  
 1683  1200            DRWMN4
 1684  1200  20 1A 10          JSR PRINT
 1685  1203  20 20 50          .BYTE '  Passes ',0
       1206  61 73 73  
       1209  65 73 20  
       120C  00        
 1686  120D  A5 35             LDA PASSES
 1687  120F  20 5B 10          JSR PDECA
 1688  1212  A5 63             LDA TESTTYPE
 1689  1214  F0 12             BEQ NORMTEST
 1690  1216  20 1A 10          JSR PRINT
 1691  1219  20 53 63          .BYTE ' Scope test',0
       121C  6F 70 65  
       121F  20 74 65  
       1222  73 74 00  
 1692  1225  4C 38 12          JMP RWRO
 1693  1228            NORMTEST
 1694  1228  20 1A 10          JSR PRINT
 1695  122B  20 4E 6F          .BYTE ' Normal test',0
       122E  72 6D 61  
       1231  6C 20 74  
       1234  65 73 74  
       1237  00        
 1696  1238            RWRO
 1697  1238  A5 36             LDA READONLY
 1698  123A  F0 11             BEQ RW
 1699  123C  20 1A 10          JSR PRINT
 1700  123F  20 52 65          .BYTE ' Read only',0
       1242  61 64 20  
       1245  6F 6E 6C  
       1248  79 00     
 1701  124A  4C 55 12          JMP PPROMPT
 1702  124D            RW
 1703  124D  20 1A 10          JSR PRINT
 1704  1250  20 52 2F          .BYTE ' R/W',0
       1253  57 00     
 1705  1255            PPROMPT
 1706  1255  20 1A 10          JSR PRINT
 1707  1258  20 3E 20          .BYTE ' > ',0
       125B  00        
 1708  125C  60                RTS
 1709                  
 1710                          ; Get key from polled key without waiting. Carry clear if no key
 1711                          ; Key returned in A. X,Y modified
 1712  125D            Get_Chr_Polled
 1713  125D  20 73 12          JSR Check_Keypress  ;any pressed keys?
 1714  1260  90 40             BCC NOKEY       ;no, dont get stuck in keypoller
 1715  1262  20 ED FE          JSR $FEED       ;yes - check keypoller
 1716  1265  48                PHA
 1717  1266  A9 00             LDA #$00
 1718  1268  8D 15 02          STA $0215       ;clear keypoller last key
 1719  126B            UNKEY
 1720  126B  20 73 12          JSR Check_Keypress  ;wait till key unpressed to prevent reading key twice 
 1721  126E  B0 FB             BCS UNKEY
 1722  1270  68                PLA
 1723  1271            HAVEKEY
 1724  1271  38                SEC
 1725  1272  60                RTS
 1726                  
 1727  1273            Check_Keypress
 1728  1273  24 30             BIT MACHINE
 1729  1275  70 2B             BVS NOKEY   ;don't poll C3 machine
 1730  1277  A9 FE             LDA #$FE    ;want all except first row with shift lock
 1731  1279  45 31             EOR INVKEYB
 1732  127B  8D 00 DF          STA $DF00   ; Select row
 1733  127E  8D 00 DF          STA $DF00   ; In case some time needed for signals to propagate
 1734  1281  AD 00 DF          LDA $DF00
 1735  1284  45 31             EOR INVKEYB ;C1 keyboard inverted
 1736  1286  48                PHA
 1737  1287  A9 00             LDA #$00    ;Deselect all rows
 1738  1289  45 31             EOR INVKEYB
 1739  128B  8D 00 DF          STA $DF00
 1740  128E  68                PLA
 1741  128F  F0 11             BEQ NOKEY   ; bail if no key pressed
 1742  1291  A0 07             LDY #$07    ; count bits 7 to 1
 1743  1293  A2 00             LDX #$00
 1744  1295            DEKEY
 1745  1295  0A                ASL A
 1746  1296  90 01             BCC *+3
 1747  1298  E8                INX
 1748  1299  88                DEY
 1749  129A  D0 F9             BNE DEKEY
 1750  129C  E0 01             CPX #$01    ;x has # cols pressed
 1751  129E  D0 02             BNE NOKEY   ;more than one or none = nokey
 1752  12A0  38                SEC 
 1753  12A1  60                RTS
 1754  12A2            NOKEY
 1755  12A2  18                CLC
 1756  12A3  60                RTS 
 1757                  
 1758  12A4            Get_Chr
 1759  12A4            FRACIANW  ; read from ACIA no wait  carry clear when no data
 1760  12A4  24 30             BIT MACHINE
 1761  12A6  30 0A             BMI FRAC1NW
 1762  12A8  AD 00 FC          LDA C2ACIA
 1763  12AB  4A                LSR A
 1764  12AC  90 03             BCC FRAC1NW-1
 1765  12AE  AD 01 FC          LDA C2ACIA+1
 1766  12B1  60                RTS
 1767  12B2            FRAC1NW
 1768  12B2  AD 00 F0          LDA C1ACIA
 1769  12B5  4A                LSR A    
 1770  12B6  90 F9             BCC FRAC1NW-1 
 1771  12B8  AD 01 F0          LDA C1ACIA+1
 1772  12BB  60                RTS
 1773                  
 1774                          ; Get key from serial or polled keyboard waiting for key.
 1775  12BC            INKEY
 1776  12BC  24 32             BIT VIDEO
 1777  12BE  10 03             BPL *+5         ; No
 1778  12C0  4C 00 FD          JMP $FD00       ; Polled keyboard
 1779  12C3            FRACIA              ;read from ACIA carry set on abort return value in A
 1780  12C3  24 30             BIT MACHINE
 1781  12C5  30 0B             BMI FRAC1
 1782  12C7            FRSER               ; read from C3
 1783  12C7  AD 00 FC          LDA C2ACIA
 1784  12CA  4A                LSR A    
 1785  12CB  90 FA             BCC FRSER 
 1786  12CD  AD 01 FC          LDA C2ACIA+1
 1787  12D0  18                CLC      
 1788  12D1            ACIARET
 1789  12D1  60                RTS
 1790  12D2            FRAC1               ;read from C1
 1791  12D2  AD 00 F0          LDA C1ACIA
 1792  12D5  4A                LSR A    
 1793  12D6  90 FA             BCC FRAC1 
 1794  12D8  AD 01 F0          LDA C1ACIA+1
 1795  12DB  18                CLC       
 1796  12DC  60                RTS
 1797                  
 1798                          ; Check if TX ready bit is set for serial. Carry set if ready
 1799  12DD            CheckTXReady
 1800  12DD  24 30             BIT MACHINE
 1801  12DF  30 06             BMI TOAC1B
 1802  12E1  AD 00 FC          LDA C2ACIA      ; wait for TxEmpty
 1803  12E4  4A                LSR A     
 1804  12E5  4A                LSR A     
 1805  12E6  60                RTS             ; Carry set if TX ready
 1806  12E7            TOAC1B
 1807  12E7  AD 00 F0          LDA C1ACIA 
 1808  12EA  4A                LSR A     
 1809  12EB  4A                LSR A     
 1810  12EC  60                RTS             ; Carry set if TX ready
 1811                  
 1812                          ; Write a character to serial or video. A modified
 1813  12ED            OUTPUT
 1814  12ED  24 32             BIT VIDEO
 1815  12EF  10 03             BPL TOACIA      ; No, not video system
 1816  12F1  4C 8A 13          JMP VIDOUT
 1817  12F4            TOACIA
 1818  12F4  48                PHA
 1819  12F5  24 30             BIT MACHINE
 1820  12F7  30 0C             BMI TOAC1
 1821  12F9            TOACIA1        
 1822  12F9  AD 00 FC          LDA C2ACIA      ; wait for TxEmpty
 1823  12FC  4A                LSR A     
 1824  12FD  4A                LSR A     
 1825  12FE  90 F9             BCC TOACIA1   
 1826  1300  68                PLA       
 1827  1301  8D 01 FC          STA C2ACIA+1 
 1828  1304  60                RTS       
 1829  1305            TOAC1
 1830  1305  AD 00 F0          LDA C1ACIA 
 1831  1308  4A                LSR A     
 1832  1309  4A                LSR A     
 1833  130A  90 F9             BCC TOAC1   
 1834  130C  68                PLA       
 1835  130D  8D 01 F0          STA C1ACIA+1 
 1836  1310  60                RTS 
 1837                  
 1838                          ; Video output routine
 1839                          ; video init for SYN600, SYNMON, CEGMON
 1840                          ; $FFE0 - cursor start
 1841                          ; $FFE1 - line len-1   (wrap position)
 1842                          ; $FFE2 - 00 = 1K vid, 01=2K vid otherwise serial or other ROM
 1843                          ; FFE0 65, 17, 00 (c1 ROM, cegmon)
 1844                          ; FFE0 40, 3F, 01 (c2 ROM)
 1845                          ; FFE0 4D, 2F, 01 (C1E cegmon 64x32)
 1846                          ; FFE0 CC, 2F, 00 (C1E cegmon 64x16)
 1847  1311            VIDINIT
 1848  1311  A9 00             LDA #$00
 1849  1313  85 70             STA VIDOFFSET
 1850  1315  85 6E             STA VIDDST
 1851  1317  8D AC 13          STA VIDCR+1     ;cursor start
 1852  131A  A0 80             LDY #$80        ;bottom line low
 1853  131C  AE E2 FF          LDX $FFE2
 1854  131F  F0 37             BEQ C1VID       ;1k screen
 1855  1321  E0 8D             CPX #$8D                ;NewMon UK101 $FB85 =  len
 1856  1323  F0 1D             BEQ NEWMON
 1857  1325  E0 AA             CPX #$AA
 1858  1327  F0 19             BEQ WEMON
 1859  1329  CA                DEX
 1860  132A  F0 10             BEQ C2VID
 1861  132C  E0 8C             CPX #$8C   ;newmon is 8D@FFE2
 1862  132E  F0 12             BEQ NEWMON
 1863  1330  E0 A9             CPX #$A9
 1864  1332  F0 0E             BEQ WEMON  ;wemon is AA@FFE2
 1865                  
 1866  1334            WHATVID ;assume C2-like video
 1867  1334  A2 D7             LDX #$D7        ;bottom line hi
 1868  1336  A9 40             LDA #$40        ;linelen
 1869  1338  85 72             STA VIDXMAX
 1870  133A  D0 37             BNE VIDINI2
 1871                          
 1872  133C            C2VID               ;C2VID  2k screen
 1873  133C  A9 40             LDA #$40        ;linelen
 1874  133E  A2 D7             LDX #$D7        ;bottom line hi
 1875  1340  D0 1A             BNE VIDINI1
 1876  1342            NEWMON
 1877  1342            WEMON
 1878  1342  A9 0C         LDA #$0C
 1879  1344  8D AC 13          STA VIDCR+1
 1880  1347  85 70             STA VIDOFFSET
 1881  1349  A9 40         LDA #$40
 1882  134B  85 72             STA VIDXMAX
 1883  134D  A2 D7             LDX #$D7
 1884  134F  EC 85 FB          CPX $FB85       ;$D3 or $D7
 1885  1352  F0 1F             BEQ VIDINI2
 1886  1354  A2 D3             LDX #$D3
 1887  1356  D0 1B             BNE VIDINI2 
 1888                          
 1889  1358            C1VID   ;C1VID  1K screen
 1890  1358  A9 20             LDA #$20
 1891  135A  A2 D3             LDX #$D3
 1892                  
 1893  135C            VIDINI1 ;read video settings from ROM
 1894  135C  48                PHA 
 1895  135D  AD E0 FF          LDA $FFE0
 1896  1360  A8                TAY
 1897  1361  29 0F             AND #$0F
 1898  1363  8D AC 13          STA VIDCR+1     ;cursor start
 1899  1366  38                SEC
 1900  1367  6D E1 FF          ADC $FFE1
 1901  136A  85 72             STA VIDXMAX
 1902  136C  98                TYA
 1903  136D  29 F0             AND #$F0
 1904  136F  A8                TAY             ;bottom line low
 1905  1370  85 70             STA VIDOFFSET
 1906  1372  68                PLA
 1907                  
 1908  1373            VIDINI2 
 1909                  
 1910  1373  85 71             STA VIDXLEN
 1911  1375  85 6C             STA VIDSRC
 1912                  
 1913  1377  8E EF 13          STX VIDCLR+2    ;D3E0 or D780
 1914  137A  8C EE 13          STY VIDCLR+1  
 1915  137D  8E 99 13          STX VIDFIX1+1   ;D3E0 or D780
 1916  1380  8C 98 13          STY VIDFIX1
 1917  1383  A9 D0             LDA #$D0
 1918  1385  85 6D             STA VIDSRC+1    ;init to D040 or D020
 1919  1387  85 6F             STA VIDDST+1    ;init to D000
 1920  1389  60                RTS
 1921                          
 1922  138A            VIDOUT
 1923  138A  84 62             STY YHOLD 
 1924  138C  C9 0D             CMP #CR
 1925  138E  F0 1B             BEQ VIDCR
 1926  1390  48                PHA
 1927  1391  C9 0A             CMP #LF
 1928  1393  F0 1B             BEQ VIDLF
 1929  1395  A4 70             LDY VIDOFFSET
 1930  1398            VIDFIX1=*+1
 1931  1397  99 C0 D6          STA $D6C0,Y
 1932  139A  C8                INY
 1933  139B  84 70             STY VIDOFFSET
 1934  139D  C4 72             CPY VIDXMAX
 1935  139F  D0 06             BNE VIDRETY
 1936  13A1  20 AB 13          JSR VIDCR
 1937  13A4  4C B0 13          JMP VIDLF
 1938  13A7            VIDRETY
 1939  13A7  A4 62             LDY YHOLD
 1940  13A9  68                PLA
 1941  13AA  60                RTS
 1942  13AB            VIDCR
 1943  13AB  A9 00             LDA #0
 1944  13AD  85 70             STA VIDOFFSET
 1945  13AF  60                RTS
 1946                  
 1947  13B0            VIDLF
 1948  13B0  A0 00             LDY #$00
 1949  13B2            VIDLF1
 1950  13B2  B1 6C             LDA (VIDSRC),Y  ;copy row by row
 1951  13B4  91 6E             STA (VIDDST),Y
 1952  13B6  C8                INY
 1953  13B7  C4 71             CPY VIDXLEN
 1954  13B9  D0 F7             BNE VIDLF1
 1955  13BB  98                TYA
 1956  13BC  18                CLC
 1957  13BD  65 6C             ADC VIDSRC
 1958  13BF  85 6C             STA VIDSRC
 1959  13C1  90 02             BCC VIDLF2
 1960  13C3  E6 6D             INC VIDSRC+1
 1961  13C5            VIDLF2
 1962  13C5  98                TYA
 1963  13C6  18                CLC
 1964  13C7  65 6E             ADC VIDDST
 1965  13C9  85 6E             STA VIDDST
 1966  13CB  90 02             BCC VIDLF3
 1967  13CD  E6 6F             INC VIDDST+1
 1968  13CF            VIDLF3  
 1969                  
 1970  13CF  A5 6F             LDA VIDDST+1
 1971  13D1  CD EF 13          CMP VIDCLR+2
 1972  13D4  D0 DA             BNE VIDLF1-2
 1973  13D6  A5 6E             LDA VIDDST
 1974  13D8  CD EE 13          CMP VIDCLR+1
 1975  13DB  D0 D3             BNE VIDLF1-2
 1976                  
 1977  13DD  A9 D0             LDA #$D0
 1978  13DF  85 6D             STA VIDSRC+1
 1979  13E1  85 6F             STA VIDDST+1
 1980  13E3  A9 00             LDA #$00
 1981  13E5  85 6E             STA VIDDST
 1982  13E7  A5 71             LDA VIDXLEN
 1983  13E9  85 6C             STA VIDSRC
 1984                  
 1985  13EB  A9 20             LDA #' '
 1986  13ED            VIDCLR
 1987  13ED  99 C0 D6          STA $D6C0,Y     ; Clear last line
 1988  13F0  C8                INY
 1989  13F1  C4 71             CPY VIDXLEN
 1990  13F3  D0 F8             BNE VIDCLR
 1991  13F5  C8                INY
 1992  13F6  4C A7 13          JMP VIDRETY
 1993                          
 1994                          
 1995                  
 1996                  ; Return an 8 bit "random" number in A
 1997                  ; X modified on return
 1998                  ; From http://forum.6502.org/viewtopic.php?f=2&t=5247 modified for better
 1999                  ; randomness
 2000  13F9            RAND
 2001  13F9  A5 3C             LDA RND+4       ; ADD B shifted, 
 2002  13FB  38                SEC             ; carry adds value 0x80
 2003  13FC  6A                ROR
 2004  13FD  65 39             ADC RND+1       ; add last value (E)
 2005  13FF  65 3D             ADC RND+5       ; add C
 2006  1401  85 38             STA RND         ; new number
 2007  1403  A2 04             LDX #4          ; move 5 numbers
 2008  1405            RPL
 2009  1405  B5 38             LDA RND,X
 2010  1407  95 39             STA RND+1,X     ; ..move over 1
 2011  1409  CA                DEX
 2012  140A  10 F9             BPL RPL         ; all moved?
 2013  140C  A5 38             LDA RND
 2014  140E  60                RTS
 2015                  
 2016                  ; From https://codebase64.org/doku.php?id=base:24bit_division_24-bit_result
 2017                  ; EXECUTES AN UNSIGNED INTEGER DIVISION OF A 24-BIT DIVIDEND BY A 24-BIT DIVISOR
 2018                  ; THE RESULT GOES TO DIVIDEND AND REMAINDER VARIABLES
 2019                  ;
 2020                  ; VERZ!!! 18-MAR-2017
 2021                  ; A, X, Y modified.
 2022                  
 2023  140F            DIV24   
 2024  140F  A9 00             LDA #0          ;PRESET REMAINDER TO 0
 2025  1411  85 4A             STA REMAINDER
 2026  1413  85 4B             STA REMAINDER+1
 2027  1415  85 4C             STA REMAINDER+2
 2028  1417  A2 18             LDX #24         ;REPEAT FOR EACH BIT: ...
 2029                  
 2030  1419            DIVLOOP
 2031  1419  06 44             ASL DIVIDEND    ;DIVIDEND LB & HB*2, MSB -> CARRY
 2032  141B  26 45             ROL DIVIDEND+1  
 2033  141D  26 46             ROL DIVIDEND+2
 2034  141F  26 4A             ROL REMAINDER   ;REMAINDER LB & HB * 2 + MSB FROM CARRY
 2035  1421  26 4B             ROL REMAINDER+1
 2036  1423  26 4C             ROL REMAINDER+2
 2037  1425  A5 4A             LDA REMAINDER
 2038  1427  38                SEC
 2039  1428  E5 47             SBC DIVISOR     ;SUBSTRACT DIVISOR TO SEE IF IT FITS IN
 2040  142A  A8                TAY             ;LB RESULT -> Y, FOR WE MAY NEED IT LATER
 2041  142B  A5 4B             LDA REMAINDER+1
 2042  142D  E5 48             SBC DIVISOR+1
 2043  142F  85 50             STA PZTEMP
 2044  1431  A5 4C             LDA REMAINDER+2
 2045  1433  E5 49             SBC DIVISOR+2
 2046  1435  90 0A             BCC SKIP        ;IF CARRY=0 THEN DIVISOR DIDN'T FIT IN YET
 2047                  
 2048  1437  85 4C             STA REMAINDER+2 ;ELSE SAVE SUBSTRACTION RESULT AS NEW REMAINDER,
 2049  1439  A5 50             LDA PZTEMP
 2050  143B  85 4B             STA REMAINDER+1
 2051  143D  84 4A             STY REMAINDER   
 2052  143F  E6 44             INC DIVIDEND    ;AND INCREMENT RESULT CAUSE DIVISOR FIT IN 1 TIMES
 2053                  
 2054  1441            SKIP
 2055  1441  CA                DEX
 2056  1442  D0 D5             BNE DIVLOOP 
 2057  1444  60                RTS
 2058                  
 2059                  
 2060                  ; From https://codebase64.org/doku.php?id=base:24bit_multiplication_24bit_product
 2061                  ; Multiply REMAINDER by DIVIDEND with result in DIVIDEND
 2062  004A            factor1 = REMAINDER
 2063  0044            product = DIVIDEND
 2064  1445            MULT24
 2065  1445  A9 00             LDA #$00        ; set product to zero
 2066  1447  85 44             STA product
 2067  1449  85 45             STA product+1
 2068  144B  85 46             STA product+2
 2069                  
 2070  144D            mloop
 2071  144D  A5 4D             LDA factor2     ; while factor2 != 0
 2072  144F  D0 09             BNE nz
 2073  1451  A5 4E             LDA factor2+1
 2074  1453  D0 05             BNE nz
 2075  1455  A5 4F             LDA factor2+2
 2076  1457  D0 01             BNE nz
 2077  1459  60                RTS
 2078  145A            nz
 2079  145A  A5 4D             LDA factor2     ; if factor2 is odd
 2080  145C  29 01             AND #$01
 2081  145E  F0 13             BEQ mskip
 2082                          
 2083  1460  A5 4A             LDA factor1     ; product += factor1
 2084  1462  18                CLC
 2085  1463  65 44             ADC product
 2086  1465  85 44             STA product
 2087                          
 2088  1467  A5 4B             LDA factor1+1
 2089  1469  65 45             ADC product+1
 2090  146B  85 45             STA product+1
 2091                          
 2092  146D  A5 4C             LDA factor1+2
 2093  146F  65 46             ADC product+2
 2094  1471  85 46             STA product+2   ; end if
 2095                  
 2096  1473            mskip
 2097  1473  06 4A             ASL factor1     ; << factor1 
 2098  1475  26 4B             ROL factor1+1
 2099  1477  26 4C             ROL factor1+2
 2100  1479  46 4F             LSR factor2+2   ; >> factor2
 2101  147B  66 4E             ROR factor2+1
 2102  147D  66 4D             ROR factor2
 2103                  
 2104  147F  4C 4D 14          JMP mloop       ; end while 
 2105                  
 2106                  ; Status screen for displaying drive inputs
 2107                  ;  Commands:
 2108                  ;  Z- Zero Head   U - Step Up  D - Step Down   E Exit
 2109                  ;  R - Read Trk(not implemented) H - load/unload head 
 2110                  ;  S - Select disk, W - Write
 2111                  ;
 2112  002F            LASTPIA = TMP       ; need a storage location
 2113  1482            STATSCRN
 2114  1482  A9 AA             LDA #$AA
 2115  1484  85 2F             STA LASTPIA
 2116  1486  20 32 0F          JSR INITPIA     ; Select disk
 2117  1489  20 57 0F          JSR SELDRV
 2118  148C  A9 20             LDA #$20        ; Turn master select back off
 2119  148E  4D 02 C0          EOR DDPIA+2
 2120  1491  8D 02 C0          STA DDPIA+2
 2121                          ; JSR PRINT
 2122                          ;.BYTE $1B,$48,$D,$A,0 ;escape codes to Home cursor no big deal if terminal doesn't respond correctl
 2123                  
 2124  1494  20 1A 10          JSR PRINT
 2125  1497  0D 0A 0D          .BYTE $D,$A,$D,$A,'CMDS:(S)el (H)ead (W)rite Step:(U)p (D)own (Z)ero (E)xit',$D, $A
       149A  0A 43 4D  
       149D  44 53 3A  
       14A0  28 53 29  
       14A3  65 6C 20  
       14A6  28 48 29  
       14A9  65 61 64  
       14AC  20 28 57  
       14AF  29 72 69  
       14B2  74 65 20  
       14B5  53 74 65  
       14B8  70 3A 28  
       14BB  55 29 70  
       14BE  20 28 44  
       14C1  29 6F 77  
       14C4  6E 20 28  
       14C7  5A 29 65  
       14CA  72 6F 20  
       14CD  28 45 29  
       14D0  78 69 74  
       14D3  0D 0A     
 2126  14D5  20 0D 0A          .BYTE ' ',$D, $A
 2127  14D8  52 20 54          .BYTE 'R T F S R W S I',$D, $A
       14DB  20 46 20  
       14DE  53 20 52  
       14E1  20 57 20  
       14E4  53 20 49  
       14E7  0D 0A     
 2128  14E9  44 20 52          .BYTE 'D R A E D R e N',$D, $A
       14EC  20 41 20  
       14EF  45 20 44  
       14F2  20 52 20  
       14F5  65 20 4E  
       14F8  0D 0A     
 2129  14FA  59 20 4B          .BYTE 'Y K U C Y I l D',$D, $A
       14FD  20 55 20  
       1500  43 20 59  
       1503  20 49 20  
       1506  6C 20 44  
       1509  0D 0A     
 2130  150B  31 20 30          .BYTE '1 0 L T 2 T 1 E',$D, $A
       150E  20 4C 20  
       1511  54 20 32  
       1514  20 54 20  
       1517  31 20 45  
       151A  0D 0A     
 2131  151C  20 20 20          .BYTE '    T     P   X',$D, $A
       151F  20 54 20  
       1522  20 20 20  
       1525  20 50 20  
       1528  20 20 58  
       152B  0D 0A     
 2132  152D  00                .BYTE 0
 2133                  
 2134  152E            STATSCR2
 2135  152E  AD 00 C0          LDA DDPIA
 2136  1531            STATSCR5
 2137  1531  85 2F             STA LASTPIA
 2138  1533  A2 08             LDX #$08
 2139  1535            STATSCR1
 2140  1535  4A                LSR A
 2141  1536  48                PHA
 2142  1537  90 01             BCC *+3
 2143  1539  A9 30             LDA #$30
 2144  153B  2C A9 31          BIT $31A9
 2145  153E  20 ED 12          JSR OUTPUT
 2146  1541  A9 20             LDA #$20
 2147  1543  20 ED 12          JSR OUTPUT
 2148  1546  68                PLA
 2149  1547  CA                DEX
 2150  1548  D0 EB             BNE STATSCR1
 2151  154A  20 1A 10          JSR PRINT
 2152  154D  20 54 52          .BYTE ' TRK ',0
       1550  4B 20 00  
 2153  1553  A5 2E             LDA TRK
 2154  1555  20 8E 08          JSR PrDec2Dig
 2155  1558  A9 0D             LDA #$0D
 2156  155A  20 ED 12          JSR OUTPUT      ;keep redrawing current line- no LF
 2157  155D            STATSCR4
 2158  155D  24 32             BIT VIDEO
 2159  155F  10 06             BPL STATSER     ; No
 2160  1561  20 5D 12          JSR Get_Chr_Polled
 2161  1564  4C 6A 15          JMP *+6
 2162  1567            STATSER
 2163  1567  20 A4 12          JSR Get_Chr
 2164  156A  B0 0A             BCS STATSCR3
 2165  156C  AD 00 C0          LDA DDPIA
 2166  156F  C5 2F             CMP LASTPIA
 2167  1571  F0 EA             BEQ STATSCR4    ;no change, no update
 2168  1573  4C 31 15          JMP STATSCR5
 2169  1576            STATSCR3
 2170  1576  29 5F             AND #$5F
 2171  1578  AA                TAX
 2172                          ;CMP #'R        ; READ TRACK/Show Part
 2173                          ;BNE *+8
 2174                          ;JSR VIEWTRK
 2175                          ;JMP STATSCR2
 2176  1579  E0 53             CPX #'S
 2177  157B  D0 0B             BNE CHECKLOAD
 2178  157D  A9 20             LDA #$20
 2179  157F  4D 02 C0          EOR DDPIA+2
 2180  1582  8D 02 C0          STA DDPIA+2
 2181  1585  4C 2E 15          JMP STATSCR2
 2182  1588            CHECKLOAD
 2183  1588  E0 48             CPX #'H
 2184  158A  D0 0B             BNE CHKWRITE
 2185  158C  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2186  158F  49 80             EOR #$80        ; TOGGLE HEAD LOAD
 2187  1591  8D 02 C0          STA DDPIA+2 
 2188  1594  4C 2E 15          JMP STATSCR2
 2189  1597            CHKWRITE
 2190  1597  E0 57             CPX #'W
 2191  1599  D0 1C             BNE CHKEXIT
 2192  159B  A9 20             LDA #$20
 2193  159D  2C 02 C0          BIT DDPIA+2     ; TEST DRIVE SEL
 2194  15A0  F0 0A             BEQ WRITNOIDX
 2195  15A2  2C 00 C0          BIT DDPIA       ; WAIT 
 2196  15A5  30 FB             BMI *-3         ; INDEX PULSE
 2197  15A7  2C 00 C0          BIT DDPIA       ; WAIT END OF
 2198  15AA  10 FB             BPL *-3         ; INDEX PULSE
 2199  15AC            WRITNOIDX
 2200  15AC  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2201  15AF  49 03             EOR #$03        ; TOGGLE WRITE AND ERASE ENABLE
 2202  15B1  8D 02 C0          STA DDPIA+2 
 2203  15B4  4C 2E 15          JMP STATSCR2
 2204  15B7            CHKEXIT
 2205  15B7  E0 45             CPX #'E
 2206  15B9  D0 0B             BNE CHKUP
 2207  15BB  AD 02 C0          LDA DDPIA+2     ; PRESERVE DISK SEL BIT
 2208  15BE  09 A3             ORA #$A3        ; TURN OFF HEAD LOAD, SELECT, AND WRITE
 2209  15C0  8D 02 C0          STA DDPIA+2 
 2210  15C3  4C A1 03          JMP TOP
 2211                  
 2212  15C6            CHKUP
 2213  15C6  A9 20             LDA #$20
 2214  15C8  2C 02 C0          BIT DDPIA+2
 2215  15CB  F0 11             BEQ JSTATSCR2   ; Can't move head if drive not selected
 2216                  
 2217  15CD  E0 55             CPX #'U
 2218  15CF  D0 06             BNE *+8
 2219  15D1  20 D8 0F          JSR TNEXT       ; STEP TO NEXT TRACK
 2220  15D4  4C 2E 15          JMP STATSCR2
 2221  15D7  E0 44             CPX #'D
 2222  15D9  D0 06             BNE *+8
 2223  15DB  20 B6 0F          JSR TPREV       ; STEP TO PREV TRACK
 2224  15DE            JSTATSCR2
 2225  15DE  4C 2E 15          JMP STATSCR2
 2226  15E1  E0 5A             CPX #'Z
 2227  15E3  D0 03             BNE *+5
 2228  15E5  20 74 0F          JSR TZERO       ; STEP TO TRACK 0
 2229  15E8  4C 2E 15          JMP STATSCR2
 2230                           
 2231                  
 2232                  ;VIEWTRK ;placeholder for View Track function   
 2233                  ;   RTS 
 2234  15EB            BUFFER  =   *
 2235  15EB            *=*+BYTES8 ;space for track buffer
 2236  23FB            BUFFER2 =   *
 2237                  ;space for track buffer. We may write more data than this but will not
 2238                  ;use the extra data written. Don't put anything that can't be overwritten
 2239                  ;after this
 2240  23FB            *=*+[BYTES8+BYTES8+2] 
 2241                  
 2242                  ;*=*+[MAXPAG8*2*256] ;space for track buffer
 2243                  
 2244  401D            .END

Errors   = 0
Warnings = 0
